---
title: 数据类型
date: 2020-07-04
---

```js
// 简单数据类型(不可改变,只能复制,按值传递)
1. Symbol
2. undefined
3. Boolean
4. Number
5. String
6. 值不可修改
7. 保存在栈内存中
8. 按值访问
9. 比较时值相等即相等
10. 复制时创建一个副本
11. 按值传递参数
12. 用typeof检测类型
----------------------------------------------------------------------------------------------
// 复杂数据类型(引用,可以改变,按引用传递)
1. Object
2. Array
3. Function
4. null
5. 值可以修改
6. 保存在堆内存中
7. 按引用访问
8. 比较时同一引用才相等
9. 复制其实是指针
10. 按值传递参数
11. 用instanceof检测类型
----------------------------------------------------------------------------------------------
// 栈和堆
1. 栈从上往下落,堆从下往上升,一般不会重合(内存)
----------------------------------------------------------------------------------------------
// 简单数据类型检测,返回值String, Number, Boolean, Object, undefined, function
1. typeOf(1) // 返回Numbner
    1. 能识别所有简单数据类型
    2. 识别函数
    3. 判断是否是引用类型(不可再细分,object)
    4. typeof null === 'object' // 历史问题
    5. typeof Symbol === 'function'
    6. typeof NaN === 'number'
    7. typeof document.all === 'undefined'
2. undefined == null // true, undefined是null派生出来的
3. NaN // 非数值
4. NaN !== NaN // true
5. isNaN(参数) // 判断参数是否是非数值,返回Boolean,会尝试把参数转为数字类型如 id = '16'
6. null 是关键词，而 undefined 是变量
7. typeof 性能比 instanceof 性能高
8. undefined 在旧版本的 IE 中是可以被改写的，如果要判断是不是 undefined，可以使用 'xx' === void 0
  1. void 0 返回的一直是 undefined，即使 undefined 被改写了，也可以是 void 10/100/1000
----------------------------------------------------------------------------------------------
// 复杂数据类型检验,typeof遇到复杂数据类型只会返回object
1. [] instanceof Array // 返回true
2. Object.prototype.toString 可以用来判断变量类型，和普通对象上的 toString 作用不一样
  1. Symbol.toStringTag 这个方法可以自定义 Object.prototype.toString 的返回值
     当你设置了 Symbol.toStringTag，再使用 Object.prototype.toString 时，返回的值
     是你设置的值，而不是原有的类型
----------------------------------------------------------------------------------------------
// 数值转换
1. Number(参数) // 参数要以数字开头, 会忽略开头0和空格,如果转换字符串则返回NaN,有两个参数的第二个为进制
2. parsetInt(参数) // 参数要以数字开头, 会忽略开头0和空格,如果转换字符串则返回NaN,有两个参数的第二个为进制
3. parseFloat(参数) // 参数要以数字开头, 会忽略开头0和空格,如果转换字符串则返回NaN,有两个参数的第二个为进制,第一个小数点有效
----------------------------------------------------------------------------------------------
// 字符串转换
1. String(参数) // 在不知道参数的类型时使用
2. toStirng() // 返回str的一个副本
----------------------------------------------------------------------------------------------
// boolean转换
1. 除0之外的所有数字转换为布尔值都为true
2. 除空之外的所有字符串转换为布尔值都为true
3. null和undefined转换为布尔值为false
4. 比较操作符返回值为boolean
----------------------------------------------------------------------------------------------
// 逻辑与操作符转换
逻辑与(只要有一个条件不成立则返回false)
如果操作数不是布尔值时:
1. 如果第一个操作数隐式类型转换后为true则返回最后一个操作数
2. 如果第一个操作数隐式类型转换后为false则返回第一个操作数
3. 有一个操作数是null则返回null
4. 有一个操作数是undefined则返回undefined
----------------------------------------------------------------------------------------------
// 逻辑或操作符转换
逻辑或(只要有一个条件成立则返回true)
如果操作数不是布尔值时:
1. 如果第一个操作数隐式类型转换后为true则返回第一个操作数
2. 如果第一个操作数隐式类型转换后为false则返回第二个操作数
3. 如果有两个操作数是null则返回null
4. 如果有两个操作数是undefined则返回undefined
5. 如果有两个操作数是NaN则返回NaN
----------------------------------------------------------------------------------------------
// 逻辑非操作符转换
1. 无论操作数是什么数据类型,都会返回一个布尔值
2. !!对该布尔值求反
----------------------------------------------------------------------------------------------
// 二元操作符 '+' 规则
1. 如果操作数是对象，则对象会转换为原始值
  1. 对象转为原始数据类型的值
    1. Symbol.ToPromitive
    2. Object.prototype.valueOf
    3. Object.prototype.toString
  2. 优先级按上述进行，valueOf 如果返回的不是原始值（即不是简单数据类型）的话，就会继续调用 toString
2. 如果其中一个操作数是字符串的话，另一个操作数也会转换成字符串，进行字符串拼接
3. 否则，两个操作数都将转换为数字或NaN，进行加法操作
4. 示例
  1. [] + []
    1. 返回 ''
    2. 因为 [][Symbol.ToPromitive] 不存在
    3. 继续执行 Object.prototype.valueOf，返回 []，不是原始值
    4. 继续执行 Object.prototype.toString，返回 ''
  2. [] + {}
    1. 返回 '[object Object]'
    2. [] 上面已解释，{}[Symbol.ToPromitive] 不存在
    3. 继续执行 Object.prototype.valueOf，返回 {}，不是原始值
    4. 继续执行 Object.prototype.toString，返回 '[object Object]'
  3. {} + []
    1. 这个如果是在非浏览器的控制台中手动输入时，返回值和第 2 题结果一样，如果是在浏览器控制台中输入时则返回的是 0
    2. 在控制台中 {} 会被认为是一个语句，也就是说 {} + []，就变成了 +[]
    3. 而 +[] 相当于 +''，所以返回的是 0
  4. {} + {}
    1. 这个如果是在非浏览器的控制台中手动输入时，返回值是 '[object Object][object Object]'
    2. 如果是在 chore 浏览器的控制台中手动输入时，返回值也是 '[object Object][object Object]'
    3. 如果是在非 chore 的浏览器的控制台中手动输入时，返回是 NaN
      1. 原因是第一个 {} 被当成了语句，所以 {} + {} 相当于 +{}
      2. 而 +{} 相当于 +'[object Object]'，所以返回的是 NaN
----------------------------------------------------------------------------------------------
// 可选链
const user = {
  address: {
    street: '街道',
    getNum() {
      return '80号'
    }
  }
}
1. 常规获取
  const street = user && user.address && user.address.street
  const num = user && user.address && user.address.getNum && user.address.getNum()
2. 可选链获取
  const street = user?.address?.street
  const num = user?.address?.getNum?.()
----------------------------------------------------------------------------------------------
// 空值合并运算符
1. 常规
  const b = null
  const a = b || 5 // 当 b 隐式转换是 true 时取 b，否则取 5
2. 空值合并运算符
  const b = null
  const a = b ?? 5 // 只有 b 是 null 或 undefined 时才会取 5，而常规中 b 的值是 0 或空字符或 false 都会取 5
----------------------------------------------------------------------------------------------
// truly和falsely
1. !!变量 === true // truly变量
2. !!变量 === false // falsely变量
3. if里判断就是这两种变量
----------------------------------------------------------------------------------------------
// js错误类型
1. syntaxError // 语法错误
    符号漏打、多大、少打、错打
    使用了不符合语法的变量名
    语句写错,没写完
2. referenceError // 变量引用异常或未定义
3. typeError // 类型使用错误
4. ranggeError // 递归爆栈,深度太深错误
5. 捕获错误
    try {
      code
    } catch(ex) {
      code
    } finally {
      code
    }
6. throw new Error('err') // 抛出错误
7. debugger // 打断点
----------------------------------------------------------------------------------------------
// 其他
1. 在判断是否相等时只有判断是不是 == null 时使用两个等号,其他使用三个等号
2. blob对象表示一个不可变、原始数据的类文件对象
3. 不同的数据类型做比较 // 和数字或布尔做比较时，不管是什么类型都会转为数字
  1. 对象类型和对象类型做比较时，比的是引用地址
  2. 对象类型和字符串类型做比较时，对象类型会先转为字符串，再和字符串做比较 // toString()
  3. 对象类型和布尔类型做比较时，两边都要转为数字，对象会先尝试调用 valueOf() 方法获取结果，如果没定义，
     再尝试调用 toString 方法获取结果，最后调用 Number()
  4. 对象类型和数字类型做比较时，对象类型会转为数字，对象会先尝试调用 valueOf() 方法获取结果，如果没定义，
     再尝试调用 toString 方法获取结果，最后调用 Number()
  5. 数字类型和布尔类型做比较时，布尔类型会转为数字 // true == 1，false == 0
  6. 数字类型和字符串类型做比较时，字符串类型会转为数字 // Number()
  7. 布尔类型和字符串类型做比较时，字符串类型会转为数字 // Number()
  8. 示例
    '[object Object]' == {} // true
    '' == [] // true
    0 == [] // true
4. if 语句中的判断是调用 Boolean(xxx)，进行判断的
  1. 其值不是undefined或null的任何对象（包括其值为false的布尔对象）在传递给条件语句时都将计算为true。
     例如，以下if语句中的条件评估为true：
      var x = new Boolean(false);
      if (x) {
        // 这里的代码会被执行
      }
  2. Boolean 对象：如果省略或值0，-0，null，false，NaN，undefined，或空字符串（""），该对象具有的初始值false。
     所有其他值，包括任何对象，空数组（[]）或字符串"false"，都会创建一个初始值为true的对象
  3. 注意不要将基本类型中的布尔值 true 和 false 与值为 true 和 false 的 Boolean 对象弄混了。
5. 使用 + 号转数字时，如果数字是 ES6 的 BigInt 和 Symbol 时会报错，而不是返回 NaN
```
