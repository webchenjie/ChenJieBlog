---
title: 进阶知识
date: 2021-01-10
---

```js
// Redux
1. 相当于一个公共的存储区域和 vuex 类似
2. Redux = Reducer + Flux
3. 工作流程
  1. React Components 通过 dispatch（action）调用 Action Creators
  2. Action Creators 会通知到 Store
  3. Store 接收到 Action Creators 的两个参数即 previousState 和 action，会把这两个参数传递给 Reducers 中去操作
  4. Reducers 在创建 Store 时传递给了 Store
  5. Reducers 在操作完成后把对应的 newState 返回给 Store
  6. React Components 监听到 store 的变化重新获取到 Store 中的 value
  7. 相当于学生到图书馆借书流程
    1. React Components 相当于学生
    2. Store 相当于图书馆管理员
    3. Reducers 相当于书本具体位置
    4. Action Creators 相当于学生向管理员借书的对话语句
4. 常用 API
  1. createStore
  2. store.dispatch
  3. store.getState
  4. store.subscribe
4. 示例
  // index.js
  import { createStore } from 'redux' // npm install redux
  import reducer from './reducer.js'
  const store = createStore(reducer)
  export default store
  // reducer.js
  import { INPUTCHANGE, ADDITEM } from './actionType.js'
  const defaultState = {
    value: '',
    list: []
  }
  export default (state = defaultState, action) => {
    if (action.type === INPUTCHANGE) {
      // reducer 可以接收 state，但是绝不能修改 state
      const newState = JSON.parse(JSON.stringify(state)) // 深拷贝
      newState.value = action.value
      return newState
    }
    if (action.type === ADDITEM) {
      // reducer 可以接收 state，但是绝不能修改 state
      const newState = JSON.parse(JSON.stringify(state)) // 深拷贝
      newState.list.push(state.value)
      newState.value = ''
      return newState
    }
    return state
  }
  // actionType.js
  export const INPUTCHANGE = 'inputChange'
  export const ADDITEM = 'addItem'
  // actionCreators.js
  import { INPUTCHANGE, ADDITEM } from './actionType.js'
  export const handleInputChangeAction = value => {
    type: INPUTCHANGE,
    value
  }
  export const handleAddItemAction = () => {
    type: ADDITEM
  }
  // 组件
  import React, { Component } from 'react' // 一定要引入 React 否则编译报错，虽然在代码没显式用到
  import store from './index.js'
  import { handleInputChangeAction, handleAddItemAction } from './actionCreators.js'
  import { INPUTCHANGE, ADDITEM } from './actionType.js'
  class App extends Component {
    constructor(props) {
      super(props)
      this.state = store.getState() // getState 方法是 store 自带的
      this.handleChange = this.handleChange.bind(this)
      this.handleAdd = this.handleAdd.bind(this)
      store.subscribe(this.handleStoreChange) // 订阅或监听 store 变化
    }
    render() {
      return (
        <div>
          {/* value 是 store 中存储的 */}
          <input value = { this.state.value } onChange = { this.handleChange } />
          <button onClick = { this.handleAdd }>添加</button>
        </div>
      )
    }
    handleStoreChange() {
      // 一旦 store 发生改变就重新获取 store 里的数据
      this.setState(store.getState()) // store.getState() 返回一个对象
    }
    handleChange(e) {
      const action = {
        // action 下必须有一个 type 字段用于给到 reducer 做区分，而其他 value 都可以自定义名称
        type: INPUTCHANGE,
        value: e.target.value
      }
      // 最好集中管理 action 函数，而不是像上面一个在组件中创建 action
      const action = handleInputChangeAction(e.target.value)
      store.dispatch(action)
    }
    handleAdd() {
      const action = {
        type: ADDITEM
      }
      // 最好集中管理 action 函数，而不是像上面一个在组件中创建 action
      const action = handleAddItemAction()
      store.dispatch(action)
    }
  }
export default App
----------------------------------------------------------------------------------------------
// redux chrome 扩展
在网上应用商店安装完扩展后，需要在创建 store 的时候传入第二个参数即
window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
----------------------------------------------------------------------------------------------
// Redux 设计和使用的三项原则
1. store 是唯一的
2. 只有 store 能够改变自己的内容 // reducer 只是返回了 newState
3. reducer 必须是纯函数 // 纯函数指的是，给定固定的输入，就一定会有固定的输出，而且不会有任何副作用（就是不能对参数做修改）
----------------------------------------------------------------------------------------------
// UI 组件和容器组件
1. UI 组件又称傻瓜组件，只负责页面显示，没有其他逻辑
2. 容器组件又称聪明组件，只负责页面的逻辑，不负责页面渲染
----------------------------------------------------------------------------------------------
// 无状态组件
1. 无状态组件就是一个函数，参数接收一个 props，函数返回一个 JSX
2. 如果一个 react 组件只有一个 render 的生命周期就可以用无状态组件代替
3. 无状态组件不需要继承 React.Component
4. 简单的 UI 组件就可以用无状态组件表示
----------------------------------------------------------------------------------------------
// redux-thunk 中间件
1. 中间件是 action 和 store 之间
2. redux 的中间件就是对 action 的 dispatch 的封装，action 如果返回的是一个对象会直接给到 store，如果返回的是一个函数就会给到 dispatch
3. redux-thunk 是 redux 的中间件，它使得 action 可以是一个函数
4. 可以在 action 中做异步操作，而不是在组件的生命周期中
5. 示例
  // store.js 
  import { createStore, applyMiddleware, compose } from 'redux' // npm install redux
  import thunk from 'redux-thunk' // npm install redux-thunk
  import reducer from './reducer.js'

  // 使用 thunk 和 devTools
  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : compose
  const enhancer = composeEnhancers(applyMiddleware(thunk))

  const store = createStore(reducer, enhancer)
  export default store
  // action.js
  // 本来是 return 一个对象，现在 return 一个函数
  // 这个函数接收一个参数是 dispatch
  // 组件可以直接调用这个 action，这个 action 就会去获取数据调用下一个 action
  export const getList = () => {
    return dispatch => {
      axios.get('url').then(res => {
        const action = {
          type: 'getList',
          data: res.data
        }
        dispatch(action)
      })
    }
  }
  // 组件
  componentDidMount() {
    const action = getList()
    store.dispatch(action)
  }
----------------------------------------------------------------------------------------------
// redux-saga 中间件
1. 示例
  // store.js 
  import { createStore, applyMiddleware, compose } from 'redux' // npm install redux
  import createSagaMiddleware from 'redux-saga' // npm install redux-saga
  import sagas from './saga.js' // 集中管理的文件
  import reducer from './reducer.js'

  // 使用 saga 和 devTools
  const sagaMiddleware = createSagaMiddleware()
  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : compose
  const enhancer = composeEnhancers(applyMiddleware(sagaMiddleware))

  const store = createStore(reducer, enhancer)
  sagaMiddleware.run(sagas)
  export default store
  // saga.js
  import { takeEvery, put } from 'redux-saga/effects'
  function* getList() {
    const res = yield axios.get('url')
    const action = {
      type: 'initList',
      list: res.data
    }
    yield put(action) // put 方法是 saga 中自带的，相当于 dispatch
  }
  function* sagas() {
    yield takeEvery('getList', getList) // 监听这个 getList 的 action
  }
  export default sagas
  // 组件
  componentDidMount() {
    const action = getList()
    store.dispatch(action)
  }
----------------------------------------------------------------------------------------------
// React-Redux 的使用
1. npm install react-redux
2. 示例
  // index.js
  import React from 'react'
  import ReactDOM from 'react-dom'
  import TodoList from './TodoList'
  import { Provider } from 'react-redux'
  import store from './store' // store 和正常定义的一样

  // 通过 Provider 让在里面的每个组件都能使用 store，还需要组件做连接
  const App = (
    <Provider store= { store }>
      <TodoList/>
    </Provider>
  )

  ReactDOM.render(App, document.getElementById('root'))
  // TodoList.js
  import React, { Component } from 'react'
  import { connect } from 'react-redux'

  class TodoList extends Component {
    render() {
      const {
        inputValue,
        handleChange,
        handleClick,
      } = this.props
      return (
        <div>
          <input value = { inputValue } onChange = { handleChange } />
          <botton onClick = { handleClick }>提交</button>
        </div>
      )
    }
  }

  // 通过 react-redux 中的 connect 方法把当前组件和 store 做连接
  // mapStateToProps，会把 store 中的数据映射到组件的 props 中
  // mapDispatchToProps 会把 store 的 dispatch 方法映射到组件的 props 中
  const mapStateToProps = state => {
    return {
      inputValue: state.inputValue
    }
  }
  const mapDispatchToProps = dispatch => {
    return {
      handleChange(e) {
        const action = {
          type: 'change',
          value: e.target.value
        }
        dispatch(action)
      },
      handleClick() {
        const action = {
          type: 'add',
          value: e.target.value
        }
        dispatch(action)
      }
    }
  }

  export default connect(mapStateToProps, mapDispatchToProps)(TodoList)
----------------------------------------------------------------------------------------------
// 实践
1. 使用 styled-components 写样式 // npm install styled-components
  import { injectGlobal } from 'styled-components'
  // 写全局样式必须跟 `` 反引号
  injectGlobal`
    html {
      margin: 0;
      padding: 0;
    }
  `
```
