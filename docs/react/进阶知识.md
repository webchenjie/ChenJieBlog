---
title: 进阶知识
date: 2021-01-10
---

```js
// Redux
1. 相当于一个公共的存储区域和 vuex 类似
2. Redux = Reducer + Flux
3. 工作流程
  1. React Components 通过 dispatch（action）调用 Action Creators
  2. Action Creators 会通知到 Store
  3. Store 接收到 Action Creators 的两个参数即 previousState 和 action，会把这两个参数传递给 Reducers 中去操作
  4. Reducers 在创建 Store 时传递给了 Store
  5. Reducers 在操作完成后把对应的 newState 返回给 Store
  6. React Components 监听到 store 的变化重新获取到 Store 中的 value
  7. 相当于学生到图书馆借书流程
    1. React Components 相当于学生
    2. Store 相当于图书馆管理员
    3. Reducers 相当于书本具体位置
    4. Action Creators 相当于学生向管理员借书的对话语句
4. 常用 API
  1. createStore
  2. store.dispatch
  3. store.getState
  4. store.subscribe
4. 示例
  // index.js
  import { createStore } from 'redux' // npm install redux
  import reducer from './reducer.js'
  const store = createStore(reducer)
  export default store
  // reducer.js
  import { INPUTCHANGE, ADDITEM } from './actionType.js'
  const defaultState = {
    value: '',
    list: []
  }
  export default (state = defaultState, action) => {
    if (action.type === INPUTCHANGE) {
      // reducer 可以接收 state，但是绝不能修改 state
      const newState = JSON.parse(JSON.stringify(state)) // 深拷贝
      newState.value = action.value
      return newState
    }
    if (action.type === ADDITEM) {
      // reducer 可以接收 state，但是绝不能修改 state
      const newState = JSON.parse(JSON.stringify(state)) // 深拷贝
      newState.list.push(state.value)
      newState.value = ''
      return newState
    }
    return state
  }
  // actionType.js
  export const INPUTCHANGE = 'inputChange'
  export const ADDITEM = 'addItem'
  // actionCreators.js
  import { INPUTCHANGE, ADDITEM } from './actionType.js'
  export const handleInputChangeAction = value => ({
    type: INPUTCHANGE,
    value
  })
  export const handleAddItemAction = () => ({
    type: ADDITEM
  })
  // 组件
  import React, { Component } from 'react' // 一定要引入 React 否则编译报错，虽然在代码没显式用到
  import store from './index.js'
  import { handleInputChangeAction, handleAddItemAction } from './actionCreators.js'
  import { INPUTCHANGE, ADDITEM } from './actionType.js'
  class App extends Component {
    constructor(props) {
      super(props)
      this.state = store.getState() // getState 方法是 store 自带的
      this.handleChange = this.handleChange.bind(this)
      this.handleAdd = this.handleAdd.bind(this)
      store.subscribe(this.handleStoreChange) // 订阅或监听 store 变化
    }
    render() {
      return (
        <div>
          {/* value 是 store 中存储的 */}
          <input value = { this.state.value } onChange = { this.handleChange } />
          <button onClick = { this.handleAdd }>添加</button>
        </div>
      )
    }
    handleStoreChange() {
      // 一旦 store 发生改变就重新获取 store 里的数据
      this.setState(store.getState()) // store.getState() 返回一个对象
    }
    handleChange(e) {
      const action = {
        // action 下必须有一个 type 字段用于给到 reducer 做区分，而其他 value 都可以自定义名称
        type: INPUTCHANGE,
        value: e.target.value
      }
      // 最好集中管理 action 函数，而不是像上面一个在组件中创建 action
      const action = handleInputChangeAction(e.target.value)
      store.dispatch(action)
    }
    handleAdd() {
      const action = {
        type: ADDITEM
      }
      // 最好集中管理 action 函数，而不是像上面一个在组件中创建 action
      const action = handleAddItemAction()
      store.dispatch(action)
    }
  }
export default App
----------------------------------------------------------------------------------------------
// redux chrome 扩展
1. 在网上应用商店安装完扩展后，需要在创建 store 的时候传入第二个参数即
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
2. 示例
  // store.js 
  import { createStore, compose } from 'redux' // npm install redux
  import reducer from './reducer.js'

  // 使用 devTools
  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : compose

  const store = createStore(reducer, composeEnhancers())
  export default store
----------------------------------------------------------------------------------------------
// Redux 设计和使用的三项原则
1. store 是唯一的
2. 只有 store 能够改变自己的内容 // reducer 只是返回了 newState
3. reducer 必须是纯函数 // 纯函数指的是，给定固定的输入，就一定会有固定的输出，而且不会有任何副作用（就是不能对参数做修改）
----------------------------------------------------------------------------------------------
// redux-thunk 中间件
1. 中间件是 action 和 store 之间
2. redux 的中间件就是对 action 的 dispatch 的封装，action 如果返回的是一个对象会直接给到 store，如果返回的是一个函数就会给到 dispatch
3. redux-thunk 是 redux 的中间件，它使得 action 可以是一个函数
4. 可以在 action 中做异步操作，而不是在组件的生命周期中
5. 示例
  // store.js 
  import { createStore, applyMiddleware, compose } from 'redux' // npm install redux
  import thunk from 'redux-thunk' // npm install redux-thunk
  import reducer from './reducer.js'

  // 使用 thunk 和 devTools
  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : compose
  const enhancer = composeEnhancers(applyMiddleware(thunk))

  const store = createStore(reducer, enhancer)
  export default store
  // action.js
  // 本来是 return 一个对象，现在 return 一个函数
  // 这个函数接收一个参数是 dispatch
  // 组件可以直接调用这个 action，这个 action 就会去获取数据调用下一个 action
  export const getList = () => {
    return dispatch => {
      axios.get('url').then(res => {
        const action = {
          type: 'getList',
          data: res.data
        }
        dispatch(action)
      })
    }
  }
  // 组件
  componentDidMount() {
    const action = getList()
    store.dispatch(action)
  }
----------------------------------------------------------------------------------------------
// redux-saga 中间件
1. 和 redux-thunk 一样做异步
2. 示例
  // store.js 
  import { createStore, applyMiddleware, compose } from 'redux' // npm install redux
  import createSagaMiddleware from 'redux-saga' // npm install redux-saga
  import sagas from './saga.js' // 集中管理的文件
  import reducer from './reducer.js'

  // 使用 saga 和 devTools
  const sagaMiddleware = createSagaMiddleware()
  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : compose
  const enhancer = composeEnhancers(applyMiddleware(sagaMiddleware))

  const store = createStore(reducer, enhancer)
  sagaMiddleware.run(sagas)
  export default store
  // saga.js
  import { takeEvery, put } from 'redux-saga/effects'
  function* getList() {
    const res = yield axios.get('url')
    const action = {
      type: 'initList',
      list: res.data
    }
    yield put(action) // put 方法是 saga 中自带的，相当于 dispatch
  }
  function* sagas() {
    yield takeEvery('getList', getList) // 监听这个 getList 的 action
  }
  export default sagas
  // 组件
  componentDidMount() {
    const action = getList()
    store.dispatch(action)
  }
----------------------------------------------------------------------------------------------
// React-Redux 的使用
1. npm install react-redux
2. 示例
  // index.js
  import React from 'react'
  import ReactDOM from 'react-dom'
  import TodoList from './TodoList'
  import { Provider } from 'react-redux'
  import store from './store' // store 和正常定义的一样

  // 通过 Provider 让在里面的每个组件都能使用 store，还需要组件做连接
  const App = (
    <Provider store = { store }>
      <TodoList/>
    </Provider>
  )

  ReactDOM.render(App, document.getElementById('root'))
  // TodoList.js
  import React, { Component } from 'react'
  import { connect } from 'react-redux'

  class TodoList extends Component {
    render() {
      const {
        inputValue,
        handleChange,
        handleClick,
      } = this.props
      return (
        <div>
          <input value = { inputValue } onChange = { handleChange } />
          <botton onClick = { handleClick }>提交</button>
        </div>
      )
    }
  }

  // 通过 react-redux 中的 connect 方法把当前组件和 store 做连接
  // mapStateToProps，会把 store 中的数据映射到组件的 props 中
  // mapDispatchToProps 会把 store 的 dispatch 方法映射到组件的 props 中
  const mapStateToProps = state => {
    return {
      inputValue: state.inputValue
    }
  }
  const mapDispatchToProps = dispatch => {
    return {
      handleChange(e) {
        const action = {
          type: 'change',
          value: e.target.value
        }
        dispatch(action)
      },
      handleClick() {
        const action = {
          type: 'add',
          value: e.target.value
        }
        dispatch(action)
      }
    }
  }

  export default connect(mapStateToProps, mapDispatchToProps)(TodoList)
----------------------------------------------------------------------------------------------
// 实践
1. 使用 styled-components 写样式 // npm install styled-components
  import { injectGlobal } from 'styled-components'
  // 写全局样式必须跟 `` 反引号
  injectGlobal`
    html {
      margin: 0;
      padding: 0;
    }
  `
  // 组件样式
  import styled from 'styled-components'
  import logo from '../static/logo.png'
  export const Header = styled.input.attrs({
    placeholder: '搜索' // 也可以写在 JSX 中
  })`
    width: 100px;
    height: 100px;
    color: red;
    &.class-name { // 当这个组件上有这个类名时，这个组件会有下面的样式
      color: green;
    }
    .iconfot { // 这个组件下有这个类名时，会修饰这个类对应的样式
      width: 50px;
      height: 50px;
    }
  `
  export const Content = styled.div`
    width: 100px;
    height: 100px;
    background: url(${logo}) // 本地的图片
    background: url(${props => props.imgUrl}) // 组件上传进来的图片
  `
  // 组件引用
  import React, { Component } from 'react'
  import { Header, Content } from 'style.js' // 就是上面的 styled-components 的 js 文件

  class TodoList extends Component {
    render() {
      return (
        <div>
          <Header />
          <Content />
        </div>
      )
    }
  }
  
  export default TodoList
2. 在使用 styled-components 写组件时如果需要使用 ref 则需要把 ref 改成 innerRef，否则拿不到真实的 DOM
----------------------------------------------------------------------------------------------
// redux 的 reducer 整合
1. 随着模块的增加，reducer 文件会越来越庞大，通过 redux 下的 combineReducers 可以整合小的 reducer
// reducer.js
import { combineReducers } from 'redux'
import headerReducers from './header/store/reducers.js'
const reducer = combineReducers({
  header: headerReducers
})
export default reducer
2. 通过在各个组件下新建 store 目录，再创建 reducer 文件，在每个组件中管理自己的 reducer
3. 最后通过 store 整合成一个大的 reducer，在使用时会多一层级，store.getState().header.value // 多了整合时起的 header
----------------------------------------------------------------------------------------------
// redux 的 reducer 通过 immutable 库管理
1. 我们都知道，在 reducer 操作 state 时，是不能修改到 state 的，只能返回一个新的 state
2. 为了避免我们的误操作，可以引入 immutable 来管理我们的 state
3. 示例
// reducer.js
  import { INPUTCHANGE } from './actionType.js'
  import { formJS } from 'immutable' // npm install immutable

  const defaultState = formJS({ // 返回一个 immutable 对象
    value: ''
  })
  export default (state = defaultState, action) => {
    if (action.type === INPUTCHANGE) {
      // reducer 可以接收 state，但是绝不能修改 state
      const newState = JSON.parse(JSON.stringify(state)) // 深拷贝
      newState.value = action.value
      return newState
      // 上面的方式是通过深拷贝返回了一个新的 state，而通过 immutable 可以通过以下方式
      // immutable 对象的 set 方法，会结合之前 immutable 对象的值和设置的值，返回一个全新的对象
      return state.set('value', action.value)
    }
    return state
  }
  // 组件，如果使用了 immutable，就不能再通过 state.inputValue 方式取值，需要通过 get 方法
  const mapStateToProps = state => {
    return {
      inputValue: state.get('inputValue')
    }
  }
4. 通过 immutable 来管理我们根目录的 reducer
5. 在获取修改 state 就可以直接都使用 immutable 下的方法了，不然各个组件下的 state 调用方法就会变成以下
    state.header.get('inputValue') // 先使用了 js 的调用方法调用 header，再使用 immutable 的 get 方法
    state.get('header').get('inputValue') // 都使用了 immutable 下的方法
    state.getIn(['header', 'inputValue']) // 和上同一效果
6. 示例
  // reducer.js
  // import { combineReducers } from 'redux' // 变成 redux-immutable
  import { combineReducers } from 'redux-immutable' // npm install redux-immutable
  import headerReducers from './header/store/reducers.js'
  const reducer = combineReducers({
    header: headerReducers
  })
  export default reducer
7. 注意：在 state 中的数据使用了 formJS 进行了转换，而在改变时，action 传过来的数据也需要通过 formJS 进行转换！！！
8. formJS() 对应的转换方法是 toJS()
9. 多次改变 state 数据的 set 操作 
    state.set('value', action.value).set('list', [])
    state.merge({ // 使用 merge 方法替换 set 方法
      value: action.value,
      list: []
    })
----------------------------------------------------------------------------------------------
// react-router-dom 路由
1. 示例
  // App.js
  import React from 'react'
  import ReactDOM from 'react-dom'
  import TodoList from './TodoList'
  import { BrowserRouter, Route, Link, useParams, useHistory } from 'react-router-dom' // npm install react-router-dom
  import Home from './pages/home'
  import Detail from './pages/detail'
  import { Provider } from 'react-redux'
  import store from './store' // store 和正常定义的一样

  // 通过 Provider 让在里面的每个组件都能使用 store，还需要组件做连接
  // 实际没有 `` 反引号，只是编辑器显示效果
  console.log(useParams().id) // 获取动态路由的参数
  console.log(useHistory().push('/')) // 跳转
  const App = (
    `<Provider store = { store }>
      <div>
        <BrowserRouter>
          <div>
            {/* Link 组件和 vue 的 router-link 类似 */}
            <Link to='/'>
              <TodoList/>
            </Link>
            {/* exact 表示只有 url 和 path 内容一样时才显示 */}
            <Route path='/' exact render={() => <div>home</div>}>
            <Route path='/detail' exact render={() => <div>detail</div>}>
            {/* 上面是匹配到路由渲染，下面是匹配到路由显示组件 */}
            <Route path='/' exact component={Home}>
            <Route path='/' exact component={Detail}>
          </div>
        </BrowserRouter>
      </div>
    </Provider>`
  )

  ReactDOM.render(App, document.getElementById('root'))
2. 动态路由
  1. 在 Link 组件的 to 属性上写 to = {`/detail/${id}`} 可以把对应参数传递到跳转的组件上去
  2. 在对应的组件上通过 this.props.match.params.id 获取
3. 带参路由
  1. 在 Link 组件的 to 属性上写 to = {`/detail?id=${id}`} 可以把对应参数传递到跳转的组件上去
  2. 在对应的组件上通过 this.props.location.search 获取
4. 重定向路由
  import { Redirect } from 'react-router-dom'
  render() { 
    return (
      <Redirect to='/' />
    )
  }
----------------------------------------------------------------------------------------------
// React.PureComponent 的使用
1. 因为使用了 react-redux 进行 store 的连接，当 store 中的数据发生变化时，每个连接的组件都会知道，都要重新执行 render
   有些数据的改变可能跟其他组件没关系，所以需要使用生命周期 shouldComponentUpdate 判断是否需要进行 render
   但是如果每个组件都需要这么做就太麻烦了，react 提供了一个 PureComponent 组件帮助我们做这些事
   前提是使用了 immutable 管理 store 中的数据，否则直接使用 PureComponent 会遇到坑，需要自己手写判断 shouldComponentUpdate
2. 实际上使用了 PureComponent 的组件，它的 shouldComponentUpdate 会进行浅比较，而不是深比较
3. 示例 // 把 Component 替换成 PureComponent 即可
  import React, { PureComponent } from 'react'
  class App extends PureComponent {}
4. React.memo 和 React.PureComponent 差不多，一个用于无状态组件（memo），一个用于普通组件（PureComponent）
  const Component = props => {}
  const areEqual = (prevProps, nextProps) => {
    /* 如果把 nextProps 传入 render 方法的返回结果和把 prevProps 传入 render 方法
       的返回结果一致则返回 true，否则返回 false
    */
  } 
  export default React.meno(Component, areEqual)
----------------------------------------------------------------------------------------------
// 异步组件
1. 示例
  // loadable.js
  import React from 'react'
  import Loadable from 'react-loadable' // npm install react-loadable

  const LoadableComponent = Loadable({
    loader: () => import('./TodoList'), // 动态加载当前目录下的组件文件
    loading() {
      return <div>正在加载</div> // 加载时显示的组件
    }
  })

  export default () => <LoadableComponent />
2. 当使用异步组件时，需要一个 loadable.js 文件做过渡加载，而在 App.js 中引入的文件也是这个过渡文件
3. 当有异步组件需要获取路由上的参数时，这时如果使用了这个过渡文件，则异步组件就拿不到路由上的参数
4. 需要使用 react-router-dom 中的 withRouter 方法
  // TodoList.js
  import React, { Component } from 'react'
  import { connect } from 'react-redux'
  import { withRouter } from 'react-router-dom' // 能让这个组件获取到路由上的参数

  class TodoList extends Component {
    render() {
      const {
        inputValue,
        handleChange,
        handleClick,
      } = this.props
      return (
        <div>
          <input value = { inputValue } onChange = { handleChange } />
          <botton onClick = { handleClick }>提交</button>
        </div>
      )
    }
  }

  // 通过 react-redux 中的 connect 方法把当前组件和 store 做连接
  // mapStateToProps，会把 store 中的数据映射到组件的 props 中
  // mapDispatchToProps 会把 store 的 dispatch 方法映射到组件的 props 中
  const mapStateToProps = state => {
    return {
      inputValue: state.inputValue
    }
  }
  const mapDispatchToProps = dispatch => {
    return {
      handleChange(e) {
        const action = {
          type: 'change',
          value: e.target.value
        }
        dispatch(action)
      },
      handleClick() {
        const action = {
          type: 'add',
          value: e.target.value
        }
        dispatch(action)
      }
    }
  }

  export default connect(mapStateToProps, mapDispatchToProps)(withRouter(TodoList))
5. 使用 React.lazy 和 React.Suspense 做异步组件
  import React from 'react'
  const Content = React.lazy(() => import('./content'))
  class App extends React.Component {
    render() {
      return (
        <React.Suspense fallback = { <div> loding... </div> }>
          <Content />
        </React.Suspense>
      )
    }
  }
----------------------------------------------------------------------------------------------
// React 高阶组件
1. 关于组件公共逻辑的抽离
  1. mixin 已被 react 弃用
  2. 使用高阶组件 HOC
  3. Render Props
2. HOC 示例
  // 高阶组件不是一种功能，而是一种模式
  const HOCFactory = Component => {
    class HOC extends React.Component {
      // 在此定义多个组件的公共逻辑
      render() {
        // 1. 透传 props
        // 2. 传递公共的参数
        return <Component {...this.props} 自定义参数 = { 自定义参数 } />
      }
    }
    return HOC
  }
  // 组件.js
  import HOCFactory from './HOC.js'
  import React from 'react'
  class App extends React.Component {}
  export default HOCFactory(App)
3. Render Props 示例
  // 通过一个函数将 class 组件的 state 作为 props 传递给纯函数组件
  class Factory extends React.Component {
    constructor(props) {
      super(props)
      this.state {
        // state 即多个组件的公共逻辑的数据
      }
    }

    render() {
      return <div>{ this.props.render(this.state) }</div>
    }
  }
  // 组件.js
  const App = () => {
    <Factory render = { props => <p>{props.a} {props.b}</p> } />
  }
----------------------------------------------------------------------------------------------
// react 组件渲染过程
1. props、state
2. render 生成 vnode
3. patch(ele, vnode)
----------------------------------------------------------------------------------------------
// react 组件更新过程
1. setState（newState） ——> dirtyComponents（可能有子组件，不只当前组件）
2. render 生成 newVnode
3. patch(ele, newVnode)
----------------------------------------------------------------------------------------------
// react-fiber 如何性能优化
1. 在组件 patch 的时候会被拆分为两个阶段
  1. reconciliation 阶段 // 执行 diff 算法，纯 js 计算
  2. commit 阶段 // 将 diff 算法结果渲染 DOM
2. 因为 js 是单线程，且和 DOM 渲染共用一个线程，当组件足够复杂，组件更新时计算和渲染的压力大
   同时再有 DOM 操作需求（动画、鼠标拖拽等）就会卡顿，如何解决？
    1. 将 reconciliation 阶段进行任务拆分 // commit 阶段无法拆分，涉及到浏览器
    2. DOM 需要渲染时暂停，空闲时恢复 // react-fiber
    3. 通过 window.requestIdleCallback 这个 API 能够知道什么时候空闲
```
