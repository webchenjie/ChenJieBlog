---
title: 高级知识
date: 2021-05-07
---

```js
// vue3 新特性
1. <div :[name]="msg" @[event]="handleEvent"></div> // 动态属性 key 和 val，都是 data 内定义的内容
2. 子组件通过 $attrs 可以获取到父组件传递过来的属性，在非 props 特性中常用到 // 非 props 特性看基础知识
3. 可以直接给子组件上写 'class'，对应的样式会生效
4. 如何改变引用类型的数据内容？
  1. 数组
    1. 使用数组自带的方法，如：push、pop、shift、unshift
    2. 改变数组引用，即使用新数组
    3. 直接更新指定数组的内容，如：this.arr[1] = 'chenj' // 在 vue2.x 中需使用 $set，不可直接改变
  2. 对象
    1. 改变对象引用，即使用新对象
    2. 直接新增对象内容，如：this.obj.name = 'chenj' // 在 vue2.x 中需使用 $set，不可直接新增
5. 绑定多个事件：<button @click="handleClick1(), handleClick2()">按钮</button>
6. 修饰符
  1. 事件修饰符：stop、prevent、capture、self、once、passive  
  2. 按键修饰符：enter、tab、delete、esc、up、down、left、right // 键盘按了对应的按键才会触发
  3. 鼠标修饰符：left、middle、right // 对应鼠标按键
  4. 精确修饰符：exact // 只有按下对应的按键且没有按其他的按键才会触发
7. v-modle
  1. 在 radio 中对应多个选项，每个都需要绑定同一个数据，且 value 是不一样的，绑定的数据是基础类型，如字符串
  2. 在 checkbox 中对应多个选项，每个都需要绑定同一个数据，且 value 是不一样的，绑定的数据的引用类型，如数组
  3. 在 checkbox 中对应单个选项，即表示是否勾选时，默认勾选时 true，不勾选是 false，可以通过 true-value 和 false-value 改变默认值
    <input type="checkbox" v-model="msg" true-value="yes" false-value="no" />
8. 父子组件传值
  1. 通过 v-bind 传递父组件的参数
    <erzi v-bind="params"></erzi> // params = { a: 1, b: 2, c: 3}，相当于传递了一个对象
    在子组件的 props 中接收 a、b、c
  2. 父组件传递参数时使用 id-num 语法，子组件接收使用 idNum 语法，一个使用 -，一个使用大写
  3. 非 props 特性
    1. 在子组件中使用 inheritAttrs: false，表示不接收父组件传递过来的属性，即不会在 html 标签上展示对应的属性
    2. 在子组件中使用 <div v-bind="$attrs"></div> 表示将父组件传递过来的所有属性都放在 div 这个标签上
    3. 在子组件中使用 $attrs 可以获取到父组件传递过来的属性
9. 在子组件中使用 emits: ['event1'] 表示这个组件向外触发了一个事件名是 event1 的事件，如果触发的事件名和定义的不一致会报警告
   也可以使用对象形式，可以对触发事件的参数做校验，如果不符合会报警告
   emits: {
    event1: agrs => {
       if (agrs < 0) { 
         return false 
       }
       return true
      }
   }
10. 实现 v-model
  // 父组件
  const app = Vue.createApp({
    data() {
      return {
        count: 1
      }
    },
    template: '<counter v-model="count" />'
  })
  // 子组件
  app.component('counter', {
    props: ['modelValue'], // 必须使用 modelValue
    methods: {
      handleClick() {
        this.$emit('update:modelValue', this.modelValue + 1)
      }
    },
    template: '<div @click="handleClick">{{ modelValue }}<div/>'
  })
11. 多个 v-model
  // 父组件
  const app = Vue.createApp({
    data() {
      return {
        count1: 1,
        count2: 2
      }
    },
    template: '<counter v-model:count1="count1" v-model:count2="count2" />'
  })
  // 子组件
  app.component('counter', {
    props: ['count1', 'count2'],
    methods: {
      handleClick1() {
        this.$emit('update:count1', this.count1 + 1)
      },
      handleClick2() {
        this.$emit('update:count2', this.count2 + 1)
      }
    },
    template: `
      <div @click="handleClick1">{{ count1 }}<div/>
      <div @click="handleClick2">{{ count2 }}<div/>
    `
  })
12. v-modle 自定义修饰符
  // 父组件
  const app = Vue.createApp({
    data() {
      return {
        count: 'a'
      }
    },
    template: '<counter v-model.uppercase="count" />'
  })
  // 子组件
  app.component('counter', {
    props: {
      modelValue: String,
      modelModifiers: { // 接收自定义修饰符
        default() {
          return {}
        }
      }
    }
    mounted() {
      console.log(this.modelModifiers) // uppercase
    },
    methods: {
      handleClick() {
        let newValue = this.modelValue + 'a'
        if (this.modelModifiers.uppercase) {
          newValue = newValue.toUpperCase()
        }
        this.$emit('update:modelValue', newValue)
      }
    },
    template: '<div @click="handleClick">{{ modelValue }}<div/>'
  })
13. 异步组件
  // 父组件
  const app = Vue.createApp({
    template: '<async-component />'
  })
  // 子组件
  app.component('async-component', Vue.defineAsyncComponent(() => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve({
          template: '<div >this is an async component<div/>'
        })
      }, 3000)
    })
  }))
14. provide/inject
  // 父组件
  const app = Vue.createApp({
    data() {
      return {
        count: 1
      }
    },
    provide() {
      return {
        count: this.count // 向下传递数据，注意 count 不会和 data 中的 count 同步变化！
      }
    }
    template: '<erzi />'
  })
  // 孙子组件
  app.component('sunzi', {
    inject: ['count'],
    template: '<div>{{ count }}</div>'
  })
15. 过渡和动画: 在标签上用<transition>内容</transition>包住
  // 入场过渡
  .v-enter-from {
    opacity: 0;
  }
  .v-enter-active {
    transition: opacity 1s; // 也可用animate动画
  }
  .v-enter-to {
    opacity: 1;
  }
  // 出场过渡
  .v-leave-from {
    opacity: 0;
  }
  .v-leave-active {
    transition: opacity 1s; // 也可用animate动画
  }
  .v-leave-to {
    opacity: 1;
  }
  // 动画
  @keyframes shake {
    0% {
      transform: translateX(-100px)
    }
    0% {
      transform: translateX(-50px)
    }
    100% {
      transform: translateX(50px)
    }
  }
  .v-enter-active {
    animation: shake 1s;
  }
  .v-leave-active {
    animation: shake 1s;
  }
  1. 如果给了 name 属性则 v- 就要对应 name 的 val 值，如 <transition name="hello"><组件/></transition>
      则 css 名称需要写成 .hello-enter-form 等
  2. 也可自定义类名，如： <transition enter-active-class="hello"><组件/></transition>
      则 css 名称需要写成 .hello 等
  3. 在<transition>标签内可写自定义属性和两种动画一起使用时 type="transition"，表示持续时间由transition决定
  4. 在<transition>标签内可写自定义属性和两种动画一起使用时 duration="1000"，表示持续时间为 1000ms
      也可以写一个对象，控制入场出场动画时间，如：:duration="{ enter: 1000, leave: 1000 }"
  5. 取消 css 动画，<transition :css="false">
      js动画: 在<transition>中定义事件,el、done为函数接收的参数
      @before-enter="函数名(el)"、@enter="函数名(el, done)"、@after-enter="函数名(el)"
      @before-leave="函数名(el)"、@leave="函数名(el, done)"、@after-leave="函数名(el)"
  6. 在 <transition-grop> 中的类名会多一个 v-move，其他都和 <transition> 一样
  7. 具体看基础知识
16. 自定义指令 
  app.directive('pos', {
    beforeMount() {
      console.log('beforeMount')
    },
    mounted(el, binding) {
      console.log(binding.value) // 等于号后面的值，如：v-pos="100"，即 100
      console.log(binding.agr) // 冒号后面的值，如：v-pos:left="100"，即 left
      console.log('mounted')
    },
    beforeUpdate() {
      console.log('beforeUpdate')
    },
    updated(el, binding) {
      console.log(binding.value) // 等于号后面的值，如：v-pos="100"，即 100
      console.log(binding.agr) // 冒号后面的值，如：v-pos:left="100"，即 left
      console.log('updated')
    },
    beforeUnmount() {
      console.log('beforeUnmount')
    },
    unmount() {
      console.log('unmount')
    }
  })
  如果一个指令中只有 mounted 和 updated 这两个生命周期函数，且里面的代码是一样的，则可以写成下面这种样子
  app.directive('pos', (el, binding) => {
    console.log(el)
    console.log(binding)
  })
  <组件 v-pos:left="100" /> // 100 也可以用 data 中的变量代替
17. 传送门 teleport 标签可以把里面的标签挂载到对应的 DOM 上去，且可以继续使用该组件中的变量等方法
  const app = Vue.createApp({
    data() {
      return {
        msg: 'hello'
      }
    },
    template: `
      <div class="container">
        <div class="box1">{{ msg }}</div>
        <teleport to="body">
          <div class="box1">{{ msg }}</div>
        </teleport>
      </div>
    `
  })
18. render 函数
  // 父组件
  const app = Vue.createApp({
    template: `
      <my-title :level="2">
        hello
      <my-title>
    `
  })
  // 子组件
  const app = Vue.createApp({
    props: ['level'],
    render() {
      const { h } = Vue
      return h('h' + this.level, {}, this.$slots.default())
    },
    // 上面的 render 函数和下面的 template 效果一样
    template: `
      <h1 v-if="level === 1"><solt /></h1>
      <h2 v-if="level === 2"><solt /></h2>
      <h3 v-if="level === 3"><solt /></h3>
      <h4 v-if="level === 4"><solt /></h4>
      <h5 v-if="level === 5"><solt /></h5>
      <h6 v-if="level === 6"><solt /></h6>
    `
  })
19. plugin 插件
  定义：
  const myPlugin = {
    install(app, options) {
      console.log(app) // vue 实例
      console.log(options) // 自定义参数
      app.provide('name', 'chenj') // 全局注入
      app.directive('focus', { // 全局指令
        mounted(el) {
          el.focus()
        }
      })
      app.mixin({
        mounted() {
          console.log('全局 mixin')
        }
      })
      app.config.globalProperties.$sayHello = 'hello'
    }
  }
  使用：
  const app = Vue.createApp({
    mounted() {
      console.log('mounted')
    }
  })
  app.use(myPlugin, { name: '自定义参数' })
```
