---
title: 基础知识
date: 2020-07-12
---

```js
// 单页应用和多页应用
1. 多页应用实际请求html页面,seo好,首页块,切换慢
2. 单页应用实际请求js动态渲染,seo差,首页慢,切换块
3. 单页应用也叫SPA
----------------------------------------------------------------------------------------------
1. new Vue({
  el: #id, // 挂载点
  data: {}, // 变量定义
  computed: {}, // 计算属性
  methods: {}, // 事件函数
  watch: {}, // 监听
  filters: {} // 过滤器
})
2. 插件表达式: {{ `data中的变量` }}
3. v-text="data中的变量" // 不能解析html标签
4. v-html="data中的变量" // 可以解析html标签
5. v-on的简写@,用于监听事件
6. v-bind的简写:,用于绑定变量
7. v-model,用于form双向绑定
8. v-if,只有当表达式或变量是true的时候才显示,否则会移除DOM
9. v-show,只有当表达式或变量是true的时候才显示,否则会加上display: none
10. <div v-for="(item, index) of list">
      {{ item }} // 循环的val值
      {{ index }} // 循环的下标
    </div>
11. vue的实例相当于vue的组件,两者相等,子组件也有data、methods等属性
----------------------------------------------------------------------------------------------
1. vue改变对象或数组内容的方法: vue.set/vm.$set
2. 在使用组件时当标签写在<ul>或<table>等的标签内时可使用<li is="组件名"></li>符合h5规范
3. 获取div上的元素时使用ref属性,在函数中使用this.$refs.属性名获取
4. 当ref属性在组件上的时候获取的是它的引用而不是DOM元素
5. 在除了根组件中的data是个函数,而不是对象
6. 在vue实例下以$开头的都是vue的属性或方法
7. 在使用if/for指令时可在其内容中加上key值表唯一
8. 在操作数组或对象时,不可以直接改变下标修改值,应使用其自带的方法或改变其引用进行修改,也可使用1.
9. 在使用for指令时,可以使用<template></template>占位符进行包裹,它不会再DOM中显示
10. for指令也可以对对象进行循环<div v-for="(val, key, index) of obj"></div>
11. 子组件不可直接修改父组件传递过来的值,如非要修改则需要在子组件的data中创建一个副本
12. props: {
      content: {
        type: [String, Number], // 类型
        required: true, // 必传
        default() {
          return arr/obj // 如果默认值是数组或对象则要写成函数形式,其他类型直接给默认值
        },
        validator: function(val) {
          return val.length > 5 // 自定义校验
        }
      }
    }
13. props特性: 父传子接,在子组件中可以直接使用传过来的内容,传递属性的参数和内容不会显示在DOM标签上
14. 非props特性: 父传子不接,在子组件中不可以使用传的内容,属性值会显示在DOM标签上
15. 给组件绑定原生的事件,正常需要通过<组件名 @click.native="handleClick"></组件名>事件修饰符native
16. 组件插槽: 当子组件的内容需要由父组件内容决定时使用
    子组件定义: <slot name="名称">默认值</slot>
    父组件使用: <子组件><div slot="名称">内容</div></子组件>
17. 作用域插槽: 在子组件的插槽上进行循环,把值用属性的方式传递
    子组件定义: <slot :item="item"></slot>
    父组件使用: <子组件><template slot-scopr="传递过来的值"><div>{{ 传递过来的值.item }}</div></template></子组件>
18. 动态组件: 通过在父组件中使用<component></component>
    <component :is="type" /> 再结合对type数据的更改进行显示不同的组件,type是组件名
19. 在子组件的模板上加上v-noce指令会被载入内存,里面的数据只绑定一次,不会刷新,只渲染一次,后面发生变化也不会改变
20. 通过总线进行非父子组件传值,在main.js中引入
    Vue.prototype.bus = new Vue()
    在函数中触发: this.bus.$emit('change', this.content)
    在生命周期中监听: this.bus.$on('change', function(val) { console.log(val) })
    要在emit的组件中的destroyed方法中去解绑事件,否则会造成内存泄露 // 不解绑事件会造成绑定事件的node节点无法回收，造成DOM泄漏
21. 过渡: 显示——隐藏,隐藏——显示,在标签上用<transition>内容</transition>包住
    .v-leave-active,
    .v-enter-active{
      transition: opacity 1s // 也可用animate动画
    }
    .v-leave-to,
    .-enter{
      opacity: 0
    }
22. 使用animate库动画: 在<transition>标签上自定义class名
    <transition enter-active-class="animated 动画名 也可用继续写transition过渡动画" />
    <transition leave-active-class="animated 动画名 也可用继续写transition过渡动画" />
    可以嵌套
    在<transition>标签内可写自定义属性和两种动画一起使用时type="transition",表示持续时间由transition决定
23. js动画: 在<transition>中定义事件,el、done为函数接收的参数
    @before-enter="函数名(el)"、@enter="函数名(el, done)"、@after-enter="函数名(el)"
    @before-leave="函数名(el)"、@leave="函数名(el, done)"、@after-leave="函数名(el)"
24. velocity.js: 动画库,写在@enter/@levave中
    velocity(el, { opacity: 1 }, { duration: 1000, complate: done })
    如果自己写要手动执行done()
25. 多个元素或组件的过渡,多个元素时需要添加属性,key值表示唯一值
    在<transition>加mode="in-out/out-in" // 先进入再隐藏/先隐藏再进入
    动态组件也是在外面加上<transition>
26. 列表过渡: 在列表外包一层<transition-group>循环列表,一样在样式中定义过渡效果
27. 使用@keyframes 动画名{ 0% { 样式 } 50% { 样式 } 100% { 样式 }}在样式中正常使用
28. 通过在<transition>标签内增加appear和appear-active-class="动画名"实现页面刚加载第一次就有动画
29. 动态路由: 点哪个请求哪个,接口参数不一样,在url上设置:to="'/' + id"
30. 按需加载: () => import('路径') // 路由或组件注册
31. key值也指唯一,vue会尽量复用DOM
32. 标签跳转: <router-link to="/" tag="li"></router> // tag="li" 可以变成li标签
33. 可以使用<keep-alive exckude="不被缓存的组件名"></keep-alive>实现页面ajax缓存,会一个activated()生命周期函数
34. 组件的name常用于递归组件,自己调用自己
----------------------------------------------------------------------------------------------
// 其他
1. 在vue中使用obj: { 0: [], 1: [] } = data,obj[0] = data[0]这种方式不会让DOM重新渲染,需要用this.$set()方法进行赋值
2. 可以在vue实例中加入mixins这个对象进行混入,可以把vue实例中复用的代码抽离到公用的地方,再通过mixins进行混入
    mixins: ['导入的对象'],混入的内容是vue的options,比如data、methods等,也有Vue.mixin()全局混入的方法
    mixins的缺点:
      变量来源不明确,不利于阅读
      多个mixin可能会造成命名冲突
      mixin和组件可能出现多对多的关系,复杂度较高
3. 在写.env环境变量时变量要以VUE_APP开头
4. 可以使用 'I18N' 这个库来实现国际化
5. 如果要实现搜索结果高亮可以通过遍历搜索出来的结果把结果外面加一个标签,使用v-html进行展示
6. 上拉或下拉容器移动原理是通过js动态改变position的位置
7. 点击哪个选哪个解决方法：动态的加class通过index和点击时的activeIndex相同时就加，实现点哪个选哪个
8. 点击哪个多选哪个解决方法：判断数组中的变量，如果是true就动态的加class，否则不加，实现多点哪个多选哪个
----------------------------------------------------------------------------------------------
// 脚手架
1. 要使用在public下的资源文件,需要通过在index.html中的link标签引入
2. 在src/assets中的资源文件,会经过webpack打包,需要在main.js中import
3. 在vue的script标签中也可以写原生的js
4. 在main.js中import了scss文件要注意这样会把scss编译成css,如果里面都是css那就没问题
   如果里面有变量或者方法,就需要在vue文件中import(和vue文件一起编译),这样才能取到里面的变量或方法
```
