---
title: 源码知识
date: 2021-10-23
---

```js
// 数据驱动（渲染流程）
1. 为什么在 Vue2 中，可以通过 this.msg 方式获取 data 或者 props 上的值？
    1. 原因就是这里 proxy 函数通过代理了 vm 实例，当通过 this. 方式访问时
       实际访问的是 this._data.msg 或者 this._props.msg，具体实现就是遍历
        data 或 props，然后把每个 key 传入了 proxy 方法进行代理，实际上
        vm 上并没有这个属性，但是代理完就会指向 _data 或 _props 下的属性
       在新版的 Vue2 中，用户自定义的 data、props、methods 会暴露到 vm 实例上
    2. 示例: src/core/instance/state proxy()
        const sharedPropertyDefinition = {
            enumerable: true,
            configurable: true,
            get: noop,
            set: noop
        }
        export function proxy (target: Object, sourceKey: string, key: string) {
            sharedPropertyDefinition.get = function proxyGetter () {
                return this[sourceKey][key]
            }
            sharedPropertyDefinition.set = function proxySetter (val) {
                this[sourceKey][key] = val
            }
            Object.defineProperty(target, key, sharedPropertyDefinition)
        }
        proxy(vm, `_data`, key)
        proxy(vm, `_props`, key)
2. 如果在 Vue2 的实例中没有传入 el 属性，则不会进行 DOM 渲染，在新版的 Vue2 中，mount 支持传入挂载的 el 节点
    1. 示例: src/core/instance/init initMixin()
        if (vm.$options.el) {
            vm.$mount(vm.$options.el)
        }
3. $mount：
   1. 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法
   2. 如果有 render 函数会直接使用 render 函数进行 mount，如果没有会判断 template
      它可以是一个字符串也可以是一个 DOM 对象，Vue 会获取该对象的 innerHTML
      如果没有 template 会拿 el 的 outerHTML，也就是说会优先使用 render ——> template ——> el
   3. 第一次渲染时会把原本的 HTML 中 id = 'app' 的 DOM 节点直接替换掉而不是插入
4. createElement：
    1. 把 children 转换成一维数组
    2. 判断是否是原生 HTML 标签或者是组件名称
    3. 生成 VNode
5. 渲染流程：new Vue ——> init ——> $mount ——> compile（如果是 Runtime-Only 则没有）——> render（createElement） ——> vnode ——> patch ——> DOM
----------------------------------------------------------------------------------------------
// 组件化
1. 组件 patch 流程：createComponent ——> 子组件初始化 ——> 子组件 render ——> 子组件 patch
2. activeInstance 为当前激活的 vm 示例，vm.$vnode 是组件的占位 vnode，vm._vnode 是组件的渲染 vnode
    1. vm.$vnode 占位 vnode 指的就是该组件的父 VNode，即 _parentVnode
    2. vm._vnode 渲染 vnode 指的就是该组件中的渲染 vnode
    3. vm._vnode.parent === vm.$vnode
3. 嵌套组件的插入顺序是先子后父
4. 配置合并（mixin 就是 mergeOptions）
    1. new Vue 根据对应的策略进行合并
    2. 组件配置会和大 Vue 的配置进行合并放在原型上
5. 生命周期（callHook），每个 Vue 实例的 $options 中的生命周期是个数组，会遍历执行
    1. beforeCreate 数据 data 等 watcher 执行前
    2. created 数据 data 等 watcher 执行后
    3. beforeMount 先父后子
    4. mounted 先子后父
    5. beforeUpdate watcher 执行完前执行
    6. updated watcher 执行完后执行
    7. beforeDestroy 先子后父
    8. destroyed 先子后父
6. 异步组件
    1. 异步组件实现的本质是 2 次渲染，先渲染成注释节点，当组件加载成功后，再通过 forceRender 重新渲染
    2. 异步组件 3 种实现方式中，高级异步组件的设计非常巧妙，它可以通过简单的配置实现了 lodaing、
        resolve、reject、timeout 4 种状态
    3. 示例
        1. 工厂函数
            Vue.component('HelloWorld', function(resolve, reject) {
                require(['./components/HelloWorld'], function(res) {
                    resolve(res)
                })
            })
        2. Promise
            Vue.component('HelloWorld', () => import('./components/HelloWorld.vue'))
        3. 高级组件
            Vue.component('HelloWorld', () => ({
                component: import('./components/HelloWorld.vue'),
                loading: {
                    template: '<div>loading</div>'
                },
                error: {
                    template: '<div>error</div>'
                },
                delay: 200,
                timeout: 1000
            }))
----------------------------------------------------------------------------------------------
// 响应式
1. nextTick
    1. nextTick 是要把执行的任务推入到一个队列中，在下一个 tick 同步执行
    2. 数据改变后触发渲染 watcher 的 update，但是 watchers 的 flush 是在 nextTick 后，
        所以重新渲染时异步的
2. Dep、Watcher、Observer（defineReactive）之间的关系
    1. Observer 主要作用就是遍历了 data，给 data 的每个 key 执行了 defineReactive
        defineReactive 主要作用就是使用 Object.defineProperty 给每个 key 加上了 getter、setter
        并且 new Dep()，getter 时会执行 dep.depend() 即收集当前 key 属性的 Watcher，
        在 setter 时会执行 dep.notify() 即会遍历 dep.subs 通知每个 Watcher 更新
    2. Watcher 主要作用是 update 方法用于更新操作，并且在 new Watcher 时会把 Dep.target = this
        即把 Dep.target 指向自己，最后释放 Dep.target = null，还有一个 addDep 方法用于调用
        Dep 中 addSub 方法，所以把 watcher push 进去的操作是在 Watcher 中执行的
        但是触发是在 Observer getter 时触发
    3. Dep 中有 subs 数组，由于存储 Watcher，有 addSub 用于 subs.push(watcher)
        notify 用于遍历 subs 通知所有 watcher for(let i = 0; i < subs.length; i++){ subs[i].update() }
    4. 总结
        1. Observer getter 触发依赖收集即 dep.depend()，depend 方法会判断如果有 Dep.target（指向 Watcher） 的话
            就会调用 Dep.target.addDep(Dep)，实际就是 Watcher.addDep(Dep)，而 addDep 就会调用 Dep.addSub(watcher)
            然后 addDep 会把 watcher push 到 subs 数组中
        2. Observer setter 触发派发更新即 dep.notify()，notify 方法会遍历 subs 中的每个 watcher，然后
            执行 watcher 中的 update()，update 方法就是更新操作
----------------------------------------------------------------------------------------------
// Event
1. event 在编译阶段生成相关的 data，对于 DOM 事件在 patch 过程中的创建阶段和更新阶段执行
    updateDOMListeners 生成 DOM 事件，对于自定义事件，会在组件初始化阶段通过 initEvents 创建
2. 原生 DOM 事件和自定义事件主要的区别在与添加和删除事件的方式不一样，并且自定义事件的派发
    是往当前实例上派发，但是可以利用在父组件环境定义回调函数来实现父子组件的通讯
----------------------------------------------------------------------------------------------
// keep-alive
1. 实际缓存的是 vnode，缓存数组会先删除最前面即最不常用的
2. 生命周期通过判断 vnode.data.keppAlive 变量决定调用特定的生命周期
3. 会调用 $forceUpdate 进行更新
4. 属于抽象组件，不会实际渲染，会渲染子节点
----------------------------------------------------------------------------------------------
// transition
1. 实际上源码只是管理了我们的 Css 类名，实际过渡效果还是通过 Css 实现的
2. transition-group 组件是为了做列表的过渡，它会渲染成真实的元素
3. 当我们去修改列表的数据的时候，如果是添加或删除数据，则会触发相应元素本身的过渡动画
    这点和 <transition> 组件实现效果一样，初次之外 <transition-group> 还实现了 move 的
    过渡效果，让我们的列表过渡动画更加丰富
----------------------------------------------------------------------------------------------
// Vue.use
1. 可以传一个函数或者对象，会默认执行对象中的 install 方法，如果没有 install 会判断是否传入的是函数
    是的话就执行，否则不执行
----------------------------------------------------------------------------------------------
// vue-router
1. Vue.use(vueRouter) 会执行
    1. 通过 Vue.mixin 混入了 beforeCreate 和 destroyed 生命周期的一些逻辑
    2. 全局注册了 <RouterView> 和 <RouterLink> 组件
    3. 在 Vue.prototype 上定义了 $router 和 $route 属性
2. 初始化（beforeCreate 中 init）
    1. 对于 History 路由做降级操作，如果浏览器不支持，则自动换成 Hash 路由
    2. 非浏览器环境还有一个 abstract 路由
    3. 生成了路由映射表，包含有 pathList、nameMap、pathMap
3. 路由始终会维护当前的线路，路由切换的时候会把当前线路切换到目标线路，切换过程中会执行一系列
    的导航守卫钩子函数，会更新 URL，同样也会渲染对应的组件，切换完毕后会把目标线路更新替换
    当前线路，这样就会作为下一次的路径切换的依据
----------------------------------------------------------------------------------------------
// 响应式
1. 数据驱动视图：UI = render(state) // state 即输入，UI 即页面输出，render 即 vm 层
2. Vue 如何知道 state 发生变化之 Object
    1. Object.defineProperty 可以让 Object 数据变得可观测
    2. 看一段源码：src/core/observer/index.js
    /**
     * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象
     */
    export class Observer {
        constructor (value) {
            this.value = value
            // 给value新增一个__ob__属性，值为该value的Observer实例
            // 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作
            def(value,'__ob__',this)
            if (Array.isArray(value)) {
                // 当value为数组时的逻辑
                // ...
            } else {
                this.walk(value)
            }
        }

        walk (obj: Object) {
            const keys = Object.keys(obj)
            for (let i = 0; i < keys.length; i++) {
                defineReactive(obj, keys[i])
            }
        }
    }
    /**
     * 使一个对象转化成可观测对象
     * @param { Object } obj 对象
     * @param { String } key 对象的key
     * @param { Any } val 对象的某个key的值
     */
    function defineReactive (obj,key,val) {
        // 如果只传了obj和key，那么val = obj[key]
        if (arguments.length === 2) {
            val = obj[key]
        }
        if(typeof val === 'object'){
            new Observer(val)
        }
        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get(){
                console.log(`${key}属性被读取了`);
                return val;
            },
            set(newVal){
                if(val === newVal){
                    return
                }
                console.log(`${key}属性被修改了`);
                val = newVal;
            }
        })
    }
    3. 在上面的代码中，我们定义了observer类，它用来将一个正常的object转换成可观测的object。
        并且给value新增一个__ob__属性，值为该value的Observer实例。这个操作相当于为value打上标记，
        表示它已经被转化成响应式了，避免重复操作。
        然后判断数据的类型，只有object类型的数据才会调用walk将每一个属性转换成getter/setter的形式来侦测变化。
        最后，在defineReactive中当传入的属性值还是一个object时使用new observer（val）来递归子属性，
        这样我们就可以把obj中的所有属性（包括子属性）都转换成getter/seter的形式来侦测变化.
        也就是说，只要我们将一个object传到observer中，那么这个object就会变成可观测的、响应式的object。
    4. 依赖收集
        1. 什么是依赖收集
            1. 在上一章中，我们迈出了第一步：让object数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，
                那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？
                总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。此时，你肯定会想到，
                视图里谁用到了这个数据就更新谁呗。对！你想的没错，就是这样。
            2. 视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把"谁用到了这个数据"称为"谁依赖了这个数据",
                我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)
                我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，
                告诉他们："你们依赖的数据变啦，你们该更新啦！"。这个过程就是依赖收集。
        2. 何时收集依赖？何时通知依赖更新？
            1. 明白了什么是依赖收集后，那么我们到底该在何时收集依赖？又该在何时通知依赖更新？
            2. 其实这个问题在上一小节中已经回答了，我们说过：谁用到了这个数据，那么当这个数据变化时就通知谁。
                所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发getter属性，
                那么我们就可以在getter中收集这个依赖。同样，当这个数据变化时会触发setter属性，
                那么我们就可以在setter中通知依赖更新。
        3. 把依赖收集到哪里
            1. 明白了什么是依赖收集以及何时收集何时通知后，那么我们该把依赖收集到哪里？
            2. 在4.1小节中也说了，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。
                单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，
                更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，
                我们的依赖管理器Dep类应运而生
```

## 1. 前言

在上一篇文章中，我们知道：数据驱动视图的关键点则在于我们如何知道数据发生了变化，只要知道数据在什么时候变了，那么问题就变得迎刃而解，我们只需在数据变化的时候去通知视图更新即可。

要想知道数据什么时候被读取了或数据什么时候被改写了，其实不难，`JS`为我们提供了`Object.defineProperty`方法，通过该方法我们就可以轻松的知道数据在什么时候发生变化。

## 2. 使 Object 数据变得“可观测”

数据的每次读和写能够被我们看的见，即我们能够知道数据什么时候被读取了或数据什么时候被改写了，我们将其称为数据变的‘可观测’。

要将数据变的‘可观测’，我们就要借助前言中提到的`Object.defineProperty`方法了，在本文中，我们就使用这个方法使数据变得“可观测”。

首先，我们定义一个数据对象`car`：

```javascript
let car = {
	brand: 'BMW',
	price: 3000
}
```

我们定义了这个`car`的品牌`brand`是`BMW`,价格`price`是 3000。现在我们可以通过`car.brand`和`car.price`直接读写这个`car`对应的属性值。但是，当这个`car`的属性被读取或修改时，我们并不知情。那么应该如何做才能够让`car`主动告诉我们，它的属性被修改了呢？

接下来，我们使用`Object.defineProperty()`改写上面的例子：

```javascript
let car = {}
let val = 3000
Object.defineProperty(car, 'price', {
	enumerable: true,
	configurable: true,
	get() {
		console.log('price属性被读取了')
		return val
	},
	set(newVal) {
		console.log('price属性被修改了')
		val = newVal
	}
})
```

通过`Object.defineProperty()`方法给`car`定义了一个`price`属性，并把这个属性的读和写分别使用`get()`和`set()`进行拦截，每当该属性进行读或写操作的时候就会触发`get()`和`set()`。如下图：

可以看到，`car`已经可以主动告诉我们它的属性的读写情况了，这也意味着，这个`car`的数据对象已经是“可观测”的了。

为了把`car`的所有属性都变得可观测，我们可以编写如下代码：

```javascript
// 源码位置：src/core/observer/index.js

/**
 * Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象
 */
export class Observer {
	constructor(value) {
		this.value = value
		// 给value新增一个__ob__属性，值为该value的Observer实例
		// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作
		def(value, '__ob__', this)
		if (Array.isArray(value)) {
			// 当value为数组时的逻辑
			// ...
		} else {
			this.walk(value)
		}
	}

	walk(obj: Object) {
		const keys = Object.keys(obj)
		for (let i = 0; i < keys.length; i++) {
			defineReactive(obj, keys[i])
		}
	}
}
/**
 * 使一个对象转化成可观测对象
 * @param { Object } obj 对象
 * @param { String } key 对象的key
 * @param { Any } val 对象的某个key的值
 */
function defineReactive(obj, key, val) {
	// 如果只传了obj和key，那么val = obj[key]
	if (arguments.length === 2) {
		val = obj[key]
	}
	if (typeof val === 'object') {
		new Observer(val)
	}
	Object.defineProperty(obj, key, {
		enumerable: true,
		configurable: true,
		get() {
			console.log(`${key}属性被读取了`)
			return val
		},
		set(newVal) {
			if (val === newVal) {
				return
			}
			console.log(`${key}属性被修改了`)
			val = newVal
		}
	})
}
```

在上面的代码中，我们定义了`observer`类，它用来将一个正常的`object`转换成可观测的`object`。

并且给`value`新增一个`__ob__`属性，值为该`value`的`Observer`实例。这个操作相当于为`value`打上标记，表示它已经被转化成响应式了，避免重复操作

然后判断数据的类型，只有`object`类型的数据才会调用`walk`将每一个属性转换成`getter/setter`的形式来侦测变化。
最后，在`defineReactive`中当传入的属性值还是一个`object`时使用`new observer（val）`来递归子属性，这样我们就可以把`obj`中的所有属性（包括子属性）都转换成`getter/seter`的形式来侦测变化。
也就是说，只要我们将一个`object`传到`observer`中，那么这个`object`就会变成可观测的、响应式的`object`。

`observer`类位于源码的`src/core/observer/index.js`中。

那么现在，我们就可以这样定义`car`:

```javascript
let car = new Observer({
	brand: 'BMW',
	price: 3000
})
```

这样，`car`的两个属性都变得可观测了。

## 3. 依赖收集

### 3.1 什么是依赖收集

在上一章中，我们迈出了第一步：让`object`数据变的可观测。变的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。那么问题又来了，视图那么大，我们到底该通知谁去变化？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。此时，你肯定会想到，视图里谁用到了这个数据就更新谁呗。对！你想的没错，就是这样。

视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把"谁用到了这个数据"称为"谁依赖了这个数据",我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们："你们依赖的数据变啦，你们该更新啦！"。这个过程就是依赖收集。

### 3.2 何时收集依赖？何时通知依赖更新？

明白了什么是依赖收集后，那么我们到底该在何时收集依赖？又该在何时通知依赖更新？

其实这个问题在上一小节中已经回答了，我们说过：谁用到了这个数据，那么当这个数据变化时就通知谁。所谓谁用到了这个数据，其实就是谁获取了这个数据，而可观测的数据被获取时会触发`getter`属性，那么我们就可以在`getter`中收集这个依赖。同样，当这个数据变化时会触发`setter`属性，那么我们就可以在`setter`中通知依赖更新。

总结一句话就是：**在 getter 中收集依赖，在 setter 中通知依赖更新**。

### 3.3 把依赖收集到哪里

明白了什么是依赖收集以及何时收集何时通知后，那么我们该把依赖收集到哪里？

在 3.1 小节中也说了，我们给每个数据都建一个依赖数组，谁依赖了这个数据我们就把谁放入这个依赖数组中。单单用一个数组来存放依赖的话，功能好像有点欠缺并且代码过于耦合。我们应该将依赖数组的功能扩展一下，更好的做法是我们应该为每一个数据都建立一个依赖管理器，把这个数据所有的依赖都管理起来。OK，到这里，我们的依赖管理器`Dep`类应运而生，代码如下：

```javascript
// 源码位置：src/core/observer/dep.js
export default class Dep {
	constructor() {
		this.subs = []
	}

	addSub(sub) {
		this.subs.push(sub)
	}
	// 删除一个依赖
	removeSub(sub) {
		remove(this.subs, sub)
	}
	// 添加一个依赖
	depend() {
		if (window.target) {
			this.addSub(window.target)
		}
	}
	// 通知所有依赖更新
	notify() {
		const subs = this.subs.slice()
		for (let i = 0, l = subs.length; i < l; i++) {
			subs[i].update()
		}
	}
}

/**
 * Remove an item from an array
 */
export function remove(arr, item) {
	if (arr.length) {
		const index = arr.indexOf(item)
		if (index > -1) {
			return arr.splice(index, 1)
		}
	}
}
```

在上面的依赖管理器`Dep`类中，我们先初始化了一个`subs`数组，用来存放依赖，并且定义了几个实例方法用来对依赖进行添加，删除，通知等操作。

有了依赖管理器后，我们就可以在 getter 中收集依赖，在 setter 中通知依赖更新了，代码如下：

```javascript
function defineReactive(obj, key, val) {
	if (arguments.length === 2) {
		val = obj[key]
	}
	if (typeof val === 'object') {
		new Observer(val)
	}
	const dep = new Dep() //实例化一个依赖管理器，生成一个依赖管理数组dep
	Object.defineProperty(obj, key, {
		enumerable: true,
		configurable: true,
		get() {
			dep.depend() // 在getter中收集依赖
			return val
		},
		set(newVal) {
			if (val === newVal) {
				return
			}
			val = newVal
			dep.notify() // 在setter中通知依赖更新
		}
	})
}
```

在上述代码中，我们在`getter`中调用了`dep.depend()`方法收集依赖，在`setter`中调用`dep.notify()`方法通知所有依赖更新。

## 4. 依赖到底是谁

通过上一章节，我们明白了什么是依赖？何时收集依赖？以及收集的依赖存放到何处？那么我们收集的依赖到底是谁？

虽然我们一直在说”谁用到了这个数据谁就是依赖“，但是这仅仅是在口语层面上，那么反应在代码上该如何来描述这个”谁“呢？

其实在`Vue`中还实现了一个叫做`Watcher`的类，而`Watcher`类的实例就是我们上面所说的那个"谁"。换句话说就是：谁用到了数据，谁就是依赖，我们就为谁创建一个`Watcher`实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的`Watch`实例，由`Watcher`实例去通知真正的视图。

`Watcher`类的具体实现如下：

```javascript
export default class Watcher {
	constructor(vm, expOrFn, cb) {
		this.vm = vm
		this.cb = cb
		this.getter = parsePath(expOrFn)
		this.value = this.get()
	}
	get() {
		window.target = this
		const vm = this.vm
		let value = this.getter.call(vm, vm)
		window.target = undefined
		return value
	}
	update() {
		const oldValue = this.value
		this.value = this.get()
		this.cb.call(this.vm, this.value, oldValue)
	}
}

/**
 * Parse simple path.
 * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来
 * 例如：
 * data = {a:{b:{c:2}}}
 * parsePath('a.b.c')(data)  // 2
 */
const bailRE = /[^\w.$]/
export function parsePath(path) {
	if (bailRE.test(path)) {
		return
	}
	const segments = path.split('.')
	return function(obj) {
		for (let i = 0; i < segments.length; i++) {
			if (!obj) return
			obj = obj[segments[i]]
		}
		return obj
	}
}
```

谁用到了数据，谁就是依赖，我们就为谁创建一个`Watcher`实例，在创建`Watcher`实例的过程中会自动的把自己添加到这个数据对应的依赖管理器中，以后这个`Watcher`实例就代表这个依赖，当数据变化时，我们就通知`Watcher`实例，由`Watcher`实例再去通知真正的依赖。

那么，在创建`Watcher`实例的过程中它是如何的把自己添加到这个数据对应的依赖管理器中呢？

下面我们分析`Watcher`类的代码实现逻辑：

1. 当实例化`Watcher`类时，会先执行其构造函数；
2. 在构造函数中调用了`this.get()`实例方法；
3. 在`get()`方法中，首先通过`window.target = this`把实例自身赋给了全局的一个唯一对象`window.target`上，然后通过`let value = this.getter.call(vm, vm)`获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的`getter`，上文我们说过，在`getter`里会调用`dep.depend()`收集依赖，而在`dep.depend()`中取到挂载`window.target`上的值并将其存入依赖数组中，在`get()`方法最后将`window.target`释放掉。
4. 而当数据变化时，会触发数据的`setter`，在`setter`中调用了`dep.notify()`方法，在`dep.notify()`方法中，遍历所有依赖(即 watcher 实例)，执行依赖的`update()`方法，也就是`Watcher`类中的`update()`实例方法，在`update()`方法中调用数据变化的更新回调函数，从而更新视图。

简单总结一下就是：`Watcher`先把自己设置到全局唯一的指定位置（`window.target`），然后读取数据。因为读取了数据，所以会触发这个数据的`getter`。接着，在`getter`中就会从全局唯一的那个位置读取当前正在读取数据的`Watcher`，并把这个`watcher`收集到`Dep`中去。收集好之后，当数据发生变化时，会向`Dep`中的每个`Watcher`发送通知。通过这样的方式，`Watcher`可以主动去订阅任意一个数据的变化。为了便于理解，我们画出了其关系流程图，如下图：

以上，就彻底完成了对`Object`数据的侦测，依赖收集，依赖的更新等所有操作。

## 5. 不足之处

虽然我们通过`Object.defineProperty`方法实现了对`object`数据的可观测，但是这个方法仅仅只能观测到`object`数据的取值及设置值，当我们向`object`数据里添加一对新的`key/value`或删除一对已有的`key/value`时，它是无法观测到的，导致当我们对`object`数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。

当然，`Vue`也注意到了这一点，为了解决这一问题，`Vue`增加了两个全局 API:`Vue.set`和`Vue.delete`，这两个 API 的实现原理将会在后面学习全局 API 的时候说到。

## 6. 总结

首先，我们通过`Object.defineProperty`方法实现了对`object`数据的可观测，并且封装了`Observer`类，让我们能够方便的把`object`数据中的所有属性（包括子属性）都转换成`getter/seter`的形式来侦测变化。

接着，我们学习了什么是依赖收集？并且知道了在`getter`中收集依赖，在`setter`中通知依赖更新，以及封装了依赖管理器`Dep`，用于存储收集到的依赖。

最后，我们为每一个依赖都创建了一个`Watcher`实例，当数据发生变化时，通知`Watcher`实例，由`Watcher`实例去做真实的更新操作。

其整个流程大致如下：

1. `Data`通过`observer`转换成了`getter/setter`的形式来追踪变化。
2. 当外界通过`Watcher`读取数据时，会触发`getter`从而将`Watcher`添加到依赖中。
3. 当数据发生了变化时，会触发`setter`，从而向`Dep`中的依赖（即 Watcher）发送通知。
4. `Watcher`接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等。
