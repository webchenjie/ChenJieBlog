---
title: 进阶知识
date: 2020-07-12
---

```js
1. this.$on('事件名称', 处理函数) // 定义事件,可以定义多个事件名称为数组,也可以为同一个事件定义多个处理函数
2. this.$emit('事件名称', '传递参数') // 触发事件,有try catch,有异常不会中断执行
3. Vue.directive // 自定义指令(bind、inserted、update、componentUpdated、unbind)
4. Vue.component // 定义组件
5. Vue.extend // 生成组件的构造方法
6. Vue.use // 使用插件
7. provide和inject // 组件通信
8. Vue.$mount // 挂载
9. filters // 过滤器
10. watch // 监听器
11. vue.observable // 相当于vuex
12. v-slot
  具名插槽:
    组件定义:
              <div>
                <slot name="header">默认内容</slot>
                <slot>默认内容</slot>
                <slot name="footer">默认内容</slot>
              </div>
    使用:
              <组件名>
                <template v-slot:header>
                  <div>将插入header的slot中</div>
                </template>
                <div>将插入没命名的slot中</div>
                <template v-slot:footer>
                  <div>将插入footer的slot中</div>
                </template>
              </组件名>
              在使用时'v-slot:'也可用#代替,如: #header、#footer
  作用域插槽:
    组件定义:
              <div>
                <slot :list="data">
                  data.id // 默认内容
                </slot>
              </div>
    使用:
              <组件名>
                <template v-slot="prop">
                  {{ prop.list.id }} // prop名字随意
                </template>
              </组件名>
----------------------------------------------------------------------------------------------
// 插槽(已废弃,建议使用上面)
1. 组件定义: <div><slot name="body"></slot></div> // 具名插槽
   使用: <组件名><div slot="body">内容</div></组件名>
2. 组件定义: <div><slot a="1" b="2"></slot></div> // 组件向父组件传值
   使用: <组件名><div slot-scope="obj">{{ obj.a/obj.b }}</div></组件名>
----------------------------------------------------------------------------------------------
1. const vm = new Vue({}) // vm === this
2. vm.$data // 返回一个对象,data里面的数据
3. vm.$props // 传递的值组件
4. vm.$el // 挂载到哪个的节点
5. vm.$options // 在new时传进去的整个对象,包括全部属性(不能通过$options.data修改)
6. vm.$root // 根节点的vue对象, vm.$root === vm
7. vm.$children // 组件里面的值或传递的值
8. vm.$slots // 插槽
9. vm.$scopedslots // 插槽
10. vm.$refs // 获得模板中的节点或组件中的实例引用
11. vm.isServer // 服务端渲染
12. vm.$watch('监听的名字', (newVal, oldVal) => {})
13. const unwatch = vm.$watch() // 执行unwatch取消监听,在options中写的watch会自动取消监听
14. vm.$on('事件名称', () => {}) // 定义事件,相当于@
15. vm.$emit('事件名称', '传递参数') // 触发事件,有try catch,有异常不会中断执行
16. vm.$once('事件名称', () => {}) // 定义只触发一次的事件
17. vm.forceUpdate() // 重新渲染页面
18. vm.$set(vm.obj, 'name', 'cj') // 修改vm.obj.name = cj
19. vm.$delete(vm.obj, 'name') // 删除vm.obj.name
20. vm.$nextTick() // vue进行DOM更新时执行
21. vm.$destroy() // 销毁实例
22. vue的事件绑定@click="handle(agruments, $event)"
    如果不加括号在methods方法中能拿到e事件参数,如果加了括号则需要把$event传进去,下面才能拿到e参数
    在第一个参数前加上agruments可拿到所有传递的参数
    event是原生的
    事件被挂载到当前元素
    e.target是事件绑定的元素
    e.currentTarget是事件触发的元素
23. vm.$attrs和vm.$listeners
    所谓的$arrts其实就是多级组件中的props,它就像一个中间件,用来传递爷组件给孙组件的数据,使用的时候只需给父组件中的孙组件配置v-bind="$attrs",然后再爷组件中传入孙组件所需要的数据,孙组件正常接收即可,v-on="$listeners"也是类似
----------------------------------------------------------------------------------------------
// 生命周期
1. beforeCreate() // 初始化之前,没有数据
2. create() // 初始化之后,1和2都不能做DOM操作,拿不到this.$el
3. beforeMount() // 页面挂载之前
4. mounted() // 页面挂载之后
5. beforeUpdate() // 数据更新之前
6. updated() //数据更新之后
7. activeted() // keep-alive组件激活之前
8. deactivated() // keep-alive组件停用时
9. beforeDestroy() // 实例销毁之前
10. destroyed() // 实例销毁之后
11. renderError(h, err) // render方法错误(本组件),开发环境使用
12. errorCaptured() // 收集错误,会向上冒泡,正式环境可以使用
13. 父组件子组件生命周期执行顺序,一定是父组件先执行,父组件结尾 // before之前和之后
----------------------------------------------------------------------------------------------
// computed/watch 不要去改变值,而是去执行操作
1. computed: {
  函数名() {
    return 'cj' // 相当于getter操作,有get、set操作(要写对象),计算修改值、拼接等
  }
}
2. watch: { // 监听的如果是引用类型,则拿不到oldVal,因为指向不一样
  obj/'obj.name': {
    handler(newVal, oldVal) {
      // 操作
    },
    immediate: true, // 马上执行,不等数据变化
    deep: true // 监听到子集
  }
}
----------------------------------------------------------------------------------------------
// 事件修饰符
1. @click.prevent // 阻止默认行为
2. @click.stop // 阻止冒泡
3. @click.capture // 变成捕获
4. @click.once // 只能触发一次
5. @click.self // 当e.target = e.cuttentTarget才触发
6. @click.right // 鼠标右键点击触发,还有middle、left
6. @keydown.enter.exact // 按下回车触发,还有tab、esc等,exact表示只能通过按下enter键触发,不加exact其他键和enter一起按也可以触发
7. @keydown.ctrl // 同时按下ctrl和其他键触发,还有shift、alt、meta等
----------------------------------------------------------------------------------------------
// v-model修饰符
1. v-model.lazy = "val" // 当鼠标失焦时触发而不是同步
2. v-model.number = "val" // 把val值转成数字,默认输入框中都是String
3. v-model.trim = "val" // 把val值的首位空格去除
----------------------------------------------------------------------------------------------
// 自定义v-model
1. 在实现的组件中:
<template>
  <input
    type="text"
    :value="value"
    @input="$emit('change', $event.taeget.value)"
  />
</template>
export default {
  model: {
    porp: 'value', // 对应props中的value
    event: 'change' // 对应$emit的change
  },
  props: {
    value: { // 对应value的属性
      type: 'String',
      default: ''
    }
  }
}
2. 在使用的组件中:
  <组件名  v-model="value" />
3. 即可实现双向绑定,要在实现的组件中配置model
----------------------------------------------------------------------------------------------
// 其他指令
1. v-pre // 不会解析标签里面的值,会原样显示
2. v-once // 里面的数据只绑定一次,不会再渲染
----------------------------------------------------------------------------------------------
// 组件继承
1. const compVue = Vue.extend(组件名)
   new compVue({ el: #id })
   数据通过propsData,而不通过props
   data会覆盖父级的data
   父级的生命周期先执行,再执行子级
2. const compVue2 = { extends: 组件名, data() {} }
   new Vue({ el: #id, components: { compVue2 }})
   与1一致
3. 当需要扩展组件时可以用extend
4. 可以通过this.$prent.$option去查看父级的东西或修改属性
5. 只有在new Vue时才能指定new Vue({ prent: prent })
----------------------------------------------------------------------------------------------
// provide和inject(非父子组件传递方法)
1. provide() { return { '传递的名字': this }} // 和生命周期平级,父级的this
2. inject: ['传递的名字'] // 在子组件中,即可使用this.传递的名字来获取父级的组件
----------------------------------------------------------------------------------------------
// 动态组件
1. <component :is="变量名" />
2. 通过is指定要渲染哪个组件,变量名指组件名,可以进行判断渲染哪个
----------------------------------------------------------------------------------------------
// keep-alive
1. keep-alive和v-show的区别,一个是js层面,一个是css层面
2. keep-alive作用是缓存组件,不会让组件执行destroyed,被缓存的组件重新激活也不会执行mounted
----------------------------------------------------------------------------------------------
// $nextTick
1. vue是异步渲染
2. data改变之后,DOM不会立刻渲染
3. $nextTick会在DOM渲染之后被触发,以获取最新DOM节点
4. 页面渲染时会将data的修改做整合,多次data修改只会渲染一次
5. this.$nextTick(() => { '在DOM渲染完触发回调' })
----------------------------------------------------------------------------------------------
// 组件化MVVM
1. 传统组件,只是静态渲染,更新还要依赖于操作DOM
2. 数据驱动视图MVVM
----------------------------------------------------------------------------------------------
// vue响应式
1. 实现数据驱动视图的第一步
2. 组件data的数据一旦变化,立刻触发视图的更新
3. 核心API Object.defineProperty // vue3.0启用proxy
    const data = {}
    let name = 'cj'
    Object.defineProperty(data, 'userName', {
      get: function() {
        return name
      },
      set: function(val) {
        name = val
      }
    })
4. 利用Object.defineProperty()监听data的数据
    先对data的数据进行过滤,如果是值类型则直接返回
    如果是obj则用Object.defineProperty()方法监听
    如果是数组则要特殊处理,修改原型方法
    在监听方法中会递归使用过滤方法实现深度监听
5. Object.defineProperty()的缺点
    对于data下面的嵌套的对象需要深度监听,需要递归到底,一次性计算量大 // vue3.0优化
    无法监听新增属性和删除属性的变化,所以需要使用Vue.set()和Vue.delete()
6. 对于对象采用递归方式深度监听,无法原生监听数组,需要特殊处理
7. 对于数组则利用Object.create('监听的数组')这个方法改写原型下所有的方法加入了更新视图等操作
   而改写后原型上的方法名和正常的方法名一样,这样就实现了监听数组,其实就是重新定义数组原型然后
   把每一个数组的原型都变成改写后的原型 // Object.create()的作用是创建新对象,原型指向参数,再扩展新的方法不会影响到原型
    const oldArrayProperty = Array.prototype
    const newArr = Object.create(oldArrayProperty)
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(item => {
      newArr[item] = function() {
        // 调用原数组的原型方法
        oldArrayProperty[item].call(this, ...arguments) // 如push方法: Array.prototype.push.call(this, ...arguments)
        updateView() // 更新视图
      }
    })
----------------------------------------------------------------------------------------------
// 虚拟DOM/VDOM (Virtual DOM)
1. vdom存在的价值: 数据驱动视图,控制DOM操作
2. DOM操作非常耗费性能,有了一定的复杂度,想减少计算次数比较难,但可以把计算转移为js计算,因为js执行速度很快
3. vdom就是用js模拟DOM结构,计算出最小的变更,操作DOM
    <div id="container" class="box"><span style="font-size: 20px">123</span></div>
    上面的DOM结构可以用js这样表示: // vnode
    {
      tag: 'div', // 标签名
      props: { // 属性,也会包含事件
        id: 'container',
        className: 'box'
      },
      children: [ // 内容
        {
          tag: 'span',
          props: {
            style: 'font-size: 20px'
          },
          children: '123'
        }
      ]
    }
4. snabbdom 是一个简洁强大的vdom库,vue就是参考它实现的vdom和diff
    h函数传入的参数和3的vnode差不多,会返回一个vnode对象里面包括sel标签、data属性、children子元素和子文本不共存、
    text子文本和子元素不共存、elm挂载的DOM标签、key
    patch函数传入的第一个参数可以是DOM元素也可以是vnode,第二个参数也是vnode,如果是DOM元素则是第一次渲染,如果是vnode则是更新
5. 如果不用vdom,改变了某个DOM元素的子元素会导致整个DOM元素重新渲染,而vdom则是只让子元素重新渲染
    新旧vnode对比,得出最小的更新范围,最后更新DOM
6. vdom和vnode的区别: vdom好比是一棵树,vnode则是vdom中一个一个的树节点
7. diff翻译过来就是对比,是一个比较广泛的概念,如linux diff命令、git diff命令等,两棵树做diff,就是这里的vdom diff
8. diff算法是比较两个vnode,计算出最小的变更,以便减少DOM操作次数,提高性能
9. 两棵树做diff的时间复杂度O(n^3),第一遍历tree1,第二遍历tree2,第三排序比较,当数量大时,此算法不可用
10. vue vdom diff算法把时间复杂度优化到O(n):
    只比较同一层级,不跨级比较
    tag不相同,则直接删掉重建,不再深度比较
    tag和key两者都相同,则认为是相同节点,不再深度比较
11. 它的流程是：
    首先,它会判断是否是首次渲染,因为如果是首次渲染,没有旧的vnode,不需要比较,直接渲染就可以了
    在非首次渲染,首先比较两个节点是否一样如果不一样,直接删除重建,如果一样,就需要进行vnode比较、就是比较children
    如果新节点没有文本节点,删除旧节点的文本节点,如果有文本节点,替换掉旧的文本节点
    如果只有新节点有子节点,直接插入,如果只有旧节点有子节点,直接删除
    最后就是,新旧节点都有子节点的情况
    这时候会遍历新节点的children,每个新的子节点都需要在旧的children里面进行寻找,找一个一样的节点
    如果没有找到,新的子节点直接插入,如果找到了,这两个节点再进行vnode比较
    也可以简单的理解为,如果没有是重新渲染,如果有的话,直接把旧的子节点挪过来用就可以了
----------------------------------------------------------------------------------------------
// 模板编译
1. with语法会改变{}内自由变量的查找规则,当做obj属性来查找,如果找不到就会报错,不要乱用,打破了作用域规则,易读性变差
    const obj = { a: 1, b: 2 }
    with(obj) {
      console.log(a)
      console.log(b)
      console.log(c) // 报错
    }
2. 模板编译为render函数,执行render函数返回vnode
3. 基于vnode再执行patch和diff
----------------------------------------------------------------------------------------------
// render函数,相当于模板的template
1. template: <comp-one ref="comp"><span ref="span">{{ val }}</span></comp-one>
2. 所对应的render函数是:
   render(h) { // h === this.$createElement()
     return h(
      'comp-one',
      { ref: 'comp'},
      [h('span', {ref: 'span'}, this.val)]
     )
   }
3. vue-template-compiler生成render函数
----------------------------------------------------------------------------------------------
// 组件渲染过程
1. 响应式: 监听data属性getter、setter // 包括数组
2. 模板编译: 模板到render函数,再到vnode
3. vdom: patch(ele, vnode)和patch(oldVnode, newVnode)
// 初次渲染
1. initState ->进行双向绑定
2. $mount->将template编译成render函数
3. 执行渲染 触发属性get函数,将渲染watcher 收集到dep中
4. 调用render 函数 生成vnode
5. patch(elm, vnode)
// 更新
1. 修改数据 触发属性set
2. 然后dep.notify() ->watch.update 派发更新
3. 触发render watcher 的render回调
4. 生成新的vnode
5. patch(oldVnode, newVnode)
// 异步渲染
1. vue是异步渲染的,data改变和后dom不会立即渲染
2. 页面渲染时会将data的修改经行整合一次性渲染
3. 在js中dom是在主线程清空了的才会去渲染
4. $nextTick()在DOm渲染完成后才会执行回调函数
5. vue里面渲染也是一样,$nextTicket 其实就是个类似于settimeout这样的异步函数,把回调操作推到异步队列
   所以即使我不用$netTicket,用个setTimeout也是能实时获取到最新的dom
----------------------------------------------------------------------------------------------
// vuex
1. const store = new vuex.store({
    state: { count: 0 },
    mutations: { updateCount(state, num) { state.count = num }},
    action: { updateCountSync(state, num) { state.count = num }}
  })
2. 在组件中的computed中使用,获取值时写在computed中
   computed: {
     count() {
       return this.$store.state.count
     }
   }
3. 在组件中的methods中使用,通过this.$store.commit('updateCount', 1) 调用mutations操作修改state
4. getter相当于组件内的computed
   getter: {
     sum(state) {
       return state.count + 1
     }
   }
   在组件中使用this.$store.getter.sum
5. 在组件中的computed中使用简写
   computed: {
     ...mapState(['count']) // 直接使用this.count === this.$store.state.count
     ...mapState({ counter: 'count' }) // 改变名称
     ...mapState({ counter: state => state.count }) // this.counter === this.$store.state.count
     ...mapGetter(['sum']) // 直接使用this.sum === this.$store.getter.sum
     ...mapState({ summit: 'sum' }) // 改变名称
   }
6. 修改state中的数据通过mutations(同步)或actions(异步)去修改
7. actions或组件通过this.$store.commit('mutations中的函数名', '传递的参数,多个值使用对象')
8. 组件通过this.$store.dispatch('actions中的函数名', '传递的参数,多个值使用对象')
9. 在组件中的methods中使用简写
   methods: {
     ...mapMutations(['mutations中的函数名']) === this.函数名(参数) === 7
     ...mapActions(['actions中的函数名']) === this.函数名(参数) === 8
   }
10. 模块
   const store = new vuex.store({
      modules: {
        g1: {
          state: {
            count: 1
          }
        },
        g2: {
          state: {
            count: 2
          }
        }
      }
   })
11. 在组件中的computed中使用
   computed: {
     count() {
       return this.$store.g1.state.count
     }
   }
12. 在组件中的computed中简写
   computed: {
     ...mapState([g1Count: state => state.g1.count])
   }
13. 默认模块下mutations会变成全局,所以使用时和7、9一样,也可以给module: { g1: { namespaced: true }}
14. 加配置,变成模块下的,则方法需要...mapmutations(['g1/函数名']),this['g1/函数名'](参数)调用
15. 在模块中的getter有3个参数,前2个一样,第3个是全局的state
16. 在模块中的actions可以调用commit触发当前模块下的mutations
17. 如果要触发全局下的mutations则需要在第三个参数中加上 { root: true },因为加了13的配置
18. 可以通过在入口文件时的store.registerModules('c', { state: { count: 1 }})动态增加模块
19. store.unrefisterModule('c') // 解除模块
20. store.watch // 监听state变化
21. store.subcribe((mutation, state) => { '哪个mutation', 'mutation的参数' }) // 获取mutations的变化
22. store.subcribeAction((action, state) => { '哪个action', 'action的参数' }) // 获取action的变化
23. 可以实现热更新
24. 全部配置
    export default () => {
      return new Vuex.store({
        strict: true, // 只用于生产环境,不能直接修改state的值
        state: { count: 1 },
        mutations: { updateCount(state, num) { state.count = num }},
        action: { updateCountSync(state, num) { state.count = num }}, // 也可直接commit调用mutations
        getter: { sum(state) {  return state.count + 1 } },
        modules: {
          g1: {
            state: {
              count: 1
            }
          },
          g2: {
            state: {
              count: 2
            }
          }
        }
      })
    }
25. vuex刷新会重置丢失数据,可以在数据中加入缓存机制解决 // 注意
26. 在actions中 return commit 可以在调用dispatch时使用.then获取修改后的值
27. vue-devtools可以在chrome商店中下载或使用远程的devtools,使用远程时需要在index.html中添加一段js,具体看github
28. getters使用时是通过函数return state的方式,要在new store时传入
29. 使用扩展运算符(...)在computed中相当是往computed添加对象属性 // 合并computed和store的值,就可以通过this.值获取
30. mutations相当于是原子操作,不能再细分
31. actions可以包含多个mutations
----------------------------------------------------------------------------------------------
// vue-router
1. vue-router默认的url加上#/为哈希,最好用history
2. route它是指一条路由
3. routes它是指一组路由
4. router它是一个机制,用来管理路由
5. 使用this.$route.query.参数名获取到的url参数,第一次获取到的值的类型时传递过来的类型
6. 刷新后获取到的值的类型则是String,因为路由没有变,直接取url上的
7. const routes = [
     { path: '/home', component: home },
     { path: '/login', component: login },
     { path: '/', redirect: '/home' } // 重定向,默认进入home页面
   ]
   var router = new Router( { routes })
   在html中使用<router-view></router-view>
8. export default () => {
      return new Router({
        routes, // 一组路由
        mode: 'histoty', // 把路由中默认加的#去掉
        base: '/base/', // 在使用跳转时在路径前面加上/base/
        linkActiveClass: 'active-link', // 当当前路由一部分和to="..."一样时会给元素加上这个类名,给<router-link>增加样式
        linkExactActiveClass: 'exact-active-link', // 当当前路由完全和to="..."一样时会给元素加上这个类名,给<router-link>增加样式
        scrollBehavior(to, from, savePosition) {
          // 进入页面时滚动到上次浏览的位置
          // to去哪个页面,from从哪里来,savePosition历史记录上次的位置
          if (savePosition) {
            return savePosition
          } else {
            return { x: 0, y: 0 }
          }
        },
        parseQuery(query) {
          // 字符串查询转为对象
        },
        stringifyQuery(obj) {
          // 对象查询转为字符串
        },
        fallback: true // 有的浏览器不能使用history会自动转为hash模式
      })
   }
9. 在routes中可以在组件中用this.$route获取url上的内容
   const routes = [{
     path: '/home/':id, // this.$route.params.id获取
     component: () => import('路径') // 进行懒加载,在组件注册时也可用
     name: 'home', // 在<router-link :to="{ name: 'home' }">
     meta: {
       title: 'this is home',
       description: ''
     },
     children: [{ // 嵌套路由,在用children中需在所对应的组件中用<router-view>占位
       path: '/homeChildren,
       component: homeChildren,
     }],
     props: true,
     props: route => {
       id: route.query.id // 在组件中直接使用this.id,而不用使用this.$route.query.id
     }
   }]
10. 在<transition name="fade"><router-view /></transition> // 可以用过渡动画
11. 一个页面两个<router-view>对应不同的组件
    <router-view />
    <router-view name="g1" />
    const routes = [{
      path: '/home',
      components: {
        default: home, // 没name
        g1: homeg1 // 有name="g1"
      }
    }]
----------------------------------------------------------------------------------------------
// 导航守卫
1. 导航守卫: 类型中间件,进入路由前先通过守卫,进行操作,进入页面
2. 全局守卫: 在定义router的地方定义,main.js
   router.beforEach((to, from, next) => { console.log('beforEach') next() }) // 前置守卫
   router.beforResolve((to, from, next) => { console.log('beforResolve') next() }) // 解析守卫
   router.afterEach((to, from) => { console.log('afterEach') }) // 后置守卫
3. 路由独享守卫: 在路由内定义
   const routes = [{
     path: '/home',
     components: home,
     beforeEnter: (to, from, next) => { console.log('beforeEnter') next() }
   }]
4. 组件内的守卫: 在组件内定义
   beforeRouteEnter(to, from, next) {
     // 在渲染该组件的对应路由被confirm(弹框)前调用
     // 不能获取组件实例this,因为在守卫执行前,组件实例还没创建
     // 可用这个守卫给next传值
     console.log('beforeRouteEnter')
     next()
   }
   beforeRouteUptate(to, from, next) {
     // 同一个组件但是id不同: abc/123到abc/456,生命周期不会重新执行,而这个可以,重用的组件
     console.log('beforeRouteUptate')
     next()
   }
   beforeRouteLeave(to, from, next) { console.log('beforeRouteLeave') next() }
----------------------------------------------------------------------------------------------
// 完整的导航解析流程
1. 导航被触发
2. 在失活的组件里调用beforeRouteLeave守卫
3. 调用全局的beforEach守卫
4. 在重用的组件里调用beforeRouteUpdate守卫
5. 在路由配置里调用beforeEnter守卫
6. 解析异步路由组件
7. 在被激活的组件中调用beforeRouteEnter守卫
8. 调用全局的beforeResolve守卫
9. 导航被确认调用全局的afterEach守卫
10. 触发DOM更新
----------------------------------------------------------------------------------------------
// 风格指南
1. 组件命名尽量为多个单词
2. data必须是个函数返回一个对象 // new Vue除外
3. prop定义应该尽量详细,写对象不要写数组
4. 使用v-for时配合key
5. v-if和v-for不要用在一起
6. 组件样式设置作用域 // scoped或使用css modules或使用BEM约定
7. 使用模块作用域保持不允许外部访问的函数的私有性,如果无法做到这一点,就始终为插件、混入等不考虑作为对外公共 API 的自定义私有 property 使用 $_ 前缀,并附带一个命名空间以回避和其它作者的冲突 (比如 $_yourPluginName_)
8. 一个组件一个文件,不要集中在引入文件中
9. 单文件组件的文件名应该要么始终是单词大写开头 (PascalCase),要么始终是横线连接 (kebab-case) // MyComponent.vue或者my-component.vue
10. 应用特定样式和约定的基础组件名 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头,比如 Base、App 或 V // BaseButton.vue或者AppButton.vue或者VButton.vue
11. 单例组件名: 只应该拥有单个活跃实例的组件应该以 The 前缀命名,以示其唯一性 // TheHeading.vue或者TheSidebar.vue
    这不意味着组件只可用于一个单页面,而是每个页面只使用一次,这些组件永远不接受任何 prop
    因为它们是为你的应用定制的,而不是它们在你的应用中的上下文,如果你发现有必要添加 prop
    那就表明这实际上是一个可复用的组件,只是目前在每个页面里只使用一次
12. 紧密耦合的组件名: 和父组件紧密耦合的子组件应该以父组件名作为前缀命名 // TodoList.vue --> TodoListItem.vue --> TodoListItemButton.vue
    如果一个组件只在某个父组件的场景下有意义,这层关系应该体现在其名字上
    因为编辑器通常会按字母顺序组织文件,所以这样做可以把相关联的文件排在一起
13. 组件名中的单词顺序: 组件名应该以高级别的 (通常是一般化描述的) 单词开头,以描述性的修饰词结尾 // SearchButtonClear.vue或者SearchButtonRun.vue
14. 自闭合组件: 在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做
    自闭合组件表示它们不仅没有内容,而且刻意没有内容其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸
    而且没有了额外的闭合标签,你的代码也更简洁
    不幸的是,HTML 并不支持自闭合的自定义元素——只有官方的“空”元素
    所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方,然后再产出符合 DOM 规范的 HTML
    在单文件组件、字符串模板和 JSX 中:
    <MyComponent/>
    在 DOM 模板中:
    <my-component></my-component>
15. 模板中的组件名大小写: 对于绝大多数项目来说,在单文件组件和字符串模板中组件名应该总是 PascalCase 的
    但是在 DOM 模板中总是 kebab-case 的,由于 HTML 是大小写不敏感的,在 DOM 模板中必须仍使用 kebab-case
16. 完整单词的组件名: 组件名应该倾向于完整单词而不是缩写
17. Prop 名大小写: 在声明 prop 的时候,其命名应该始终使用 camelCase,而在模板和 JSX 中应该始终使用 kebab-cas
    props: {
      greetingText: String
    }
    <WelcomeMessage greeting-text="hi"/>
18. 多个 attribute 的元素: 多个 attribute 的元素应该分多行撰写,每个 attribute 一行
    <img
      src="https://vuejs.org/images/logo.png"
      alt="Vue Logo"
    />
19. 模板中简单的表达式: 组件模板应该只包含简单的表达式,复杂的表达式则应该重构为计算属性或方法
20. 带引号的 attribute 值: 非空 HTML attribute 值应该始终带引号 (单引号或双引号,选你 JS 里不用的那个)
    <AppSidebar :style="{ width: sidebarWidth + 'px' }" />
21. 组件/实例的选项的顺序:
      1. 副作用 (触发组件外的影响)
          el
      2. 全局感知 (要求组件以外的知识)
          name
          parent
      3. 组件类型 (更改组件的类型)
          functional
      4. 模板修改器 (改变模板的编译方式)
          delimiters
          comments
      5. 模板依赖 (模板内使用的资源)
          components
          directives
          filters
      6. 组合 (向选项里合并 property)
          extends
          mixins
      7. 接口 (组件的接口)
          inheritAttrs
          model
          props/propsData
      8. 本地状态 (本地的响应式 property)
          data
          computed
      9. 事件 (通过响应式事件触发的回调)
          watch
          生命周期钩子 (按照它们被调用的顺序)
            beforeCreate
            created
            beforeMount
            mounted
            beforeUpdate
            updated
            activated
            deactivated
            beforeDestroy
            destroyed
      10. 非响应式的 property (不依赖响应系统的实例 property)
          methods
      11. 渲染 (组件输出的声明式描述)
          template/render
          renderError
22. 元素 attribute 的顺序:
      1. 定义 (提供组件的选项)
          is
      2. 列表渲染 (创建多个变化的相同元素)
          v-for
      3. 条件渲染 (元素是否渲染/显示)
          v-if
          v-else-if
          v-else
          v-show
          v-cloak
      4. 渲染方式 (改变元素的渲染方式)
          v-pre
          v-once
      5. 全局感知 (需要超越组件的知识)
          id
      6. 唯一的 attribute (需要唯一值的 attribute)
          ref
          key
      7. 双向绑定 (把绑定和事件结合起来)
          v-model
      8. 其它 attribute (所有普通的绑定或未绑定的 attribute)
      9. 事件 (组件事件监听器)
          v-on
      10. 内容 (覆写元素的内容)
          v-html
          v-text
23. 可以在每个代码块后面加一行空行方便阅读
24. 单文件组件的顶级元素的顺序: 单文件组件应该总是让 <script>、<template> 和 <style>
    标签的顺序保持一致,且 <style> 要放在最后,因为另外两个标签至少要有一个
25. 在有scoped的style中尽量使用类选择器不要用元素选择器
26. 应该优先通过 prop 和事件进行父子组件之间的通信,而不是 this.$parent 或变更 prop
27. 应该优先通过 Vuex 管理全局状态,而不是通过 this.$root 或一个全局事件总线
```
