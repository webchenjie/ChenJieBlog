---
title: 进阶知识
date: 2020-07-12
---

``` js
1. this.$on('事件名称', 处理函数) // 定义事件,可以定义多个事件名称为数组,也可以为同一个事件定义多个处理函数
2. this.$emit('事件名称', '传递参数') // 触发事件,有try catch,有异常不会中断执行
3. Vue.directive // 自定义指令(bind、inserted、update、componentUpdated、unbind)
4. Vue.component // 定义组件
5. Vue.extend // 生成组件的构造方法
6. Vue.use // 使用插件
7. provide和inject // 组件通信
8. Vue.$mount // 挂载
9. filters // 过滤器
10. watch // 监听器
11. vue.observable // 相当于vuex
12. v-slot
  具名插槽:
    组件定义: 
              <div>
                <slot name="header">默认内容</slot>
                <slot>默认内容</slot>
                <slot name="footer">默认内容</slot>
              </div>
    使用: 
              <组件名>
                <template v-slot:header>
                  <div>将插入header的slot中</div>
                </template>
                <div>将插入没命名的slot中</div>
                <template v-slot:footer>
                  <div>将插入footer的slot中</div>
                </template>
              </组件名>
              在使用时'v-slot:'也可用#代替,如: #header、#footer
  作用域插槽:
    组件定义: 
              <div>
                <slot :list="data">
                  data.id // 默认内容
                </slot>
              </div>
    使用:
              <组件名>
                <template v-slot="prop">
                  {{ prop.list.id }} // prop名字随意
                </template>
              </组件名>
----------------------------------------------------------------------------------------------
// 插槽(已废弃,建议使用上面)
1. 组件定义: <div><slot name="body"></slot></div> // 具名插槽
   使用: <组件名><div slot="body">内容</div></组件名>
2. 组件定义: <div><slot a="1" b="2"></slot></div> // 组件向父组件传值
   使用: <组件名><div slot-scope="obj">{{ obj.a/obj.b }}</div></组件名>
----------------------------------------------------------------------------------------------
1. const vm = new Vue({}) // vm === this
2. vm.$data // 返回一个对象,data里面的数据
3. vm.$props // 传递的值组件
4. vm.$el // 挂载到哪个的节点
5. vm.$options // 在new时传进去的整个对象,包括全部属性(不能通过$options.data修改)
6. vm.$root // 根节点的vue对象, vm.$root === vm
7. vm.$children // 组件里面的值或传递的值
8. vm.$slots // 插槽
9. vm.$scopedslots // 插槽
10. vm.$refs // 获得模板中的节点或组件中的实例引用
11. vm.isServer // 服务端渲染
12. vm.$watch('监听的名字', (newVal, oldVal) => {})
13. const unwatch = vm.$watch() // 执行unwatch取消监听,在options中写的watch会自动取消监听
14. vm.$on('事件名称', () => {}) // 定义事件,相当于@
15. vm.$emit('事件名称', '传递参数') // 触发事件,有try catch,有异常不会中断执行
16. vm.$once('事件名称', () => {}) // 定义只触发一次的事件
17. vm.forceUpdate() // 重新渲染页面
18. vm.$set(vm.obj, 'name', 'cj') // 修改vm.obj.name = cj
19. vm.$delete(vm.obj, 'name') // 删除vm.obj.name
20. vm.$nextTick() // vue进行DOM更新时执行
21. vm.$destroy() // 销毁实例
22. vue的事件绑定@click="handle(agruments, $event)"
    如果不加括号在methods方法中能拿到e事件参数,如果加了括号则需要把$event传进去,下面才能拿到e参数
    在第一个参数前加上agruments可拿到所有传递的参数
    event是原生的
    事件被挂载到当前元素
    e.target是事件绑定的元素
    e.currentTarget是事件触发的元素
----------------------------------------------------------------------------------------------
// 生命周期
1. beforeCreate() // 初始化之前,没有数据
2. create() // 初始化之后,1和2都不能做DOM操作,拿不到this.$el
3. beforeMount() // 页面挂载之前
4. mounted() // 页面挂载之后
5. beforeUpdate() // 数据更新之前
6. updated() //数据更新之后
7. activeted() // keep-alive组件激活之前
8. deactivated() // keep-alive组件停用时
9. beforeDestroy() // 实例销毁之前
10. destroyed() // 实例销毁之后
11. renderError(h, err) // render方法错误(本组件),开发环境使用
12. errorCaptured() // 收集错误,会向上冒泡,正式环境可以使用
13. 父组件子组件生命周期执行顺序,一定是父组件先执行,父组件结尾 // before之前和之后
----------------------------------------------------------------------------------------------
// computed/watch 不要去改变值,而是去执行操作
1. computed: {
  函数名() {
    return 'cj' // 相当于getter操作,有get、set操作(要写对象),计算修改值、拼接等
  }
}
2. watch: { // 监听的如果是引用类型,则拿不到oldVal,因为指向不一样
  obj/'obj.name': {
    handler(newVal, oldVal) {
      // 操作
    },
    immediate: true, // 马上执行,不等数据变化
    deep: true // 监听到子集
  }
}
----------------------------------------------------------------------------------------------
// 事件修饰符
1. @click.prevent // 阻止默认行为
2. @click.stop // 阻止冒泡
3. @click.capture // 变成捕获
4. @click.once // 只能触发一次
5. @click.self // 当e.target = e.cuttentTarget才触发
6. @click.right // 鼠标右键点击触发,还有middle、left
6. @keydown.enter.exact // 按下回车触发,还有tab、esc等,exact表示只能通过按下enter键触发,不加exact其他键和enter一起按也可以触发
7. @keydown.ctrl // 同时按下ctrl和其他键触发,还有shift、alt、meta等
----------------------------------------------------------------------------------------------
// v-model修饰符
1. v-model.lazy = "val" // 当鼠标失焦时触发而不是同步
2. v-model.number = "val" // 把val值转成数字,默认输入框中都是String
3. v-model.trim = "val" // 把val值的首位空格去除
----------------------------------------------------------------------------------------------
// 自定义v-model
1. 在实现的组件中:
<template>
  <input
    type="text"
    :value="value"
    @input="$emit('change', $event.taeget.value)"
  />
</template>
export default {
  model: {
    porp: 'value', // 对应props中的value
    event: 'change' // 对应$emit的change
  },
  props: {
    value: { // 对应value的属性
      type: 'String',
      default: ''
    }
  }
}
2. 在使用的组件中:
  <组件名  v-model="value" />
3. 即可实现双向绑定,要在实现的组件中配置model
----------------------------------------------------------------------------------------------
// 其他指令
1. v-pre // 不会解析标签里面的值,会原样显示
2. v-once // 里面的数据只绑定一次,不会再渲染
----------------------------------------------------------------------------------------------
// 组件继承
1. const compVue = Vue.extend(组件名)
   new compVue({ el: #id })
   数据通过propsData,而不通过props
   data会覆盖父级的data
   父级的生命周期先执行,再执行子级
2. const compVue2 = { extends: 组件名, data() {} }
   new Vue({ el: #id, components: { compVue2 }})
   与1一致
3. 当需要扩展组件时可以用extend
4. 可以通过this.$prent.$option去查看父级的东西或修改属性
5. 只有在new Vue时才能指定new Vue({ prent: prent })
----------------------------------------------------------------------------------------------
// provide和inject(非父子组件传递方法)
1. provide() { return { '传递的名字': this }} // 和生命周期平级,父级的this
2. inject: ['传递的名字'] // 在子组件中,即可使用this.传递的名字来获取父级的组件
----------------------------------------------------------------------------------------------
// render函数,相当于模板的template
1. template: <comp-one ref="comp"><span ref="span">{{ val }}</span></comp-one>
2. 所对应的render函数是:
   render(h) { // h === this.$createElement()
     return h(
      'comp-one',
      { ref: 'comp'},
      [h('span', {ref: 'span'}, this.val)]
     )
   }
----------------------------------------------------------------------------------------------
// 动态组件
1. <component :is="变量名" />
2. 通过is指定要渲染哪个组件,变量名指组件名,可以进行判断渲染哪个
----------------------------------------------------------------------------------------------
// keep-alive
1. keep-alive和v-show的区别,一个是js层面,一个是css层面
2. keep-alive作用是缓存组件,不会让组件执行destroyed,被缓存的组件重新激活也不会执行mounted
----------------------------------------------------------------------------------------------
// $nextTick
1. vue是异步渲染
2. data改变之后,DOM不会立刻渲染
3. $nextTick会在DOM渲染之后被触发,以获取最新DOM节点
4. 页面渲染时会将data的修改做整合,多次data修改只会渲染一次
5. this.$nextTick(() => { '在DOM渲染完触发回调' })
----------------------------------------------------------------------------------------------
// vuex
1. const store = new vuex.store({
    state: { count: 0 },
    mutations: { updateCount(state, num) { state.count = num }},
    action: { updateCountSync(state, num) { state.count = num }}
  })
2. 在组件中的computed中使用,获取值时写在computed中
   computed: {
     count() {
       return this.$store.state.count
     }
   }
3. 在组件中的methods中使用,通过this.$store.commit('updateCount', 1) 调用mutations操作修改state
4. getter相当于组件内的computed
   getter: {
     sum(state) {
       return state.count + 1
     }
   }
   在组件中使用this.$store.getter.sum
5. 在组件中的computed中使用简写
   computed: {
     ...mapState(['count']) // 直接使用this.count === this.$store.state.count
     ...mapState({ counter: 'count' }) // 改变名称
     ...mapState({ counter: state => state.count }) // this.counter === this.$store.state.count
     ...mapGetter(['sum']) // 直接使用this.sum === this.$store.getter.sum
     ...mapState({ summit: 'sum' }) // 改变名称
   }
6. 修改state中的数据通过mutations(同步)或actions(异步)去修改
7. actions或组件通过this.$store.commit('mutations中的函数名', '传递的参数,多个值使用对象')
8. 组件通过this.$store.dispatch('actions中的函数名', '传递的参数,多个值使用对象')
9. 在组件中的methods中使用简写
   methods: {
     ...mapMutations(['mutations中的函数名']) === this.函数名(参数) === 7
     ...mapActions(['actions中的函数名']) === this.函数名(参数) === 8
   }
10. 模块
   const store = new vuex.store({
      modules: {
        g1: {
          state: {
            count: 1
          }
        },
        g2: {
          state: {
            count: 2
          }
        }
      }
   })
11. 在组件中的computed中使用
   computed: {
     count() {
       return this.$store.g1.state.count
     }
   }
12. 在组件中的computed中简写
   computed: {
     ...mapState([g1Count: state => state.g1.count])
   }
13. 默认模块下mutations会变成全局,所以使用时和7、9一样,也可以给module: { g1: { namespaced: true }}
14. 加配置,变成模块下的,则方法需要...mapmutations(['g1/函数名']),this['g1/函数名'](参数)调用
15. 在模块中的getter有3个参数,前2个一样,第3个是全局的state
16. 在模块中的actions可以调用commit触发当前模块下的mutations
17. 如果要触发全局下的mutations则需要在第三个参数中加上 { root: true },因为加了13的配置
18. 可以通过在入口文件时的store.registerModules('c', { state: { count: 1 }})动态增加模块
19. store.unrefisterModule('c') // 解除模块
20. store.watch // 监听state变化
21. store.subcribe((mutation, state) => { '哪个mutation', 'mutation的参数' }) // 获取mutations的变化
22. store.subcribeAction((action, state) => { '哪个action', 'action的参数' }) // 获取action的变化
23. 可以实现热更新
24. 全部配置
    export default () => {
      return new Vuex.store({
        strict: true, // 只用于生产环境,不能直接修改state的值
        state: { count: 1 },
        mutations: { updateCount(state, num) { state.count = num }},
        action: { updateCountSync(state, num) { state.count = num }}, // 也可直接commit调用mutations
        getter: { sum(state) {  return state.count + 1 } },
        modules: {
          g1: {
            state: {
              count: 1
            }
          },
          g2: {
            state: {
              count: 2
            }
          }
        }
      })
    }
25. vuex刷新会重置丢失数据,可以在数据中加入缓存机制解决 // 注意
26. 在actions中 return commit 可以在调用dispatch时使用.then获取修改后的值
27. vue-devtools可以在chrome商店中下载或使用远程的devtools,使用远程时需要在index.html中添加一段js,具体看github
28. getters使用时是通过函数return state的方式,要在new store时传入
29. 使用扩展运算符(...)在computed中相当是往computed添加对象属性 // 合并computed和store的值,就可以通过this.值获取
30. mutations相当于是原子操作,不能再细分
31. actions可以包含多个mutations
----------------------------------------------------------------------------------------------
// vue-router
1. vue-router默认的url加上#/为哈希,最好用history
2. route它是指一条路由
3. routes它是指一组路由
4. router它是一个机制,用来管理路由
5. 使用this.$route.query.参数名获取到的url参数,第一次获取到的值的类型时传递过来的类型
6. 刷新后获取到的值的类型则是String,因为路由没有变,直接取url上的
7. const routes = [
     { path: '/home', component: home },
     { path: '/login', component: login },
     { path: '/', redirect: '/home' } // 重定向,默认进入home页面
   ]
   var router = new Router( { routes })
   在html中使用<router-view></router-view>
8. export default () => {
      return new Router({
        routes, // 一组路由
        mode: 'histoty', // 把路由中默认加的#去掉
        base: '/base/', // 在使用跳转时在路径前面加上/base/
        linkActiveClass: 'active-link', // 当当前路由一部分和to="..."一样时会给元素加上这个类名,给<router-link>增加样式
        linkExactActiveClass: 'exact-active-link', // 当当前路由完全和to="..."一样时会给元素加上这个类名,给<router-link>增加样式
        scrollBehavior(to, from, savePosition) {
          // 进入页面时滚动到上次浏览的位置
          // to去哪个页面,from从哪里来,savePosition历史记录上次的位置
          if (savePosition) {
            return savePosition
          } else {
            return { x: 0, y: 0 }
          }
        },
        parseQuery(query) {
          // 字符串查询转为对象
        },
        stringifyQuery(obj) {
          // 对象查询转为字符串
        },
        fallback: true // 有的浏览器不能使用history会自动转为hash模式
      })
   }
9. 在routes中可以在组件中用this.$route获取url上的内容
   const routes = [{
     path: '/home/':id, // this.$route.params.id获取
     component: () => import('路径') // 进行懒加载,在组件注册时也可用
     name: 'home', // 在<router-link :to="{ name: 'home' }">
     meta: {
       title: 'this is home',
       description: ''
     },
     children: [{ // 嵌套路由,在用children中需在所对应的组件中用<router-view>占位
       path: '/homeChildren,
       component: homeChildren,
     }],
     props: true,
     props: route => {
       id: route.query.id // 在组件中直接使用this.id,而不用使用this.$route.query.id
     }
   }]
10. 在<transition name="fade"><router-view /></transition> // 可以用过渡动画
11. 一个页面两个<router-view>对应不同的组件
    <router-view />
    <router-view name="g1" />
    const routes = [{
      path: '/home',
      components: {
        default: home, // 没name
        g1: homeg1 // 有name="g1"
      }
    }]
----------------------------------------------------------------------------------------------
// 导航守卫
1. 导航守卫: 类型中间件,进入路由前先通过守卫,进行操作,进入页面
2. 全局守卫: 在定义router的地方定义,main.js
   router.beforEach((to, from, next) => { console.log('beforEach') next() }) // 前置守卫
   router.beforResolve((to, from, next) => { console.log('beforResolve') next() }) // 解析守卫
   router.afterEach((to, from) => { console.log('afterEach') }) // 后置守卫
3. 路由独享守卫: 在路由内定义
   const routes = [{
     path: '/home',
     components: home,
     beforeEnter: (to, from, next) => { console.log('beforeEnter') next() }
   }]
4. 组件内的守卫: 在组件内定义
   beforeRouteEnter(to, from, next) {
     // 在渲染该组件的对应路由被confirm(弹框)前调用
     // 不能获取组件实例this,因为在守卫执行前,组件实例还没创建
     // 可用这个守卫给next传值 
     console.log('beforeRouteEnter')
     next()
   }
   beforeRouteUptate(to, from, next) {
     // 同一个组件但是id不同: abc/123到abc/456,生命周期不会重新执行,而这个可以,重用的组件
     console.log('beforeRouteUptate')
     next()
   }
   beforeRouteLeave(to, from, next) { console.log('beforeRouteLeave') next() }
----------------------------------------------------------------------------------------------
// 完整的导航解析流程
1. 导航被触发
2. 在失活的组件里调用beforeRouteLeave守卫
3. 调用全局的beforEach守卫
4. 在重用的组件里调用beforeRouteUpdate守卫
5. 在路由配置里调用beforeEnter守卫
6. 解析异步路由组件
7. 在被激活的组件中调用beforeRouteEnter守卫
8. 调用全局的beforeResolve守卫
9. 导航被确认调用全局的afterEach守卫
10. 触发DOM更新
----------------------------------------------------------------------------------------------
// 组件化MVVM
1. 传统组件,只是静态渲染,更新还要依赖于操作DOM
2. 数据驱动视图MVVM
----------------------------------------------------------------------------------------------
// vue响应式
1. 实现数据驱动视图的第一步
2. 组件data的数据一旦变化,立刻触发视图的更新
3. 核心API Object.defineProperty // vue3.0启用proxy
    const data = {}
    let name = 'cj'
    Object.defineProperty(data, 'userName', {
      get: function() {
        return name
      },
      set: function(val) {
        name = val
      }
    })
4. 利用Object.defineProperty()监听data的数据
    先对data的数据进行过滤,如果是值类型则直接返回
    如果是obj则用Object.defineProperty()方法监听
    如果是数组则要特殊处理,修改原型方法
    在监听方法中会递归使用过滤方法实现深度监听
5. Object.defineProperty()的缺点
    对于data下面的嵌套的对象需要深度监听,需要递归到底,一次性计算量大 // vue3.0优化
    无法监听新增属性和删除属性的变化,所以需要使用Vue.set()和Vue.delete()
6. 对于对象采用递归方式深度监听,无法原生监听数组,需要特殊处理
7. 对于数组则利用Object.create('监听的数组')这个方法改写原型下所有的方法加入了更新视图等操作
   而改写后原型上的方法名和正常的方法名一样,这样就实现了监听数组,其实就是重新定义数组原型然后
   把每一个数组的原型都变成改写后的原型 // Object.create()的作用是创建新对象,原型指向参数,再扩展新的方法不会影响到原型
    const oldArrayProperty = Array.prototype
    const newArr = Object.create(oldArrayProperty)
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(item => {
      newArr[item] = function() {
        // 调用原数组的原型方法
        oldArrayProperty[item].call(this, ...arguments) // 如push方法: Array.prototype.push.call(this, ...arguments)
        updateView() // 更新视图
      }
    })
```