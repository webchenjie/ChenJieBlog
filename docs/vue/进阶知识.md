---
title: 基础知识
date: 2020-07-12
---

``` js
1. this.$on('事件名称', 处理函数) // 定义事件,可以定义多个事件名称为数组,也可以为同一个事件定义多个处理函数
2. this.$emit('事件名称', '传递参数') // 触发事件,有try catch,有异常不会中断执行
3. Vue.directive // 自定义指令(bind、inserted、update、componentUpdated、unbind)
4. Vue.component // 定义组件
5. Vue.extend // 生成组件的构造方法
6. Vue.use // 使用插件
7. provide和inject // 组件通信
8. Vue.$mount // 挂载
9. filters // 过滤器
10. watch // 监听器
11. vue.observable // 相当于vuex
12. v-slot
    组件定义: <div><slot name="a" b="obj" s="c"></slot></div> // obj = { x: 1}
    使用: <组件名><template v-solt:a="{ b }">{{ b.x }}</template></组件名>
    使用: '<组件名><div v-solt:[s]="{ s }">{{ s }}</div></组件名>' // s相当于c
----------------------------------------------------------------------------------------------
1. const vm = new Vue({}) // vm === this
2. vm.$data // 返回一个对象,data里面的数据
3. vm.$props // 传递的值组件
4. vm.$el // 挂载到哪个的节点
5. vm.$options // 在new时传进去的整个对象,包括全部属性(不能通过$options.data修改)
6. vm.$root // 根节点的vue对象, vm.$root === vm
7. vm.$children // 组件里面的值或传递的值
8. vm.$slots // 插槽
9. vm.$scopedslots // 插槽
10. vm.$refs // 获得模板中的节点或组件中的实例引用
11. vm.isServer // 服务端渲染
12. vm.$watch('监听的名字', (newVal, oldVal) => {})
13. const unwatch = vm.$watch() // 执行unwatch取消监听,在options中写的watch会自动取消监听
14. vm.$on('事件名称', () => {}) // 定义事件,相当于@
15. vm.$emit('事件名称', '传递参数') // 触发事件,有try catch,有异常不会中断执行
16. vm.$once('事件名称', () => {}) // 定义只触发一次的事件
17. vm.forceUpdate() // 重新渲染页面
18. vm.$set(vm.obj, 'name', 'cj') // 修改vm.obj.name = cj
19. vm.$delete(vm.obj, 'name') // 删除vm.obj.name
20. vm.$nextTick() // vue进行DOM更新时执行
21. vm.$destroy() // 销毁实例
22. vue的事件绑定@click="handle(agruments, $event)"
    如果不加括号在methods方法中能拿到e事件参数,如果加了括号则需要把$event传进去,下面才能拿到e参数
    在第一个参数前加上agruments可拿到所有传递的参数
----------------------------------------------------------------------------------------------
// 生命周期
1. beforeCreate() // 初始化之前,没有数据
2. create() // 初始化之后,1和2都不能做DOM操作,拿不到this.$el
3. beforeMount() // 页面挂载之前
4. mounted() // 页面挂载之后
5. beforeUpdate() // 数据更新之前
6. updated() //数据更新之后
7. activeted() // keep-alive组件激活之前
8. deactivated() // keep-alive组件停用时
9. beforeDestroy() // 实例销毁之前
10. destroyed() // 实例销毁之后
11. renderError(h, err) // render方法错误(本组件),开发环境使用
12. errorCaptured() // 收集错误,会向上冒泡,正式环境可以使用
----------------------------------------------------------------------------------------------
// computed/watch 不要去改变值,而是去执行操作
1. computed: {
  函数名() {
    return 'cj' // 相当于getter操作,有get、set操作(要写对象),计算修改值、拼接等
  }
}
2. watch: {
  obj/'obj.name': {
    handler(newVal, oldVal) {
      // 操作
    },
    immediate: true, // 马上执行,不等数据变化
    deep: true // 监听到子集
  }
}
----------------------------------------------------------------------------------------------
// 事件修饰符
1. @click.prevent // 阻止默认行为
2. @click.stop // 阻止冒泡
3. @click.capture // 变成捕获
4. @click.once // 只能触发一次
5. @click.self // 当e.target = e.cuttentTarget才触发
6. @click.right // 鼠标右键点击触发,还有middle、left
6. @keydown.enter // 按下回车触发,还有tab、esc等
7. @keydown.ctrl // 同时按下ctrl和其他键触发,还有shift、alt、meta等
----------------------------------------------------------------------------------------------
// v-model修饰符
1. v-model.lazy = "val" // 当鼠标失焦时触发而不是同步
2. v-model.number = "val" // 把val值转成数字,默认输入框中都是String
3. v-model.trim = "val" // 把val值的首位空格去除
----------------------------------------------------------------------------------------------
// 其他指令
1. v-pre // 不会解析标签里面的值,会原样显示
2. v-once // 里面的数据只绑定一次,不会再渲染
----------------------------------------------------------------------------------------------
// 组件继承
1. const compVue = Vue.extend(组件名)
   new compVue({ el: #id })
   数据通过propsData,而不通过props
   data会覆盖父级的data
   父级的生命周期先执行,再执行子级
2. const compVue2 = { extends: 组件名, data() {} }
   new Vue({ el: #id, components: { compVue2 }})
   与1一致
3. 当需要扩展组件时可以用extend
4. 可以通过this.$prent.$option去查看父级的东西或修改属性
5. 只有在new Vue时才能指定new Vue({ prent: prent })
----------------------------------------------------------------------------------------------
// 插槽
1. 组件定义: <div><slot name="body"></slot></div> // 具名插槽
   使用: <组件名><div slot="body">内容</div></组件名>
2. 组件定义: <div><slot a="1" b="2"></slot></div> // 组件向父组件传值
   使用: <组件名><div slot-scope="obj">{{ obj.a/obj.b }}</div></组件名>
----------------------------------------------------------------------------------------------
// provide和inject(非父子组件传递方法)
1. provide() { return { '传递的名字': this }} // 和生命周期平级,父级的this
2. inject: ['传递的名字'] // 在子组件中,即可使用this.传递的名字来获取父级的组件
----------------------------------------------------------------------------------------------
// render函数,相当于模板的template
1. template: <comp-one ref="comp"><span ref="span">{{ val }}</span></comp-one>
2. 所对应的render函数是:
   render(h) { // h === this.$createElement()
     return h(
      'comp-one',
      { ref: 'comp'},
      [h('span', {ref: 'span'}, this.val)]
     )
   }
```