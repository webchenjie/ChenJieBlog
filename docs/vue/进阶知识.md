---
title: 进阶知识
date: 2020-07-12
---

``` js
1. this.$on('事件名称', 处理函数) // 定义事件,可以定义多个事件名称为数组,也可以为同一个事件定义多个处理函数
2. this.$emit('事件名称', '传递参数') // 触发事件,有try catch,有异常不会中断执行
3. Vue.directive // 自定义指令(bind、inserted、update、componentUpdated、unbind)
4. Vue.component // 定义组件
5. Vue.extend // 生成组件的构造方法
6. Vue.use // 使用插件
7. provide和inject // 组件通信
8. Vue.$mount // 挂载
9. filters // 过滤器
10. watch // 监听器
11. vue.observable // 相当于vuex
12. v-slot
    组件定义: <div><slot name="a" b="obj" s="c"></slot></div> // obj = { x: 1}
    使用: <组件名><template v-solt:a="{ b }">{{ b.x }}</template></组件名>
    使用: '<组件名><div v-solt:[s]="{ s }">{{ s }}</div></组件名>' // s相当于c
----------------------------------------------------------------------------------------------
1. const vm = new Vue({}) // vm === this
2. vm.$data // 返回一个对象,data里面的数据
3. vm.$props // 传递的值组件
4. vm.$el // 挂载到哪个的节点
5. vm.$options // 在new时传进去的整个对象,包括全部属性(不能通过$options.data修改)
6. vm.$root // 根节点的vue对象, vm.$root === vm
7. vm.$children // 组件里面的值或传递的值
8. vm.$slots // 插槽
9. vm.$scopedslots // 插槽
10. vm.$refs // 获得模板中的节点或组件中的实例引用
11. vm.isServer // 服务端渲染
12. vm.$watch('监听的名字', (newVal, oldVal) => {})
13. const unwatch = vm.$watch() // 执行unwatch取消监听,在options中写的watch会自动取消监听
14. vm.$on('事件名称', () => {}) // 定义事件,相当于@
15. vm.$emit('事件名称', '传递参数') // 触发事件,有try catch,有异常不会中断执行
16. vm.$once('事件名称', () => {}) // 定义只触发一次的事件
17. vm.forceUpdate() // 重新渲染页面
18. vm.$set(vm.obj, 'name', 'cj') // 修改vm.obj.name = cj
19. vm.$delete(vm.obj, 'name') // 删除vm.obj.name
20. vm.$nextTick() // vue进行DOM更新时执行
21. vm.$destroy() // 销毁实例
22. vue的事件绑定@click="handle(agruments, $event)"
    如果不加括号在methods方法中能拿到e事件参数,如果加了括号则需要把$event传进去,下面才能拿到e参数
    在第一个参数前加上agruments可拿到所有传递的参数
----------------------------------------------------------------------------------------------
// 生命周期
1. beforeCreate() // 初始化之前,没有数据
2. create() // 初始化之后,1和2都不能做DOM操作,拿不到this.$el
3. beforeMount() // 页面挂载之前
4. mounted() // 页面挂载之后
5. beforeUpdate() // 数据更新之前
6. updated() //数据更新之后
7. activeted() // keep-alive组件激活之前
8. deactivated() // keep-alive组件停用时
9. beforeDestroy() // 实例销毁之前
10. destroyed() // 实例销毁之后
11. renderError(h, err) // render方法错误(本组件),开发环境使用
12. errorCaptured() // 收集错误,会向上冒泡,正式环境可以使用
----------------------------------------------------------------------------------------------
// computed/watch 不要去改变值,而是去执行操作
1. computed: {
  函数名() {
    return 'cj' // 相当于getter操作,有get、set操作(要写对象),计算修改值、拼接等
  }
}
2. watch: {
  obj/'obj.name': {
    handler(newVal, oldVal) {
      // 操作
    },
    immediate: true, // 马上执行,不等数据变化
    deep: true // 监听到子集
  }
}
----------------------------------------------------------------------------------------------
// 事件修饰符
1. @click.prevent // 阻止默认行为
2. @click.stop // 阻止冒泡
3. @click.capture // 变成捕获
4. @click.once // 只能触发一次
5. @click.self // 当e.target = e.cuttentTarget才触发
6. @click.right // 鼠标右键点击触发,还有middle、left
6. @keydown.enter.exact // 按下回车触发,还有tab、esc等,exact表示只能通过按下enter键触发,不加exact其他键和enter一起按也可以触发
7. @keydown.ctrl // 同时按下ctrl和其他键触发,还有shift、alt、meta等
----------------------------------------------------------------------------------------------
// v-model修饰符
1. v-model.lazy = "val" // 当鼠标失焦时触发而不是同步
2. v-model.number = "val" // 把val值转成数字,默认输入框中都是String
3. v-model.trim = "val" // 把val值的首位空格去除
----------------------------------------------------------------------------------------------
// 其他指令
1. v-pre // 不会解析标签里面的值,会原样显示
2. v-once // 里面的数据只绑定一次,不会再渲染
----------------------------------------------------------------------------------------------
// 组件继承
1. const compVue = Vue.extend(组件名)
   new compVue({ el: #id })
   数据通过propsData,而不通过props
   data会覆盖父级的data
   父级的生命周期先执行,再执行子级
2. const compVue2 = { extends: 组件名, data() {} }
   new Vue({ el: #id, components: { compVue2 }})
   与1一致
3. 当需要扩展组件时可以用extend
4. 可以通过this.$prent.$option去查看父级的东西或修改属性
5. 只有在new Vue时才能指定new Vue({ prent: prent })
----------------------------------------------------------------------------------------------
// 插槽
1. 组件定义: <div><slot name="body"></slot></div> // 具名插槽
   使用: <组件名><div slot="body">内容</div></组件名>
2. 组件定义: <div><slot a="1" b="2"></slot></div> // 组件向父组件传值
   使用: <组件名><div slot-scope="obj">{{ obj.a/obj.b }}</div></组件名>
----------------------------------------------------------------------------------------------
// provide和inject(非父子组件传递方法)
1. provide() { return { '传递的名字': this }} // 和生命周期平级,父级的this
2. inject: ['传递的名字'] // 在子组件中,即可使用this.传递的名字来获取父级的组件
----------------------------------------------------------------------------------------------
// render函数,相当于模板的template
1. template: <comp-one ref="comp"><span ref="span">{{ val }}</span></comp-one>
2. 所对应的render函数是:
   render(h) { // h === this.$createElement()
     return h(
      'comp-one',
      { ref: 'comp'},
      [h('span', {ref: 'span'}, this.val)]
     )
   }
----------------------------------------------------------------------------------------------
// vuex
1. const store = new vuex.store({
    state: { count: 0 },
    mutations: { updateCount(state, num) { state.count = num }},
    action: { updateCountSync(state, num) { state.count = num }}
  })
2. 在组件中的computed中使用,获取值时写在computed中
   computed: {
     count() {
       return this.$store.state.count
     }
   }
3. 在组件中的methods中使用,通过this.$store.commit('updateCount', 1) 调用mutations操作修改state
4. getter相当于组件内的computed
   getter: {
     sum(state) {
       return state.count + 1
     }
   }
   在组件中使用this.$store.getter.sum
5. 在组件中的computed中使用简写
   computed: {
     ...mapState(['count']) // 直接使用this.count === this.$store.state.count
     ...mapState({ counter: 'count' }) // 改变名称
     ...mapState({ counter: state => state.count }) // this.counter === this.$store.state.count
     ...mapGetter(['sum']) // 直接使用this.sum === this.$store.getter.sum
     ...mapState({ summit: 'sum' }) // 改变名称
   }
6. 修改state中的数据通过mutations(同步)或actions(异步)去修改
7. actions或组件通过this.$store.commit('mutations中的函数名', '传递的参数,多个值使用对象')
8. 组件通过this.$store.dispatch('actions中的函数名', '传递的参数,多个值使用对象')
9. 在组件中的methods中使用简写
   methods: {
     ...mapMutations(['mutations中的函数名']) === this.函数名(参数) === 7
     ...mapActions(['actions中的函数名']) === this.函数名(参数) === 8
   }
10. 模块
   const store = new vuex.store({
      modules: {
        g1: {
          state: {
            count: 1
          }
        },
        g2: {
          state: {
            count: 2
          }
        }
      }
   })
11. 在组件中的computed中使用
   computed: {
     count() {
       return this.$store.g1.state.count
     }
   }
12. 在组件中的computed中简写
   computed: {
     ...mapState([g1Count: state => state.g1.count])
   }
13. 默认模块下mutations会变成全局,所以使用时和7、9一样,也可以给module: { g1: { namespaced: true }}
14. 加配置,变成模块下的,则方法需要...mapmutations(['g1/函数名']),this['g1/函数名'](参数)调用
15. 在模块中的getter有3个参数,前2个一样,第3个是全局的state
16. 在模块中的actions可以调用commit触发当前模块下的mutations
17. 如果要触发全局下的mutations则需要在第三个参数中加上 { root: true },因为加了13的配置
18. 可以通过在入口文件时的store.registerModules('c', { state: { count: 1 }})动态增加模块
19. store.unrefisterModule('c') // 解除模块
20. store.watch // 监听state变化
21. store.subcribe((mutation, state) => { '哪个mutation', 'mutation的参数' }) // 获取mutations的变化
22. store.subcribeAction((action, state) => { '哪个action', 'action的参数' }) // 获取action的变化
23. 可以实现热更新
24. 全部配置
    export default () => {
      return new Vuex.store({
        strict: true, // 只用于生产环境,不能直接修改state的值
        state: { count: 1 },
        mutations: { updateCount(state, num) { state.count = num }},
        action: { updateCountSync(state, num) { state.count = num }}, // 也可直接commit调用mutations
        getter: { sum(state) {  return state.count + 1 } },
        modules: {
          g1: {
            state: {
              count: 1
            }
          },
          g2: {
            state: {
              count: 2
            }
          }
        }
      })
    }
25. vuex刷新会重置丢失数据,可以在数据中加入缓存机制解决 // 注意
26. 在actions中 return commit 可以在调用dispatch时使用.then获取修改后的值
27. vue-devtools可以在chrome商店中下载或使用远程的devtools,使用远程时需要在index.html中添加一段js,具体看github
28. getters使用时是通过函数return state的方式,要在new store时传入
29. 使用扩展运算符(...)在computed中相当是往computed添加对象属性 // 合并computed和store的值,就可以通过this.值获取
----------------------------------------------------------------------------------------------
// vue-router
1. vue-router默认的url加上#/为哈希,最好用history
2. route它是指一条路由
3. routes它是指一组路由
4. router它是一个机制,用来管理路由
5. 使用this.$route.query.参数名获取到的url参数,第一次获取到的值的类型时传递过来的类型
6. 刷新后获取到的值的类型则是String,因为路由没有变,直接取url上的
7. const routes = [
     { path: '/home', component: home },
     { path: '/login', component: login },
     { path: '/', redirect: '/home' } // 重定向,默认进入home页面
   ]
   var router = new Router( { routes })
   在html中使用<router-view></router-view>
8. export default () => {
      return new Router({
        routes, // 一组路由
        mode: 'histoty', // 把路由中默认加的#去掉
        base: '/base/', // 在使用跳转时在路径前面加上/base/
        linkActiveClass: 'active-link', // 当当前路由一部分和to="..."一样时会给元素加上这个类名,给<router-link>增加样式
        linkExactActiveClass: 'exact-active-link', // 当当前路由完全和to="..."一样时会给元素加上这个类名,给<router-link>增加样式
        scrollBehavior(to, from, savePosition) {
          // 进入页面时滚动到上次浏览的位置
          // to去哪个页面,from从哪里来,savePosition历史记录上次的位置
          if (savePosition) {
            return savePosition
          } else {
            return { x: 0, y: 0 }
          }
        },
        parseQuery(query) {
          // 字符串查询转为对象
        },
        stringifyQuery(obj) {
          // 对象查询转为字符串
        },
        fallback: true // 有的浏览器不能使用history会自动转为hash模式
      })
   }
9. 在routes中可以在组件中用this.$route获取url上的内容
   const routes = [{
     path: '/home/':id,
     component: () => import('路径') // 进行懒加载,在组件注册时也可用
     name: 'home', // 在<router-link :to="{ name: 'home' }">
     meta: {
       title: 'this is home',
       description: ''
     },
     children: [{ // 嵌套路由,在用children中需在所对应的组件中用<router-view>占位
       path: '/homeChildren,
       component: homeChildren,
     }],
     props: true,
     props: route => {
       id: route.query.id // 在组件中直接使用this.id,而不用使用this.$route.query.id
     }
   }]
10. 在<transition name="fade"><router-view /></transition> // 可以用过渡动画
11. 一个页面两个<router-view>对应不同的组件
    <router-view />
    <router-view name="g1" />
    const routes = [{
      path: '/home',
      components: {
        default: home, // 没name
        g1: homeg1 // 有name="g1"
      }
    }]
----------------------------------------------------------------------------------------------
// 导航守卫
1. 导航守卫: 类型中间件,进入路由前先通过守卫,进行操作,进入页面
2. 全局守卫: 在定义router的地方定义,main.js
   router.beforEach((to, from, next) => { console.log('beforEach') next() }) // 前置守卫
   router.beforResolve((to, from, next) => { console.log('beforResolve') next() }) // 解析守卫
   router.afterEach((to, from) => { console.log('afterEach') }) // 后置守卫
3. 路由独享守卫: 在路由内定义
   const routes = [{
     path: '/home',
     components: home,
     beforeEnter: (to, from, next) => { console.log('beforeEnter') next() }
   }]
4. 组件内的守卫: 在组件内定义
   beforeRouteEnter(to, from, next) {
     // 在渲染该组件的对应路由被confirm(弹框)前调用
     // 不能获取组件实例this,因为在守卫执行前,组件实例还没创建
     // 可用这个守卫给next传值 
     console.log('beforeRouteEnter')
     next()
   }
   beforeRouteUptate(to, from, next) {
     // 同一个组件但是id不同: abc/123到abc/456,生命周期不会重新执行,而这个可以,重用的组件
     console.log('beforeRouteUptate')
     next()
   }
   beforeRouteLeave(to, from, next) { console.log('beforeRouteLeave') next() }
----------------------------------------------------------------------------------------------
// 完整的导航解析流程
1. 导航被触发
2. 在失活的组件里调用beforeRouteLeave守卫
3. 调用全局的beforEach守卫
4. 在重用的组件里调用beforeRouteUpdate守卫
5. 在路由配置里调用beforeEnter守卫
6. 解析异步路由组件
7. 在被激活的组件中调用beforeRouteEnter守卫
8. 调用全局的beforeResolve守卫
9. 导航被确认调用全局的afterEach守卫
10. 触发DOM更新
```