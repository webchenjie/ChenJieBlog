---
title: 源码知识
date: 2021-10-23
---

```js
// 数据驱动（渲染流程）
1. 为什么在 Vue2 中，可以通过 this.msg 方式获取 data 或者 props 上的值？
    1. 原因就是这里 proxy 函数通过代理了 vm 实例，当通过 this. 方式访问时
       实际访问的是 this._data.msg 或者 this._props.msg
       在新版的 Vue2 中，用户自定义的 data、props、methods 会暴露到 vm 实例上
    2. 示例: src/core/instance/state proxy()
        const sharedPropertyDefinition = {
            enumerable: true,
            configurable: true,
            get: noop,
            set: noop
        }
        export function proxy (target: Object, sourceKey: string, key: string) {
            sharedPropertyDefinition.get = function proxyGetter () {
                return this[sourceKey][key]
            }
            sharedPropertyDefinition.set = function proxySetter (val) {
                this[sourceKey][key] = val
            }
            Object.defineProperty(target, key, sharedPropertyDefinition)
        }
        proxy(vm, `_data`, key)
        proxy(vm, `_props`, key)
2. 如果在 Vue2 的实例中没有传入 el 属性，则不会进行 DOM 渲染，在新版的 Vue2 中，mount 支持传入挂载的 el 节点
    1. 示例: src/core/instance/init initMixin()
        if (vm.$options.el) {
            vm.$mount(vm.$options.el)
        }
3. $mount：
   1. 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法
   2. 如果有 render 函数会直接使用 render 函数进行 mount，如果没有会判断 template
      它可以是一个字符串也可以是一个 DOM 对象，Vue 会获取该对象的 innerHTML
      如果没有 template 会拿 el 的 outerHTML，也就是说会优先使用 render ——> template ——> el
   3. 第一次渲染时会把原本的 HTML 中 id = 'app' 的 DOM 节点直接替换掉而不是插入 
4. createElement：
    1. 把 children 转换成一维数组
    2. 判断是否是原生 HTML 标签或者是组件名称
    3. 生成 VNode
5. 渲染流程：new Vue ——> init ——> $mount ——> compile（如果是 Runtime-Only 则没有）——> render（createElement） ——> vnode ——> patch ——> DOM
----------------------------------------------------------------------------------------------
// 组件化
1. 组件 patch 流程：createComponent ——> 子组件初始化 ——> 子组件 render ——> 子组件 patch
2. activeInstance 为当前激活的 vm 示例，vm.$vnode 是组件的占位 vnode，vm._vnode 是组件的渲染 vnode
    1. vm.$vnode 占位 vnode 指的就是该组件的父 VNode，即 _parentVnode
    2. vm._vnode 渲染 vnode 指的就是该组件中的渲染 vnode
    3. vm._vnode.parent === vm.$vnode
3. 嵌套组件的插入顺序是先子后父
```
