---
title: 基础知识
date: 2020-11-30
---

```js
// 数据结构与算法是什么？
1. 数据结构：计算机存储、组织数据的方式，就像锅碗瓢盆
2. 算法：一系列解决问题的清晰指令，就像食谱
----------------------------------------------------------------------------------------------
// 数据结构与算法的关系
1. 程序 = 数据结构 + 算法
2. 数据结构为算法提供服务，算法围绕数据结构操作
----------------------------------------------------------------------------------------------
// 时间复杂度是什么？
1. 一个函数，用大 O 表示，比如 O(1)、O(n)、O(logN) // log 即求 2 的多次方为 N
2. 时间复杂度用来定性描述该算法的运行时间 // 大概的趋势
3. O(n^2) > O(n) > O(logN) > O(1)
4. 只执行一次的代码的时间复杂度就是 O(1)
    let i = 0
    i += 1
5. 单次的循环的时间复杂度是 O(n)
    for (let i = 0; i < n; i++) {
      console.log(i)
    }
6. 计算时间复杂度的时候如果两个时间复杂度先后排列就把他们相加，而且要取增长趋势更快的时间复杂度
    let i = 0
    i += 1
    for (let i = 0; i < n; i++) {
      console.log(i)
    }
   以上代码的时间复杂度是 O(1) + O(n) = O(n)
7. 嵌套的循环的时间复杂度是相乘
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        console.log(i, j)
      }
    }
   以上代码的时间复杂度是 O(n) * O(n) = O(n^2)
8. let i = 1
   while (i < n) {
     console.log(i)
     i *= 2
   }
   以上代码的时间复杂度是 O(logN)
----------------------------------------------------------------------------------------------
// 空间复杂度是什么？
1. 一个函数，用大 O 表示，比如 O(1)、O(n)、O(n^2)
2. 算法在运行过程中临时占有存储空间大小的量度 // 内存大小
3. 空间复杂度为 O(1) 的例子
    let i = 0
    i += 1
   只声明了一个变量，占用了一个内存单元
4. 空间复杂度为 O(n) 的例子
    const list = []
    for (let i = 0; i < n; i++) {
      list.push(i)
    }
   声明了 n 个变量，占用了 n 个内存单元
5. 空间复杂度为 O(n^2) 的例子
    const matrix = []
    for (let i = 0; i < n; i++) {
      matrix.push([])
      for (let j = 0; j < n; j++) {
        matrix[i].push(j)
      }
    }
----------------------------------------------------------------------------------------------
// 栈是什么？
1. 一个后进先出的数据结构
2. js 中没有栈，但可以用 Array 实现栈的所有功能 // push 和 pop
3. 应用场景：
    十进制转二进制
    判断字符串的括号是否有效
    函数调用堆栈
4. 常用操作：push、pop、stack[stack.length - 1]
----------------------------------------------------------------------------------------------
// 队列是什么？
1. 一个先进先出的数据结构
2. js 中没有队列，但可以用 Array 实现队列的所有功能 // push 和 shift
3. 应用场景：
    食堂排队打饭
    js 异步中的任务队列
    计算最近请求次数
----------------------------------------------------------------------------------------------
// 链表是什么？
1. 多个元素组成的列表
2. 元素存储不连续，用 next 指针连在一起
3. 数组和链表的区别
    数组：增删非首尾元素时往往需要移动元素
    链表：增删非首尾元素不需要移动元素，只需要更新 next 指针
4. js 中没有链表，可以用 Object 模拟
5. 示例：
    // 创建
    const a = { val: 'a' }
    const b = { val: 'b' }
    const c = { val: 'c' }
    a.next = b
    b.next = c
    // 遍历
    let p = a
    while(p) {
      console.log(p.val)
      p = p.next
    }
    // 插入
    const d = { val: 'd' }
    b.next = d
    d.next = c
    // 删除
    b.next = c
6. 如何删除链表中的某一个节点？
    把要删除的节点的下一位节点赋值给当前要删除的节点，再删除下一位的节点，这样就变相的删除了指定的节点
----------------------------------------------------------------------------------------------
// 集合是什么？
1. 一种无序且唯一的数据结构
2. ES6 中有集合 Set
3. 集合的常用操作：
    去重、判断某元素是否在集合中、求交集
    // 去重
    const arr = [1, 1, 2, 2]
    const newArr = [...new Set(arr)]
    // 判断某元素是否在集合中
    const set = new Set(arr)
    const has = set.has(3)
    // 求交集
    const set2 = new Set([2, 3])
    const set3 = new Set([...set].filter(item => set2.has(item)))
----------------------------------------------------------------------------------------------
// 字典是什么？
1. 与集合类似，字典也是一种存储唯一值的数据结构，但它是以键值对的形式来存储
2. ES6 中有字典 Map
3. 字典的常用操作：
    键值对的增删改查
----------------------------------------------------------------------------------------------
// 树是什么？
1. 一种分层数据的抽象模型
2. 前端工作中常见的树包括：
    DOM树、级联选择、树形控件
3. js 中没有树，但是可以用 Object 和 Array 构建树
4. 树的常用操作：
    深度、广度优先遍历、先中后序遍历
5. 深度优先遍历：尽可能深的搜索树的分支 // 递归，适用于遍历深度嵌套的 json 串
    访问根节点
    对根节点的 children 挨个进行深度优先遍历
    例子：
      const dfs = root => {
        console.log(root.val)
        root.children.forEach(dfs)
      }
      dfs(tree)
6. 广度优先遍历：先访问离根节点最近的节点
    新建一个队列，把根节点入队
    把队头出队并访问
    把队头的 children 挨个入队
    重复第二、第三步骤，直到队列为空
    例子：
      const bfs = root => {
        const q = [root]
        while(q.length > 0) {
          const n = q.shift()
          console.log(n.val)
          n.children.forEach(child => {
            q.push(child)
          })
        }
      }
      bfs(tree)
----------------------------------------------------------------------------------------------
// 二叉树是什么？
// 二叉树的先中后序遍历
1. 树中每个节点最多只能有两个子节点
2. 在 js 中通常用 Object 来模拟二叉树
3. 先序遍历：// 先左后右
    访问根节点
    对根节点的左子树进行先序遍历
    对根节点的右子树进行先序遍历
    例子1：// 递归版
      const preoeder = root => {
        if (!root) { return }
        console.log(root.val)
        preoeder(root.left)
        preoeder(root.right)
      }
      preoeder(bt)
    例子2：// 非递归版
      const preoeder = root => {
        if (!root) { return }
        const stack = [root]
        while(stack.length) {
          const n = stack.pop()
          console.log(n.val)
          if (n.right) { stack.push(n.right) }
          if (n.left) { stack.push(n.left) }
        }
      }
      preoeder(bt)
4. 中序遍历：
    对根节点的左子树进行中序遍历
    访问根节点
    对根节点的右子树进行中序遍历
    例子1：// 递归版
      const inorder = root => {
        if (!root) { return }
        inorder(root.left)
        console.log(root.val)
        inorder(root.right)
      }
      inorder(bt)
    例子2：// 非递归版
      const inorder = root => {
        if (!root) { return }
        const satck = []
        let p = root
        while(stack.length || p) {
          while(p) {
            stack.push(p)
            p = p.left
          }
          const n = stack.pop()
          console.log(n.val)
          p = n.right
        }
      }
      inorder(bt)
4. 后序遍历：
    对根节点的左子树进行后序遍历
    对根节点的右子树进行后序遍历
    访问根节点
    例子1：// 递归版
      const postorder = root => {
        if (!root) { return }
        postorder(root.left)
        postorder(root.right)
        console.log(root.val)
      }
      postorder(bt)
    例子2：// 非递归版
      const postorder = root => {
        if (!root) { return }
        const outputStack = []
        const stack = [root]
        while(stack.length) {
          const n = stack.pop()
          outputStack.push(n)
          if (n.left) { stack.push(n.left) }
          if (n.right) { stack.push(n.right) }
        }
        while(outputStack.length) {
          const n = outputStack.pop()
          console.log(n.val)
        }
      }
      postorder(bt)
```