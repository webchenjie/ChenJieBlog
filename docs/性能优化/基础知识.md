---
title: 基础知识
date: 2020-11-07
---

```js
// 为什么要做性能优化
1. 性能是web网站和应用的支柱
----------------------------------------------------------------------------------------------
// 移动端挑战多
1. 设备硬件、网速、屏幕尺寸、交互方式
2. 用户更缺少耐心，大于3m加载导致53%的跳出率
3. 持续增长的移动用户和移动电商业务
----------------------------------------------------------------------------------------------
// RAIL测量模型
1. R：Response 响应 // 处理事件应在50ms以内完成
2. A：Animation 动画 // 每10ms产生一帧
3. I：Idle 空闲 // 尽可能增加空闲时间
4. L：Load 加载 // 在5s内完成内容加载并可以交互
----------------------------------------------------------------------------------------------
// 测试网站性能工具
1. webpagetest.org // 多测试地点，全面性能报告
2. chrome 中 DevTools 的 lighthouse // 网站整体质量评估，也可以通过 npm 安装，用命令行使用
    First Contentful Paint // 网页第一个出现的文字或图片的时间，从白屏到出现东西的时间
    Speed Index // 速度指数，小于4s就快，大于则需要优化
3. chrome 中的 DevTools 的 Network
    在 size 列中可以看到有两个值，上面是资源通过压缩后的大小，下面是资源本身的大小
    在打开 DevTools 的情况下可以按下 ESC 打开另一个菜单栏
4. chrome 中的 performance
    在 Main 栏中最下方可以看到调用的方法
----------------------------------------------------------------------------------------------
// 常用的性能测量API
1. performance 对象
    示例：
      window.addEventListener('load', (event) => {
        let timing = performance.getEntriesByType('navigation')[0];
        console.log(timing.domInteractive);
        console.log(timing.fetchStart);
        let diff = timing.domInteractive - timing.fetchStart;
        console.log("TTI: " + diff);
      })
    扩展：// performance.getEntriesByType('navigation')[0] 下的属性
      DNS 解析耗时: domainLookupEnd - domainLookupStart
      TCP 连接耗时: connectEnd - connectStart
      SSL 安全连接耗时: connectEnd - secureConnectionStart
      网络请求耗时 (TTFB): responseStart - requestStart
      数据传输耗时: responseEnd - responseStart
      DOM 解析耗时: domInteractive - responseEnd
      资源加载耗时: loadEventStart - domContentLoadedEventEnd
      First Byte时间: responseStart - domainLookupStart
      白屏时间: responseEnd - fetchStart
      首次可交互时间: domInteractive - fetchStart
      DOM Ready 时间: domContentLoadEventEnd - fetchStart
      页面完全加载时间: loadEventStart - fetchStart
      http 头部大小： transferSize - encodedBodySize
      重定向次数：performance.navigation.redirectCount
      重定向耗时: redirectEnd - redirectStart
      
2. PerformanceObserver
// 观察长任务
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(entry)
  }
})
observer.observe({entryTypes: ['longtask']})

3. visibilitychange // 事件，判断用户是否在当前这个页面
let vEvent = 'visibilitychange';
if (document.webkitHidden != undefined) {
    // webkit prefix detected
    vEvent = 'webkitvisibilitychange';
}

function visibilityChanged() {
    if (document.hidden || document.webkitHidden) {
        console.log("Web page is hidden.")
    } else {
        console.log("Web page is visible.")
    }
}

document.addEventListener(vEvent, visibilityChanged, false);

4. navigator // 判断用户当前网络状态
var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
var type = connection.effectiveType;

function updateConnectionStatus() {
  console.log("Connection type changed from " + type + " to " + connection.effectiveType);
  type = connection.effectiveType;
}

connection.addEventListener('change', updateConnectionStatus);
----------------------------------------------------------------------------------------------
// 浏览器渲染流程
1. 构建对象模型
    HTML ——> DOM // 构建 DOM 对象
    CSS ——> CSSOM // 构建 CSSOM 对象
2. 构建渲染树
    DOM + CSSOM = Render Tree
----------------------------------------------------------------------------------------------
// 浏览器关键渲染路径
JavaScript(触发视觉变化) ——> Style(重新计算样式) ——> Layout(布局即回流) ——> Paint(绘制即重绘) ——> Composite Layers(复合)
1. 渲染树只包含网页需要的节点
2. 布局是计算每个节点精确的位置和大小 // 盒模型
3. 绘制是像素化每个节点的过程
----------------------------------------------------------------------------------------------
// 影响回流的操作，可在 chrome 中的 performance 的 timings 查看 Layout
1. 添加或删除元素
2. 操作 style
3. display: none
4. offsetLeft、scrollTop、clienWidth // 每次获取都会计算最新值
5. 移动元素位置
6. 修改浏览器大小、字体大小
----------------------------------------------------------------------------------------------
// 避免 Layout thrashing
1. 避免回流
2. 读写分离 // 获取数据和设置数据
3. FastDom // 通过批量对 DOM 的读写操作来解决回流的库
----------------------------------------------------------------------------------------------
// Composite thread 复合线程做什么，和 ps 中多个图层一样
1. 将页面拆分图层进行绘制再进行复合 // 浏览器自带的规则拆分复合
    可以给元素添加 willChange: 'transform' 来让浏览器提取到一个图层中
2. 利用 performance 中的 Frames 弹出的菜单栏的 layers
3. 哪些样式仅影响了复合不会影响重绘
    transform: translate(50px, 50px)
    transform: scale(0.5)
    transform: rotate(90deg)
    opacity: 0.5
----------------------------------------------------------------------------------------------
// 减少重绘
1. 利用 performance 识别 paint 的瓶颈
2. 利用 will-change 创建新的图层 // 注意不可创建过多的图层
----------------------------------------------------------------------------------------------
// requestAnimationFrame 解决高频事件抖动
1. 会在 Layout 和 Paint 之前调用 // rAF
```