---
title: 基础知识
date: 2020-11-07
---

```js
// 从哪几方面入手优化
1. 渲染优化 // 浏览器
2. 代码优化
3. 资源优化
4. 构建优化
5. 传输加载优化
----------------------------------------------------------------------------------------------
// 为什么要做性能优化
1. 性能是web网站和应用的支柱
----------------------------------------------------------------------------------------------
// 移动端挑战多
1. 设备硬件、网速、屏幕尺寸、交互方式
2. 用户更缺少耐心，大于3m加载导致53%的跳出率
3. 持续增长的移动用户和移动电商业务
----------------------------------------------------------------------------------------------
// RAIL测量模型
1. R：Response 响应 // 处理事件应在50ms以内完成
2. A：Animation 动画 // 每10ms产生一帧
3. I：Idle 空闲 // 尽可能增加空闲时间
4. L：Load 加载 // 在5s内完成内容加载并可以交互
----------------------------------------------------------------------------------------------
// 测试网站性能工具
1. webpagetest.org // 多测试地点，全面性能报告
2. chrome 中 DevTools 的 lighthouse // 网站整体质量评估，也可以通过 npm 安装，用命令行使用
    First Contentful Paint // 网页第一个出现的文字或图片的时间，从白屏到出现东西的时间
    Speed Index // 速度指数，小于4s就快，大于则需要优化
3. chrome 中的 DevTools 的 Network
    在 size 列中可以看到有两个值，上面是资源通过压缩后的大小，下面是资源本身的大小
    在打开 DevTools 的情况下可以按下 ESC 打开另一个菜单栏
4. chrome 中的 performance
    在 Main 栏中最下方可以看到调用的方法
----------------------------------------------------------------------------------------------
// 常用的性能测量API
1. performance 对象
    示例：
      window.addEventListener('load', (event) => {
        let timing = performance.getEntriesByType('navigation')[0];
        console.log(timing.domInteractive);
        console.log(timing.fetchStart);
        let diff = timing.domInteractive - timing.fetchStart;
        console.log("TTI: " + diff);
      })
    扩展：// performance.getEntriesByType('navigation')[0] 下的属性
      DNS 解析耗时: domainLookupEnd - domainLookupStart
      TCP 连接耗时: connectEnd - connectStart
      SSL 安全连接耗时: connectEnd - secureConnectionStart
      网络请求耗时 (TTFB): responseStart - requestStart
      数据传输耗时: responseEnd - responseStart
      DOM 解析耗时: domInteractive - responseEnd
      资源加载耗时: loadEventStart - domContentLoadedEventEnd
      First Byte时间: responseStart - domainLookupStart
      白屏时间: responseEnd - fetchStart
      首次可交互时间: domInteractive - fetchStart
      DOM Ready 时间: domContentLoadEventEnd - fetchStart
      页面完全加载时间: loadEventStart - fetchStart
      http 头部大小： transferSize - encodedBodySize
      重定向次数：performance.navigation.redirectCount
      重定向耗时: redirectEnd - redirectStart
      
2. PerformanceObserver
// 观察长任务
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(entry)
  }
})
observer.observe({entryTypes: ['longtask']})

3. visibilitychange // 事件，判断用户是否在当前这个页面
let vEvent = 'visibilitychange';
if (document.webkitHidden != undefined) {
    // webkit prefix detected
    vEvent = 'webkitvisibilitychange';
}

function visibilityChanged() {
    if (document.hidden || document.webkitHidden) {
        console.log("Web page is hidden.")
    } else {
        console.log("Web page is visible.")
    }
}

document.addEventListener(vEvent, visibilityChanged, false);

4. navigator // 判断用户当前网络状态
var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
var type = connection.effectiveType;

function updateConnectionStatus() {
  console.log("Connection type changed from " + type + " to " + connection.effectiveType);
  type = connection.effectiveType;
}

connection.addEventListener('change', updateConnectionStatus);
----------------------------------------------------------------------------------------------
// 渲染优化
// 浏览器渲染流程
1. 构建对象模型
    HTML ——> DOM // 构建 DOM 对象
    CSS ——> CSSOM // 构建 CSSOM 对象
2. 构建渲染树
    DOM + CSSOM = Render Tree
----------------------------------------------------------------------------------------------
// 渲染优化——浏览器关键渲染路径
JavaScript(触发视觉变化) ——> Style(重新计算样式) ——> Layout(布局即回流) ——> Paint(绘制即重绘) ——> Composite Layers(复合)
1. 渲染树只包含网页需要的节点
2. 布局是计算每个节点精确的位置和大小 // 盒模型
3. 绘制是像素化每个节点的过程
----------------------------------------------------------------------------------------------
// 渲染优化——影响回流的操作，可在 chrome 中的 performance 的 timings 查看 Layout
1. 添加或删除元素
2. 操作 style
3. display: none
4. offsetLeft、scrollTop、clienWidth // 每次获取都会计算最新值
5. 移动元素位置
6. 修改浏览器大小、字体大小
----------------------------------------------------------------------------------------------
// 渲染优化——避免 Layout thrashing
1. 避免回流
2. 读写分离 // 获取数据和设置数据
3. FastDom // 通过批量对 DOM 的读写操作来解决回流的库
----------------------------------------------------------------------------------------------
// 渲染优化——Composite thread 复合线程做什么，和 ps 中多个图层一样
1. 将页面拆分图层进行绘制再进行复合 // 浏览器自带的规则拆分复合
    可以给元素添加 willChange: 'transform' 来让浏览器提取到一个图层中
2. 利用 performance 中的 Frames 弹出的菜单栏的 layers
3. 哪些样式仅影响了复合不会影响重绘
    transform: translate(50px, 50px)
    transform: scale(0.5)
    transform: rotate(90deg)
    opacity: 0.5
----------------------------------------------------------------------------------------------
// 渲染优化——减少重绘
1. 利用 performance 识别 paint 的瓶颈
2. 利用 will-change 创建新的图层 // 注意不可创建过多的图层
----------------------------------------------------------------------------------------------
// 渲染优化——requestAnimationFrame 解决高频事件抖动
1. 会在 Layout 和 Paint 之前调用 // rAF
----------------------------------------------------------------------------------------------
// 代码优化
1. 一段 js 代码在浏览器中运行需要经过加载、解析编译、执行这几步骤
2. 相同大小的 js 和图片加载速度图片会更快
3. 通过 code splitting 进行代码拆分，按需加载
4. 通过 tree shaking 代码减重
5. 避免长任务
6. 避免超过 1kb 的行间脚本
7. 使用 rAF 和 rIC 进行时间调度
8. 先加载首屏需要的东西
----------------------------------------------------------------------------------------------
// 代码优化——抽象语法树
1. 源码 ——> 抽象语法树 ——> 字节码Bytecode ——> 机器码
2. 编译过程会进行优化
3. 运行时可能发生反优化
----------------------------------------------------------------------------------------------
// 代码优化——v8优化机制
1. 脚本流 // 大于30kb的脚本会单独开一个线程出来，边下载边解析
2. 字节码缓存 // 缓存
3. 懒解析 // 相当于对函数的懒加载
----------------------------------------------------------------------------------------------
// 代码优化——函数优化
1. 由于上面提到的机制，默认会对函数进行懒解析
2. 可以通过给函数体包裹一对小括号来告诉浏览器这个函数是需要被马上解析的
    const add = (a, b) => a + b
    const add = ((a, b) => a + b) // 优化
3. 如果压缩了代码，工具会把我们加的括号给去掉所以需要用到 optimize.js 来把去掉的括号加回来
   webpack 已经解决了这个问题，一些老项目可能会用到 // npm install optimize
----------------------------------------------------------------------------------------------
// 代码优化——对象优化
1. 以相同顺序初始化对象成员，避免隐藏类的调整
2. 实例化后避免添加新属性
3. 尽量使用 Array 代替 array-like 对象 // array-like 即伪数组
4. 避免读取超过数组的长度
5. 避免元素类型转换 // [1, 2, 3].push(0.1) 就会造成元素类型转换
----------------------------------------------------------------------------------------------
// 代码优化——html优化
1. 减少 iframes 使用 // 可以先加载 iframes 标签，等加载完父容器再给 iframes 的 src 赋值加载
2. 压缩空白符
3. 避免节点深层级嵌套
4. 避免 table 布局
5. 删除注释
6. css 或 js 尽量外链
7. 删除元素默认属性
8. 可以借助 html-minifier 工具 // webpack 就是集成了这个工具进行html压缩
----------------------------------------------------------------------------------------------
// 代码优化——css优化
1. 降低 css 对渲染的阻塞
2. 利用 GPU 进行完成动画 // transform、opacity 不会影响重绘
3. 使用 contain 属性 // contain: layout 说明这个元素里面怎么变化都跟外面没关系，避免回流重绘
4. 使用 font-display 属性
----------------------------------------------------------------------------------------------
// 资源优化——为什么要压缩和合并？
1. 减少 http 请求数量
2. 减少请求资源的大小
----------------------------------------------------------------------------------------------
// 资源优化——html压缩
1. 使用在线工具进行压缩
2. 使用 html-minifier 等 npm 工具，也有集成了 clean-css
----------------------------------------------------------------------------------------------
// 资源优化——css压缩
1. 使用在线工具进行压缩
2. 使用 clean-css 等 npm 工具
----------------------------------------------------------------------------------------------
// 资源优化——压缩和混淆
1. 使用在线工具进行压缩
2. 使用 webpack 对 js 在构建时压缩
----------------------------------------------------------------------------------------------
// 资源优化——css、js 文件合并
1. 若干小文件 // maybe
2. 无冲突，服务相同的模块
3. 优化加载 // 不推荐，修改某一个会导致全部重新加载
----------------------------------------------------------------------------------------------
// 资源优化——图片
1. github.com/imagemin/imagemin // jpg 压缩
2. jpg 的优点：
    很高的压缩比，画质还可以被很好的被保持
    适用于展示大图、轮播图、视觉冲击
3. jpg 的缺点：
    有锯齿、模糊、边缘粗糙
4. github.com/imagemin/imagemin-pngquant // png 压缩
5. png 的优点：
    可以做透明的背景图片
    弥补了 jpg 的缺点
6. png 的缺点：
    体积大、适用于小图片
7. webp 的优点：
    和 png 一样的质量，比 png 小
8. webp 的缺点：
    不是标准，是 google 提出的，兼容性不好 // 80% 兼容
9. 图片懒加载
    原生：
        直接在 img 标签上加 loading="lazy" 属性即可实现懒加载 // 前提是浏览器支持
    插件：
        verlok/lazyload
        yall.js
        Blazy
10. 渐进式图片 // progressive JPEG
     基线式图片加载时是横向加载，渐进式图片加载时是全图模糊加载 // 默认是基线式图片
     相对于 基线式图片(Baseline JPEG) 对用户更友好
     解决方案：// 生成渐进式图片
        progressive-image
        ImageMagick
        libjpeg
        jpegtran
        jpeg-recompress
        imagemin
11. 响应式图片
     <img src="dog-200.jpg" sizes="100vw" srcset="dog-800.jpg 800w, dog-1200.jpg 1200w, dog-1800.jpg 1800w" />
     直接在 img 标签的属性上增加 sizes 和 srcset 属性即可实现在不同的设备上加载不同图片的大小
     也可以使用 <pictrue> 标签
----------------------------------------------------------------------------------------------
// 资源优化——字体
1. 什么是 FOIT 和FOUT：
    Flash Of Invisible Text // 文字闪烁，从看不到到看到的过程
    Flash Of Unstyled Text // 文字开始看上去是一种样式，后来经过样式渲染又变成另一种样式
2. 字体未下载完成时，浏览器隐藏或自动降级，导致字体闪烁或导致样式变化 // 不可避免
3. font-display 样式属性：
    font-display: block // 一开始不让字体显示，等加载完再显示，前 3s 生效，如果 3s 后还没加载完则会使用浏览器的默认字体代替再等加载完再显示
    font-display: swap // 替换，一开始就用一个默认的字体显示，等字体加载完就替换回去
    font-display: fallback // 和 block 差不多，区别是等待时间变成 100ms
    font-display: optional // 移动端专用，会判断用户网络情况，如果 100ms 内没有把字体加载完则会用默认字体且不会再替换成自定义的字体
4. 在 @font-face 中可以使用 unicode-range 进行字符集拆分
5. 使用 base64 把字体进行转码嵌入到 css 或 js 中加载 // 可以解决兼容性问题，缺点是缓存不可控
```