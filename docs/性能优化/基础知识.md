---
title: 基础知识
date: 2020-11-07
---

```js
// 从哪几方面入手优化
1. 渲染优化 // 浏览器
2. 代码优化
3. 资源优化
4. 构建优化
5. 传输加载优化
----------------------------------------------------------------------------------------------
// 为什么要做性能优化
1. 性能是web网站和应用的支柱
----------------------------------------------------------------------------------------------
// 移动端挑战多
1. 设备硬件、网速、屏幕尺寸、交互方式
2. 用户更缺少耐心，大于3m加载导致53%的跳出率
3. 持续增长的移动用户和移动电商业务
----------------------------------------------------------------------------------------------
// RAIL测量模型
1. R：Response 响应 // 处理事件应在50ms以内完成
2. A：Animation 动画 // 每10ms产生一帧
3. I：Idle 空闲 // 尽可能增加空闲时间
4. L：Load 加载 // 在5s内完成内容加载并可以交互
----------------------------------------------------------------------------------------------
// 测试网站性能工具
1. webpagetest.org // 多测试地点，全面性能报告
2. chrome 中 DevTools 的 lighthouse // 网站整体质量评估，也可以通过 npm 安装，用命令行使用
    First Contentful Paint // 网页第一个出现的文字或图片的时间，从白屏到出现东西的时间
    Speed Index // 速度指数，小于4s就快，大于则需要优化
3. chrome 中的 DevTools 的 Network
    在 size 列中可以看到有两个值，上面是资源通过压缩后的大小，下面是资源本身的大小
    在打开 DevTools 的情况下可以按下 ESC 打开另一个菜单栏
4. chrome 中的 performance
    在 Main 栏中最下方可以看到调用的方法
----------------------------------------------------------------------------------------------
// 常用的性能测量API
1. performance 对象
    示例：
      window.addEventListener('load', (event) => {
        let timing = performance.getEntriesByType('navigation')[0];
        console.log(timing.domInteractive);
        console.log(timing.fetchStart);
        let diff = timing.domInteractive - timing.fetchStart;
        console.log("TTI: " + diff);
      })
    扩展：// performance.getEntriesByType('navigation')[0] 下的属性
      DNS 解析耗时: domainLookupEnd - domainLookupStart
      TCP 连接耗时: connectEnd - connectStart
      SSL 安全连接耗时: connectEnd - secureConnectionStart
      网络请求耗时 (TTFB): responseStart - requestStart
      数据传输耗时: responseEnd - responseStart
      DOM 解析耗时: domInteractive - responseEnd
      资源加载耗时: loadEventStart - domContentLoadedEventEnd
      First Byte时间: responseStart - domainLookupStart
      白屏时间: responseEnd - fetchStart
      首次可交互时间: domInteractive - fetchStart
      DOM Ready 时间: domContentLoadEventEnd - fetchStart
      页面完全加载时间: loadEventStart - fetchStart
      http 头部大小： transferSize - encodedBodySize
      重定向次数：performance.navigation.redirectCount
      重定向耗时: redirectEnd - redirectStart
      
2. PerformanceObserver
// 观察长任务
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(entry)
  }
})
observer.observe({entryTypes: ['longtask']})

3. visibilitychange // 事件，判断用户是否在当前这个页面
let vEvent = 'visibilitychange';
if (document.webkitHidden != undefined) {
    // webkit prefix detected
    vEvent = 'webkitvisibilitychange';
}

function visibilityChanged() {
    if (document.hidden || document.webkitHidden) {
        console.log("Web page is hidden.")
    } else {
        console.log("Web page is visible.")
    }
}

document.addEventListener(vEvent, visibilityChanged, false);

4. navigator // 判断用户当前网络状态
var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
var type = connection.effectiveType;

function updateConnectionStatus() {
  console.log("Connection type changed from " + type + " to " + connection.effectiveType);
  type = connection.effectiveType;
}

connection.addEventListener('change', updateConnectionStatus);
----------------------------------------------------------------------------------------------
// 渲染优化
// 浏览器渲染流程
1. 构建对象模型
    HTML ——> DOM // 构建 DOM 对象
    CSS ——> CSSOM // 构建 CSSOM 对象
2. 构建渲染树
    DOM + CSSOM = Render Tree
----------------------------------------------------------------------------------------------
// 渲染优化——浏览器关键渲染路径
JavaScript(触发视觉变化) ——> Style(重新计算样式) ——> Layout(布局即回流) ——> Paint(绘制即重绘) ——> Composite Layers(复合)
1. 渲染树只包含网页需要的节点
2. 布局是计算每个节点精确的位置和大小 // 盒模型
3. 绘制是像素化每个节点的过程
----------------------------------------------------------------------------------------------
// 渲染优化——影响回流的操作，可在 chrome 中的 performance 的 timings 查看 Layout
1. 添加或删除元素
2. 操作 style
3. display: none
4. offsetLeft、scrollTop、clienWidth // 每次获取都会计算最新值
5. 移动元素位置
6. 修改浏览器大小、字体大小
----------------------------------------------------------------------------------------------
// 渲染优化——避免 Layout thrashing
1. 避免回流
2. 读写分离 // 获取数据和设置数据
3. FastDom // 通过批量对 DOM 的读写操作来解决回流的库
----------------------------------------------------------------------------------------------
// 渲染优化——Composite thread 复合线程做什么，和 ps 中多个图层一样
1. 将页面拆分图层进行绘制再进行复合 // 浏览器自带的规则拆分复合
    可以给元素添加 willChange: 'transform' 来让浏览器提取到一个图层中
2. 利用 performance 中的 Frames 弹出的菜单栏的 layers
3. 哪些样式仅影响了复合不会影响重绘
    transform: translate(50px, 50px)
    transform: scale(0.5)
    transform: rotate(90deg)
    opacity: 0.5
----------------------------------------------------------------------------------------------
// 渲染优化——减少重绘
1. 利用 performance 识别 paint 的瓶颈
2. 利用 will-change 创建新的图层 // 注意不可创建过多的图层
----------------------------------------------------------------------------------------------
// 渲染优化——requestAnimationFrame 解决高频事件抖动
1. 会在 Layout 和 Paint 之前调用 // rAF
----------------------------------------------------------------------------------------------
// 代码优化
1. 一段 js 代码在浏览器中运行需要经过加载、解析编译、执行这几步骤
2. 相同大小的 js 和图片加载速度图片会更快
3. 通过 code splitting 进行代码拆分，按需加载
4. 通过 tree shaking 代码减重
5. 避免长任务
6. 避免超过 1kb 的行间脚本
7. 使用 rAF 和 rIC 进行时间调度
8. 先加载首屏需要的东西
----------------------------------------------------------------------------------------------
// 代码优化——抽象语法树
1. 源码 ——> 抽象语法树 ——> 字节码Bytecode ——> 机器码
2. 编译过程会进行优化
3. 运行时可能发生反优化
----------------------------------------------------------------------------------------------
// 代码优化——v8优化机制
1. 脚本流 // 大于30kb的脚本会单独开一个线程出来，边下载边解析
2. 字节码缓存 // 缓存
3. 懒解析 // 相当于对函数的懒加载
----------------------------------------------------------------------------------------------
// 代码优化——函数优化
1. 由于上面提到的机制，默认会对函数进行懒解析
2. 可以通过给函数体包裹一对小括号来告诉浏览器这个函数是需要被马上解析的
    const add = (a, b) => a + b
    const add = ((a, b) => a + b) // 优化
3. 如果压缩了代码，工具会把我们加的括号给去掉所以需要用到 optimize.js 来把去掉的括号加回来
   webpack 已经解决了这个问题，一些老项目可能会用到 // npm install optimize
----------------------------------------------------------------------------------------------
// 代码优化——对象优化
1. 以相同顺序初始化对象成员，避免隐藏类的调整
2. 实例化后避免添加新属性
3. 尽量使用 Array 代替 array-like 对象 // array-like 即伪数组
4. 避免读取超过数组的长度
5. 避免元素类型转换 // [1, 2, 3].push(0.1) 就会造成元素类型转换
----------------------------------------------------------------------------------------------
// 代码优化——html优化
1. 减少 iframes 使用 // 可以先加载 iframes 标签，等加载完父容器再给 iframes 的 src 赋值加载
2. 压缩空白符
3. 避免节点深层级嵌套
4. 避免 table 布局
5. 删除注释
6. css 或 js 尽量外链
7. 删除元素默认属性
8. 可以借助 html-minifier 工具 // webpack 就是集成了这个工具进行压缩
----------------------------------------------------------------------------------------------
// 代码优化——css优化
1. 降低 css 对渲染的阻塞
2. 利用 GPU 进行完成动画 // transform、opacity 不会影响重绘
3. 使用 contain 属性 // contain: layout 说明这个元素里面怎么变化都跟外面没关系，避免回流重绘
4. 使用 font-display 属性
```