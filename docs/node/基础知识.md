---
title: 基础知识
date: 2020-07-19
---

```js
// 前端和Server端开发的区别
1. 服务稳定性
      server端可能会遭受各种恶意攻击和误操作
      单个客户端可以意外挂掉,但是服务端不能
      pm2进程守护
2. 考虑CPU和内存 // 优化、扩展
      客户端独占一个浏览器,内存和CPU都不是问题
      server端要承载很多请求,CPU和内存都是稀缺资源
      stream写日志,使用redis存session
3. 日志记录
      前端也会参与写日志,但只是日志的发起方,不关心后续
      server端要记录日志、存储日志、分析日志,前端不关心
4. 安全
      server端要随时准备接收各种恶意攻击,前端则少很多
      如: 越权操作,数据库攻击等
      语法xss攻击和sql注入
5. 集群和服务拆分
      产品发展速度快,流量可能会迅速增加
      如何通过扩展机器和服务拆分来承载大流量
----------------------------------------------------------------------------------------------
// 什么是nodejs
1. nodejs不是一门语言,不是库,不是框架,是一个js运行时环境,可以解析和执行js代码
2. nodejs是javascript的运行时,构建在chrome的v8引擎,nodejs用了事件驱动,非阻塞I/O模型
3. 阻塞: I/O时进程休眠等待I/O完成后进行下一步
4. 非阻塞: I/O时函数立即返回,进程不等待I/O完成
5. I/O操作很慢,是操作系统底层,读写硬盘数据
6. 事件驱动: I/O等异步操作结束后的通知,观察者模式
7. cpu密集: 计算、逻辑判断、压缩、解压、加密、解密
8. I/O密集: 存储设备、网络设施的读取、文件操作、数据库
9. 进程: 是计算机中的程序关于某数据集合上的一次运行活动,是系统进行资源分配和调度的基本单位,简单理解是一个运行的程序
10. 多进程: 启动多个进程,多个进程可以一块执行多个任务,原理是快速切换
11. 线程: 进程内一个相对独立的、可调度的执行单元,与同属一个进程的线程共享进程的资源
12. 多线程: 启动一个进程,在一个进程内启动多个线程,这样多个线程也可以一块执行多个任务
13. nodejs的单线程: 单线程只是针对主进程,I/O操作系统底层是多线程调度
14. 单线程不是单进程
15. 浏览器是多进程的
16. Node 是一个基于 V8 引擎的 Javascript 运行环境,它使得 Javascript 可以运行在服务端,直接与操作系统进行交互,与文件控制、网络交互、进程控制等
    Chrome 浏览器同样是集成了 V8 引擎的 Javascript 运行环境,与 Node 不同的是他们向 Javascript 注入的内容不同,Chrome 向 Javascript 注入了 window 对象,Node 注入的是 global,这使得两者应用场景完全不同,Chrome 的 Javascript 所有指令都需要通过 Chrome 浏览器作为中介实现
----------------------------------------------------------------------------------------------
// global变量,使用时不需要require
1. commonjs
2. process // 进程
   const { argr, argr0, execArgr, execPath, env } = process // 进程
   argr是一个数组,前2个是固定的,1是启动时使用的命令路径,2是当前执行文件的路径
   argr0是argr第一个值的引用
   execArgr可以拿到写在文件名之前的特殊参数 // node 参数 文件名
   execPath调用脚本的路径,相当于argr的第一个值
   env是各种配置参数
   process.cmd() // 返回process执行的路径
3. timer // setImmediate()、setTimeout()、nextTick()
    setImmediate(() => { code }) // 把当前函数放到下一个队列的队首
    process.nextTick(() => { code }) // 把当前函数放到当前队列的最后一个
    process.nextTick < setTimeout < setImmediate // process.nextTick最快,setImmediate最慢,一般用setImmediate
4. Buffer // 二进制
----------------------------------------------------------------------------------------------
// CommonJs
1. 每个文件是一个模块,有自己的作用域
2. 在模块内部module变量代表模块本身
3. module.export属性代表模块对外接口
// require规则
1. /表示绝对路径
2. ./表示相对路径
3. 支持js、json、node扩展名,不写则依次尝试
4. 不写路径直接写名字引入则认为是自带的模块或者各级node_modules内的第三方模块
// require特性
1. module被加载引用时会执行,加载后缓存,只执行一次
2. 一旦出现某个模块被循环加载,就只输出已经执行的部分,还未执行的部分不会输出
3. exports = module.exports,不能改变exports的指向
4. exports = { a: 1, b: 2 } // 错误
5. module.exports = { a: 1, b: 2 } // 正确
6. module.exports.fn1 = s1
   const mod = require('路径')
   mod.fn1
7. module.exports = {
      s1,
      s2
   }
   const { s1, s2 } = require('路径')
----------------------------------------------------------------------------------------------
// debug
1. node --inspect-brk 文件名
   在chrome中安装插件
   在url中输入'chrome://inspect'
2. 在vscode中打断点,可以打条件断点
----------------------------------------------------------------------------------------------
// 基础API——Path路径,操作系统不同,方法不同
1. const path = require('path')
2. path.normalize('路径') // 自动修复路径的错误
3. path.join('路径1', '路径2', ...) // 拼接路径,包含path.normalize()
4. path.resolve('相对路径') // 把相对路径解析成绝对路径
5. path.basename('路径') // 返回文件名
6. path.dirname('路径') // 返回所在的绝对路径
7. path.extname('路径') // 返回扩展名
8. path.parse('路径') // 把一个路径拆分成一个对象包括5、6、7、root、name
9. path.format('对象') // 把一个对象解析成一个路径,参数是一个对象
10. path.sep // 返回路径的分隔符,'/'
11. path.delimiter // 返回path的分隔符,':'
12. path.win32 // 操作系统,可以通过这2个属性调用与自己操作系统不同的方法和属性
13. path.posix // 操作系统,可以通过这2个属性调用与自己操作系统不同的方法和属性
14. __dirname、__filename总是返回文件的绝对路径 // require时自带的
15. process.cmd() // 总是返回执行node命令所在的文件夹路径
16. 在require方法中使用'./'相对的是当前文件所在的文件夹,而在其他地方和process.cmd()一样,相对的是node启动的文件夹
----------------------------------------------------------------------------------------------
// 基础API——Buffer,处理二进制数据流,是global对象,不需要require
1. Buffer用于处理二进制数据流,默认为十六进制表示,(0-255)的数字
2. 实例类似整数数组,大小固定不可改变
3. 使用的堆内存是c++代码,在v8堆外分配物理内存
// Buffer实例化
1. Buffer.alloc(10) // 创建长度为10的Buffer,默认用0填充
2. Buffer.alloc(10, 1) // 创建长度为10的Buffer,用1填充(十六进制)
3. Buffer.allocUnsafe() // 不安全的Buffer,可能包含旧数据
4. Buffer.from([1, 2, 3]) // 创建长度为3的Buffer
5. Buffer.from('text', 'base64') // 第二个参数不传,默认是utf-8
// 静态方法
1. Buffer.bytelength('测试') // 返回字节的长度,一个中文对应三个字节,返回6,英文是一个对应一个
2. Buffer.isBuffer({}) // 判断是否是Buffer对象, 返回布尔值
3. Buffer.concat([b1, b2]) // 拼接Buffer
// 实例方法
1. buf.length // 返回对应的字节数,和内容无关
2. buf.toStirng() // 可传入base64,默认是utf-8
3. buf.fill(10, 2, 6) // 从下标2开始到6填充10
4. buf.equals(buf) // 判断buf内容是否一致,返回布尔值
5. buf.indexOf() // 与js数组一样
6. buf.copy(b, 0, i) // copy到b,从0开始,i结束
// 处理中文乱码
1. const stringDecoder = require('string-decoder').stringDecoder
   const decoder = new stringDecoder('utf-8')
   decoder.write('字符')
----------------------------------------------------------------------------------------------
// 基础API——event,事件对象,继承了EventEmitter类(events)
1. const EventEmitter = require('events') // 引入
   class CustomEvent extend EventEmitter { code } // 继承
   const ce = new CustomEvent() // 实例化
   ce.on('test', () => { code }) // 绑定,也可用once绑定,只触发一次
   ce.emit('test', '参数') // 触发,后面可以用逗号隔开传参,个数不限
   ce.removeListener('test1', 'test2', () => { code }) // 移除,后面可以用逗号隔开移除多个事件
   ce.removeAllListeners() // 移除全部
----------------------------------------------------------------------------------------------
// 基础API——fs,文件有关,有回调函数,第一个参数保留给异常,当err是null或undefined时则是成功,可操作二进制数据
1. 所有的fs的API都有同步方法,在方法名后加Sync // 同步: fs.readFile(),异步: fs.readFileSync()
2. const fs = require('fs')
3. fs.readFile('文件路径', 'utf-8', (err, data) => { code }) // 读文件,默认是Buffer对象,可用toString()转成字符串,也可以在文件路径后面传第二个参数'utf-8'
4. fs.writeFile('文件路径', '写入内容', { encoding: 'utf-8' }, err => { code }) // 写文件, 可追加可覆盖需在第三参数传flags, 'a'表追加, 'w'表覆盖
5. fs.stat('文件路径', (err, stat) => { stat对象 }) // 文件信息
    stat.isFile() // 判断是否是文件
    stat.isDirectory() // 判断是否是文件夹
6. fs.rename('文件路径', '新名字', err => { code }) // 重命名
7. fs.unlink('文件路径', err => { code }) // 删除
8. fs.readdir('文件夹路径', (err, files) => { code }) // 读文件夹
9. fs.mkdir('新建的文件名', err => { code }) // 创建文件夹
10. fs.rmdir('文件夹路径', err => { code }) // 删除文件夹
11. fs.watch('监听的路径', { recursive: true }, (event, filename) => { code }) // 监听, recursive是递归监听,event是发生了什么变化,filename发生变化的文件名
12. const rs = fs.createReadStream('路径') // 读流,有方向的数据,读一点给一点,而不是全部读完再一起给
    rs.pipe(process.stdout) // 输出到控制台,pipe是输出,process.stdout是控制台
13. const ws = fs.createWriteStream('路径') // 写流,有方向的数据,写一点给一点,而不是全部写完再一起给
    ws.write('流') // 写
    rs.pipe(ws) // 把读到的数据用流的方式传递到写的地方, 可用于复制文件
    rs.on('data', chunk => {}) // 每次写的时候都会触发data事件
    rs.on('end', () => {}) // 当写完会触发end事件
    在http处理中也可以直接使用 rs.pipe(res) 即执行了 res.end('数据流')
14. process.stdin.pipe(process.stdout) // 标准流的输入输出, 可在node环境测试
----------------------------------------------------------------------------------------------
// promisify把异步函数转成promise解决回调地狱
1. const promisify = require('util').promisify
   const read = promisify(require('fs').readFile)
   read('路径').then(data => { code }).catch(err => { code })
2. 也可以通过async和await方式,在同步中try/catch相当于异步中的.catch
----------------------------------------------------------------------------------------------
// 自动重启node,相当于webpack的devServer
1. npm install supervisor
   supervisor 文件名
2. 当文件发生变化时,不用重新运行命令,相当于监听
----------------------------------------------------------------------------------------------
// 版本号x.y.z,如0.0.1
1. x: 不保证兼容,全新, 1.0.0,x为偶数时是稳定版,x为积数时是不稳定版
2. y: 有新增的功能同时兼容以前的功能,0.1.0
3. z: 有bug修改了, 0.0.2
4. 1.2.*表示z位最新不固定,和~1.2.0一样
5. 2.x表示y和z位最新不固定,和^2.0.0一样
6. alpha：内部测试版本，除非是内部测试人员，否则不推荐使用，有很多 bug
7. beta：公测版本，消除了严重错误，还是会有缺陷，这个阶段还会持续加入新的功能
8. rc：Release Candidate，发行候选版本，这个版本不会加入新的功能，主要是排错，修改 bug
9. release：正式版本
----------------------------------------------------------------------------------------------
// 本地构建
1. 压缩代码
2. 转换es6、7...
3. sass、前缀
----------------------------------------------------------------------------------------------
// ESlint
1. env: 脚本的运行环境
2. globals: 额外的全局变量
3. rules: 启用的规则
4. off === 0 // 关闭
5. warn === 1 // 开启,使用警告级别的错误,不会让程序退出
6. error === 2 // 开启,使用错误级别的错误,程序会退出
7. 在官网中的规则前面有√符号的表示推荐使用,前面有小扳手的表示可以通过命令行进行修复 // eslint --fix .
8. /* eslint-disable */ code /* eslint-enable */ // 中间的代码不受全部规则验证
9. /* eslint-disable no-alert, no-console */ code /* eslint-enable no-alert, no-console */ // 中间的代码不受no-alert, no-console验证
10. code // eslint-disable-line 这行不受全部规则验证
11. // eslint-disable-next-line 下一行不受全部规则验证
12. eslint --init // 创建一个配置规则
13. 可以通过npm install pre-commit这个包让代码如果有错误时,不让上传到git中去
----------------------------------------------------------------------------------------------
// npm参数
1. --save-dev === -D // 安装到devDependencies中(开发环境)
2. --save === -S === 不写 // 安装到dependencies中(生产环境)
3. -g // 全局安装
4. 全局安装的npm不会出现在package.json中,可以直接使用命令方式调用,如果不是全局安装则要用npx启动,或者在package.json的script中配置命令才能使用npm run的方式
5. 没有init时不加-S或-D时会安装到项目目录下,但不会写进package.json中
----------------------------------------------------------------------------------------------
// npm init生成的文件目录
1. README.md // 项目介绍
2. .gitignore // 不上传到git仓库的文件
    匹配模式前加'/'表示项目根目录
    匹配模式最后加'/'表示是目录,而不是文件
    匹配模式前加'!'表示取反
    '*'表示任意个字符
    '?'匹配任意一个字符
    '**'匹配多级目录
3. .npmignore // 不上传到npm仓库的文件,如果没有这个文件,会自动匹配.gitignore里面的配置
4. .editorConfig // 约定代码风格
5. .eslintrc.js // eslint代码校验
```
