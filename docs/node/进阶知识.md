---
title: 进阶知识
date: 2020-07-19
---

```js
// node连接mysql,属于硬盘数据库
1. npm install mysql // 安装
2. const mysql = require('mysql') // 引入
3. const con = mysql.createConnection({ // 创建连接对象
      host: 'localhost',
      user: 'root',
      password: '123456',
      port: '3306',
      database: '库名'
   })
4. con.connect() // 开始连接
5. con.query(sql语句, (err, data) => { code }) // 执行sql语句
6. con.end() // 关闭连接
7. 如果是插入或更新语句,会返回一个obj对象,其中可以判断affectedRows影响了几行、insertId插入的id,从而知道是否执行成功
----------------------------------------------------------------------------------------------
// node连接redis，属于内存数据库
1. 在命令行执行 redis-server 启动redis
2. npm install redis
3. const redis = require('redis')
4. const c = redis.create(lient(3006, '127.0.0.1'))
5. c.on('error', err => { code })
6. c.set('name', 'cj', redis.print) // 插入name=cj成功后在控制台打印ok
7. c.get('name', (err, data) => { code }) // 获取name
8. c.quit() // 退出
9. 把session存储在redis中就可以避免session过大会把node服务进程内存挤爆, 而且在做集群时,启用多个node服务即多个进程,无法共享数据
----------------------------------------------------------------------------------------------
// node 连接 mongodb
const MongoClient = require('mongodb').MongoClient // npm install mongodb
const url = 'mongodb://localhost:27017' // 地址
const dbName = 'myblog' // 库名

MongoClient.connect(
    url,
    {
        useUnifiedTopology: true
    },
    (err, client) => {
        if (err) {
            console.error('mongodb connect error', err)
            return
        }

        // 没有报错，说明连接成功
        console.log('mongodb connect success')

        // 切换到数据库（控制台 `use myblog`）
        const db = client.db(dbName)

        // 使用集合
        const usersCollection = db.collection('users') // users 即集合名称

        // 新增
        usersCollection.insertOne({
            username: 'chenj',
            password: 'abc',
            realname: '一条牛'
        }, (err, result) => {
            if (err) {
                console.error('users insert error', err)
                return
            }
            console.log(result)

            // 关闭连接
            client.close()
        })

        // 修改
        usersCollection.updateOne(
            { username: 'zhangsan' }, // 查询条件
            { $set: { realname: '张三A' } }, // 修改的内容，注意有 $set
            (err, result) => {
                if (err) {
                    console.error('users update error', err)
                    return
                }
                console.log(result)

                // 关闭连接
                client.close()
            }
        )

        // 删除
        usersCollection.deleteOne(
            { a: 101 },
            (err, result) => {
                if (err) {
                    console.error('users delete error', err)
                    return
                }
                console.log(result)

                // 关闭连接
                client.close()
            }
        )

        // 查询
        usersCollection.find({
            username: 'zhangsan',
            password: '123'
        }).toArray((err, result) => {
            if (err) {
                console.error('users find error', err)
                return
            }
            console.log(result)

            // 关闭连接
            client.close()
        })
    }
)
----------------------------------------------------------------------------------------------
// node 连接 mongoose
1. Schema 定义数据格式的规范
2. Model 规范 Collection
3. 规范数据操作的 API
4. mongoose 连接 mongodb
// db.js
const mongoose = require('mongoose')
const url = 'mongodb://localhost:27017'
const dbName = 'myblog'

mongoose.set('useFindAndModify', false)

mongoose.connect(`${url}/${dbName}`, {
    useNewUrlParser: true,
    useUnifiedTopology: true
})

const db = mongoose.connection

// 发生错误
db.on('error', err => {
    console.error(err)
})

// 连接成功
db.once('open', () => {
    console.log('mongoose connect success…')
})

module.exports = mongoose

5. model 和 Schema
// blog.js 即 connection
// 对应 blog 集合
const mongoose = require('../db')

// 规范
const BlogSchema = mongoose.Schema({
    title: {
        type: String,
        required: true // 必需
    },
    content: String,
    author: {
        type: String,
        required: true
    }
}, { timestamps: true }) // 会自动加时间戳

const Blog = mongoose.model('blog', BlogSchema) // blog 对应 blogs 集合

module.exports = Blog

6. mongoose 操作 mongodb
const Blog = require('../models/Blog')

!(async () => {

    // 新建博客
    const blog1 = await Blog.create({
        title: '标题3',
        content: '内容3',
        author: 'shuangyue'
    })
    console.log(blog1)

    // 获取列表
    const list = await Blog.find({
        // author: 'zhangsan'
        title: /A/ // 正则表达式，模糊查询
    }).sort({ _id: -1 })
    console.log(list)

    // 根据 id 获取单个博客
    const blog3 = await Blog.findById('5f4cc1824e9b73583b69b404')
    console.log(blog3)

    // 修改博客
    const res = await Blog.findOneAndUpdate(
        { _id: '5f4cc1824e9b73583b69b404' }, // 条件
        { content: '内容3内容3内容3' },
        {
            new: true // 返回修改之后的最新的内容，默认为 false
        }
    )
    console.log(res)

    // 删除
    const res = await Blog.findOneAndDelete({
        _id: '5f4cc1824e9b73583b69b404',
        author: 'shuangyue' // 验证一下作者，增加安全性，防止误删
    })
    console.log(res)
})()

----------------------------------------------------------------------------------------------
// 登录流程
1. 当用户登录成功时, 把用户信息如用户名存储到cookie中, 后端在判断是否登录, 可以直接通过cookie中的值判断
2. 如果直接把用户名存储在cookie中, 会不安全, 所以用到session
3. session原理是把每个请求的客户端都生成一个对应的id如userId, 然后通过Set-Cookie把userId存储到客户端的cookie中
4. 生成的id是可以加密的, 然后再把用户信息等内容存储到id对应的变量中去, 实现绑定, 原理和cookie中直接存储用户信息差不多
5. 把session存储到redis中, 只是把上面4中的那些原本在变量中的数据存储到redis数据库中而已
6. 在不使用connect-redis这个库时, 存储到redis中需要自己set进去, 而用了就只要配置文件就可以
7. 在所有接口调用前, 可以加一个中间件验证是否有登录或权限等
----------------------------------------------------------------------------------------------
// nginx和日志
1. 通过nginx反向代理可以让不同端口的数据从同一个端口中返回
2. 日志记录访问服务器的各种东西 // accesslog访问日志、eventlog自义定日志、errorlog错误日志
3. 通过linux的crontab命令即定时任务执行sh脚本拆分日志文件,日志前可加上时间节点用于拆分
   可设置时间每天或每周等把日志文件 'access.log' 拷贝并重命名为 '2020-09-17.access.log'
   然后清空'access.log'文件,继续积累日志
   crontab -e // 编辑crontab文件任务
   crontab -l // 查看有什么定时任务
4. 日志是按行存储的,一行就是一条日志,使用readline逐行读取文件,分析日志内容 // readline基于stream
    const readline = require('readline')
    const fs = require('fs')
    const path = require('path')
    const fileName = path.join(__dirname, access.log)
    const readStream = fs.createReadStream(fileName) // 创建读流
    // 创建 readline 对象
    const rl = readline.createInterface({
      input: readStream // 读取这个文件
    })
    rl.on('line', () => {}) // 逐行读取触发
    rl.on('close', () => {}) // 读取完成触发
----------------------------------------------------------------------------------------------
// 安全
1. sql注入: 通过在表单输入sql代码给服务器执行 // 在username中输入 chenj -- 就能实现免密登录
   解决方法: 使用mysql的escape函数处理输入内容 // 在拼接 sql 时，变量使用 escape 包裹执行
   原理: 把输入的内容转义,在sql中'-- '是注释后面代码的意思,应用在所有能拼接sql语句的地方
2. xss攻击: 在页面展示内容掺杂js代码
   解决方法: 把左右的尖括号转义或使用npm install xss,是一个函数
3. 密码加密: node自带加密库,crypto
    const crypto = require('crypto')
    // 密钥
    const SECRET_KEY = 'chenj0922'
    // md5加密
    function md5(content) {
      let md5 = crypto.createHash('md5')
      return md5.update(content).digest('hex') // 16进制
    }
    // 加密函数
    function genPassword(password) {
      const str = `password=${password}&key=${SECRET_KEY}`
      return md5(str)
    }
    module.expotrs ={
      genPassword
    }
----------------------------------------------------------------------------------------------
// async/await
1. express中间件是异步回调,koa2原生支持async/await
2. await后面可以追加promise对象,获取resolve的值
3. await必须包裹在async函数中
4. async函数执行返回也是一个promise对象
5. try/catch截获promise中reject的值
----------------------------------------------------------------------------------------------
// 断言
1. BDD行为驱动开发
2. TDD测试驱动开发
3. 断言库: chaijs // npm install chai
4. mocha让断言结果更丰富 // npm install mocha
----------------------------------------------------------------------------------------------
// 持续集成和覆盖率
1. 测试覆盖率: npm install istanbul 配合mocha
2. 持续集成: npm install egg
      频繁的将代码集成到主干
      每次集成都通过自动化的构建来验证
      尽早发现错误
      防止分支大幅偏离主干
3. benchmark排除性能影响 // jsperf.com
4. jest是ui测试,集成了覆盖率
----------------------------------------------------------------------------------------------
// 其他
1. node项目入口一般在'/bin/www.js'文件中
2. 在开发环境中可以使用 nodemon 包来自动重启node项目,否则每次修改都需要重启
3. 可以使用 corss-env 包来在package.json的script中获取env
    "dev": "corss-env NODE_ENV=dev nodemon ./bin/www.js"
4. 在项目架构时需要合理的拆分,要把路由(router)分成一个文件,把成功失败做一层封装(model)
   在router中返回的数据也需要一个文件(controller)
   也就是说项目的架构可以分为:
    'bin/www.js' -> 'app.js' -> 'router' -> 'controller' -> 'model'
5. 路由和API的关系
    API是前端和后端或不同端之间对接的术语,包括url路由、req输入、res输出
    路由是API的一部分
6. 后端可以通过设置cookie
    res.setHeader('Set-Cookie', 'username=cj; path=/; httpOnly; expires=过期时间必须是UTC格式')
```

# 原生 node

```js
const http = require('http')
const querystring = require('querystring') // 处理query参数
const server = http.createServer((req, res) => {
  console.log('req', req)
  console.log('res', res)

  const method = req.method
  const url = req.url
  const path = url.split('?')[0]
  const query = querystring.parse(url.split('?')[1])
  const env = process.env.NODE_ENV // 环境变量
  res.setHeader('Content-type', 'application/json') // 字符串的格式是json
  const resData = { method, url, path, query, env } // get请求并且路由是'/api/get'

  if (method === 'GET' && path === '/api/get') {
    res.end(JSON.stringify(resData)) // 返回字符串或二进制
    return
  } // post请求并且路由是'/api/post'

  if (method === 'POST' && path === '/api/post') {
    let postData = ''
    req.on('data', (chunk) => {
      postData += chunk.toString()
    })
    req.on('end', () => {
      resData.postData = postData
      res.end(JSON.stringify(resData)) // 返回字符串或二进制
    })
    return
  } // 未命中路由, 返回404

  res.writeHead(404, {
    'Content-type': 'text/plain',
  })
  res.write('404 Not Found')
  res.end()
})
server.listen(8000, () => {
  console.log('localhost:8000启动成功！')
})
```

# express

```js
1. 使用express脚手架创建
    npm install express-generator -g // 安装
    express test // 创建
    npm install // 安装依赖
    npm start // 运行
2. 在node中引入
npm i -S express
const express = require('express')
const cookieParser = require('cookie-parser')
const logger = require('morgan')
const session = require('express-session')
const redis = require('redis')
const redisStore = require('connect-redis')(session)
const fs = require('fs')
const path = require('path')

const app = express() // 创建 express 应用

const ENV = process.env.NODE_ENV
if (ENV !== 'production') {
  app.use(logger('dev')) // 记录日志, 也可传入 combined 记录更全面的日志
} else {
  const logFileName = path.join(__dirname, 'logs', 'access.log')
  const writeStream = fs.createWriteStream(logFileName, {
    flags: 'a' // 追加写入
  })
  app.use(logger('combined', {
    stream: writeStream
  }))
}

app.use(express.static(path.join(__dirname, 'public'))) // 静态文件
app.use(express.json()) // 解析post请求json格式的数据, 可以直接通过req.body获取
app.use(express.urlencoded({ extended: false })) // 解析post请求其他格式的数据, 可以直接通过req.body获取
app.use(cookieParser()) // 解析cookie, 可以直接通过req.cookie获取

const redisClient = redis.create(lient(3006, '127.0.0.1'))  // 连接redis
const sessionStore = new redisStore({
  client: redisClient
})
app.use(session({ // 设置session
  secret: 'chenj0922', // 密钥
  cookie: {
    path: '/',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000
  },
  store: sessionStore // 存储到redis中
}))

app.use('/', function(req, res, next) { // 相当于同一处理的路由, 有next
  console.log('路由中间件')
  console.log(req.body) // 可以直接拿到Post请求的参数
  console.log(req.query) // 可以直接拿到get请求的参数
  next()
})
app.get('/get', function(req, res) { // 只针对于get路由, 没有next
  console.log('get路由')
  console.log(req.body) // 可以直接拿到Post请求的参数
  console.log(req.query) // 可以直接拿到get请求的参数
  res.json({ code: 0 }) // 可以直接只用res.json返回json格式的数据, 不用再使用res.end(JSON.stringify(resData))
})
app.post('/post', function(req, res) { // 只针对于post路由, 没有next
  console.log('post路由')
  console.log(req.body) // 可以直接拿到Post请求的参数
  console.log(req.query) // 可以直接拿到get请求的参数
  res.json({ code: 0 }) // 可以直接只用res.json返回json格式的数据, 不用再使用res.end(JSON.stringify(resData))
})

// 参数可以多个, 相当于中间件, 用于校验登录权限等
app.post('/post', fn1, function(req, res) { // 只针对于post路由, 没有next
  console.log('post路由')
  console.log(req.body) // 可以直接拿到Post请求的参数
  console.log(req.query) // 可以直接拿到get请求的参数
  res.json({ code: 0 }) // 可以直接只用res.json返回json格式的数据, 不用再使用res.end(JSON.stringify(resData))
})

// 使 express 监听 5000 端口号发起的 http 请求
const server = app.listen(5000, function() {
  console.log('ok')
})
----------------------------------------------------------------------------------------------
// 路由演示, 有两个文件, 实际匹配的路由是 /blog/get
// app文件
const express = require('express')
const blogRouter = require('./routes/blog')
const app = express() // 创建 express 应用
app.use('/blog', blogRouter)
// 路由blog文件
const express = require('express')
const router = express.Router()
router.get('/get', function(req, res, next) {
  res.json({ code: 0 })
})
module.exports = router
----------------------------------------------------------------------------------------------
// 中间件, 中间件是一个函数,在请求和响应周期中被顺序调用
// 中间件需要在响应结束前被调用,除了异常处理的中间件需要后置
// 如果中间件中有异步代码，则会影响到后面中间件的执行时间
// express 会等异步执行完之后才会继续执行下一个中间件
const myLogger = function(req, res, next) {
  console.log('myLogger')
  next()
}
app.use(myLogger)
----------------------------------------------------------------------------------------------
// 异常处理,通过自定义异常处理中间件处理请求中产生的异常
// 注意:
// 第一,参数一个不能少,否则会视为普通的中间件
// 第二,中间件需要在请求之后引用
app.get('/', function(req, res) {
  throw new Error('something has error...')
})

const errorHandler = function (err, req, res, next) {
  console.log('errorHandler...')
  res.status(500)
  res.send('down...')
}

app.use(errorHandler)
```

# KOA

```js
// KOA
1. koa的中间件就是一个函数使用
2. const app = new koa()
   app.use((ctx, next) => { code }) // ctx用于中间件之间的传值,可以直接向ctx上面挂载属性,如ctx.a = 1,在另一个中间件中使用ctx.a获取
   app.listen(3000) // 监听3000端口
3. 洋葱模型,next()就是分界线
4. 中间件的调用都会返回promise,在每个next()方法前面加上await保证执行顺序是洋葱模型
5. koa-router
    const router = new Router()
    router.get('/', (ctx, next) => { code })
    app.use(router.routes())
    router.post('/v1/:id/books', (ctx, next) => {
      const path = ctx.params // 获取url上的参数id
      const query = ctx.request.query // 获取查询参数?后面的
      const headers = ctx.request.header // 获取请求头的内容
      app.use(parser()) // koa-bodyparser中间件
      const body = ctx.request.body // 获取http请求的body内容
    })
6. 在ctx中可以获取到很多: ctx.path、ctx.method等
7. ctx.body = { key: 'book' } // 在浏览器中显示的是json对象
8. 可以使用nodemon app.js来自动重启服务 // npm install nodemon
9. 通过requireDirectory实现路由自动加载
10. try/catch不能捕获到异步代码的异常,需要使用async和await来捕获异常
11. 在异步调用中必须使用async和await来同步代码
12. 浏览器中或API中返回NO Found是因为API没有返回结果
----------------------------------------------------------------------------------------------
// 示例
1. 使用koa脚手架创建, koa有两个版本, koa1是用generator做的, koa2是用async/await做的
    npm install koa-generator -g // 安装
    koa2 test // 创建
    npm install // 安装依赖
    npm start // 运行
2. 在node中引入
const Koa = require('koa')
const app = new Koa()
const json = require('koa-json')
const helmet = require('koa-helmet')
const bodyparser = require('koa-bodyparser') // 替换方案是 koa-body，它支持图像上传，koa-bodyparser 不支持
const logger = require('koa-logger') // 只是把在node环境中的console的打印格式优化, 并非日志
const morgan = require('koa-morgan') // 记录日志
const fs = require('fs')
const path = require('path')
const session = require('koa-generic-session')
const redisStore = require('koa-redis')

app.use(helmet()) // 自动添加安全的 hearder 头

app.use(bodyparser({ // 解析post请求json和其他格式的数据, 可以直接通过ctx.request.body获取
  enableTypes: ['json', 'form', 'text']
}))
app.use(json()) // 用于返回 json 格式的字符串

 // 日志
app.use(logger()) // 只是把在node环境中的console的打印格式优化, 并非日志
const ENV = process.env.NODE_ENV
if (ENV !== 'production') {
  app.use(morgan('dev')) // 记录日志, 也可传入 combined 记录更全面的日志
} else {
  const logFileName = path.join(__dirname, 'logs', 'access.log')
  const writeStream = fs.createWriteStream(logFileName, {
    flags: 'a' // 追加写入
  })
  app.use(morgan('combined', {
    stream: writeStream
  }))
}

app.use(require('koa-static')(__dirname + '/public')) // 静态文件

// session配置, 要放在路由注册之前
app.keys = ['chenj099']
app.use(session({
  // 配置cookie
  cookie: {
    path: '/',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000
  },
  // 配置redis
  store: redisStore({
    all: '127.0.0.1:9528'
  })
}))

// 使 koa2 监听 5000 端口号发起的 http 请求
const server = app.listen(5000, function() {
  console.log('ok')
})
----------------------------------------------------------------------------------------------
// 路由演示, 有两个文件, 实际匹配的路由是 /blog/get
// app文件
const blogRouter = require('./routes/blog')
const Koa = require('koa')
const app = new Koa()

 // 引入路由，allowedMethods 表示只支持路由中定义的方法进行访问，即 get 方法不能用 post 访问
app.use(blogRouter.routes(), blogRouter.allowedMethods())

// 路由blog文件
const router = require('koa-router')() // 默认koa2不支持router, 需要引入koa-router
router.prefix('/blog')
router.get('/get', async (ctx, next) => {
  const path = ctx.params // 获取url上的参数
  const query = ctx.request.query // 获取查询参数?后面的
  const headers = ctx.request.header // 获取请求头的内容
  const body = ctx.request.body // 获取http请求的body内容
  ctx.body = { // ctx.body相当于express的res.json
    path,
    query,
    headers,
    body,
    code: 0
  }
})
module.exports = router
```

# 爬虫

```js
1. npm install superagent // 发送请求获取html
2. npm install cheerio // 解析html
```

# pm2

```js
1. npm install pm2 -g
2. 常用命令:
    pm2 start app.js // 启动
    pm2 list // 查看启动列表
    pm2 restart AppName/id // 重启, AppName和id是pm2 list中表格展示的名称和id
    pm2 stop AppName/id // 停止, AppName和id是pm2 list中表格展示的名称和id
    pm2 delete AppName/id // 删除, AppName和id是pm2 list中表格展示的名称和id
    pm2 info AppName/id // 查看基本信息, AppName和id是pm2 list中表格展示的名称和id
    pm2 log AppName/id // 查看日志, 会自动把console记录到文件中去, AppName和id是pm2 list中表格展示的名称和id
    pm2 monit AppName/id // 查看内存和cpu, AppName和id是pm2 list中表格展示的名称和id
3. node app.js和nodemon app.js启动, 如果进程崩溃就无法访问
   pm2自带进程守护, 如果遇到进程崩溃会自动重启
4. 常用配置: // json文件
    pm2.config.json文件
    {
      "apps": {
        "name": 'pm2-config-name', // pm2 list中表格展示的名称
        "script": "app.js", // 启动的文件
        "watch": true, // 进程守护
        "instances": 4, // 电脑4核, 启用多进程
        "ignore_watch": ["node_modules", "logs"], // 忽略监听的文件
        "error_file": "logs/err.log", // 错误日志存放的地方
        "out_file": "logs/out.log", // console日志存放的地方
        "log_date_format": "YYYY-MM-DD HH:mm:ss" // 每条日志记录的时间格式
      }
    }
    在package.json文件的script中使用 pm2 start pm2.config.json
```

# nginx

```js
// 配置文件
user chenjie owner; // 权限(403)添加当前登录用户为owner
include /Users/chenjie/upload/upload.conf; // 相当于import '/Users/chenjie/upload/upload.conf'这个文件
server
{
  charset utf-8; // 字符
  listen 8089; // 监听的端口
  server_name http_host; // 域名名称
  root /Users/chenjie/upload/; // 访问的根路径
  autoindex on;
  add_header Cache-Control "no-cache, must-revalidate"; // 添加请求头
  location / {  // url路径
    add_header Access-Control-Allow-Origin *; // 跨域
  }
}
1. 当客户端向 Nginx 服务器发送请求时,Nginx首先会根据 IP地址和端口（listen 属性） 对server服务器进行配置
   如果IP地址匹配不成功,会对 域名（server_name属性） 进行匹配；如果域名也匹配不成功,则会默认匹配第一个server服务器
   因此,当只有一个Nginx服务器时,客户端的请任何情况下都会匹配到这个服务器上
2. 如果listen有ip和端口,那么server_name则不起作用
----------------------------------------------------------------------------------------------
// nginx命令
1. nginx // 启动nginx服务
2. nginx -s reload // 重启nginx服务
3. nginx -s stop // 停止nginx服务
4. nginx -t // 检查配置文件是否存在语法错误
----------------------------------------------------------------------------------------------
// 部署
1. 前端代码打包完成后可以直接把打包好的dist下的文件全部拖到云服务器中的nginx中即可
2. node代码如果是跟前端代码部署在同一台服务器上就可以直接通过pm2(node应用进程管理器)启动即可
   相当于在本地访问node服务
3. 如果不在同一台服务器上或者node代码还要提供给别的项目进行使用则需要使用nginx进行反向代理或者
   修改云服务器的开放端口实现
4. node代码中的监听端口只是监听服务器上的,而nginx上监听的80端口则是提供对外域名服务的
5. 反向代理方式是指代理服务器来接收Internet上的连接请求,然后将请求转发给内部网络上的服务器
   并将服务器上得到的结果返回给Internet上请求连接的客户端,此时代理服务器对外就表现为一个服务器
```
