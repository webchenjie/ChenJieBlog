---
title: 进阶知识
date: 2020-07-19
---

``` js
// 数据库
1. 关系型数据库: SQLServer、MySQL、Oracle、postgresSQL、Access // 除了这些之外的都是非关系型数据库
2. SQL语句:
    a <> 0 // a !== 0
    show databases // 查看所有的库
    create schema '库名' // 创建库
    create table '库名' '表名' // 创建表
    use '库名' // 使用这个库
    show tables // 查看当前库中的所有表
    insert into '表名'(username, pwd) values('cj', '123') // 插入数据
    select * from users // 查这个表下的所有数据列
    select id, username from users // 查users表下的id和username列的数据
    select * from users where username = 'cj' and/or pwd = '123' // 查users表下username = cj并且/或者pwd是123的数据
    select * from users where username like %cj% // 模糊查username = cj
    select * from users where username like %cj% order by id (desc) // 模糊查username = cj,排序id,加desc为倒序
    update users set pwd = '456' where pwd = '123' // 把pwd = 123 改成 pwd = 456
    delete from users where pwd = '123' // 删除pwd = 123这一行
    正常不会通过直接删,会采用给每一行新增一个属性status,用update来改变这个值,从而达到删除的目的,不是真的删除
----------------------------------------------------------------------------------------------
// node连接mysql
1. npm install mysql // 安装
2. const mysql = require('mysql') // 引入
3. const con = mysql.createConnection({ // 创建连接对象
      host: 'localhost',
      user: 'root',
      password: '123456',
      port: '3306',
      database: '库名'
   })
4. con.connect() // 开始连接
5. con.query(sql语句, (err, data) => { code }) // 执行sql语句
6. con.end() // 关闭连接
----------------------------------------------------------------------------------------------
// redis数据库
1. 访问数据频繁,对性能要求极高
2. 断电丢失数据,内存的硬伤
3. 数据量不会太大
4. set name cj // 添加name = cj
5. get name // 获取name
6. del name // 删除name
7. keys * // 获取全部key
----------------------------------------------------------------------------------------------
// node连接redis
1. npm install redis
2. const redis = require('redis')
3. const c = redis.create(lient(3006, '127.0.0.1'))
4. c.on('error', err => { code })
5. c.set('name', 'cj', redis.print) // 插入name=cj成功后在控制台打印ok
6. c.get('name', (err, data) => { code }) // 获取name
7. c.quit() // 退出
----------------------------------------------------------------------------------------------
// nginx和日志
1. 通过nginx反向代理可以让不同端口的数据从同一个端口中返回
2. 日志记录访问服务器的各种东西
3. 通过crontab拆分日志文件(定时任务linx)
4. 使用readline分析日志内容(逐行读取文件)
----------------------------------------------------------------------------------------------
// 安全
1. sql注入: 通过在表单输入sql代码给服务器执行
   解决方法: 使用escape函数
   原理: 把输入的内容转义,在sql中'-- '是注释后面代码的意思,应用在所有能拼接sql语句的地方
2. xss攻击: 在页面展示内容掺杂js代码
   解决方法: 把左右的尖括号转义或使用npm install xss,是一个函数
3. 密码加密: node自带加密库,crypto
----------------------------------------------------------------------------------------------
// async/await
1. express中间件是异步回调,koa2原生支持async/await
2. await后面可以追加promise对象,获取resolve的值
3. await必须包裹在async函数中
4. async函数执行返回也是一个promise对象
5. try/catch截获promise中reject的值
----------------------------------------------------------------------------------------------
// 断言
1. BDD行为驱动开发
2. TDD测试驱动开发
3. 断言库: chaijs // npm install chai
4. mocha让断言结果更丰富 // npm install mocha
----------------------------------------------------------------------------------------------
// 持续集成和覆盖率
1. 测试覆盖率: npm install istanbul 配合mocha
2. 持续集成: npm install egg
      频繁的将代码集成到主干
      每次集成都通过自动化的构建来验证
      尽早发现错误
      防止分支大幅偏离主干
3. benchmark排除性能影响 // jsperf.com
4. jest是ui测试,集成了覆盖率
```

# express
``` js
1. npm i -S express
const express = require('express')

// 创建 express 应用
const app = express()

// 监听 / 路径的 get 请求
app.get('/', function(req, res) {
  res.send('hello node')
})

// 使 express 监听 5000 端口号发起的 http 请求
const server = app.listen(5000, function() {
  const { address, port } = server.address()
  console.log('Http Server is running on http://%s:%s', address, port)
})
----------------------------------------------------------------------------------------------
// 中间件, 中间件是一个函数,在请求和响应周期中被顺序调用
// 中间件需要在响应结束前被调用,除了异常处理的中间件需要后置
const myLogger = function(req, res, next) {
  console.log('myLogger')
  next()
}

app.use(myLogger)
----------------------------------------------------------------------------------------------
// 路由
// 请求方法：get、post......
// 请求的路径：/、/user、/.*fly$/......
// 响应 / 路径的 get 请求
app.get('/', function(req, res) {
  res.send('hello node')
})
// 响应 / 路径的 post 请求
app.post('/', function(req, res) {
  res.send('hello node')
})
----------------------------------------------------------------------------------------------
// 异常处理,通过自定义异常处理中间件处理请求中产生的异常
// 注意:
// 第一,参数一个不能少,否则会视为普通的中间件
// 第二,中间件需要在请求之后引用
app.get('/', function(req, res) {
  throw new Error('something has error...')
})

const errorHandler = function (err, req, res, next) {
  console.log('errorHandler...')
  res.status(500)
  res.send('down...')
}

app.use(errorHandler)
```

# KOA
``` js
// KOA
1. koa的中间件就是一个函数使用
2. const app = new koa()
   app.use((ctx, next) => { code }) // ctx用于中间件之间的传值,可以直接向ctx上面挂载属性,如ctx.a = 1,在另一个中间件中使用ctx.a获取
   app.listen(3000) // 监听3000端口
3. 洋葱模型,next()就是分界线
4. 中间件的调用都会返回promise,在每个next()方法前面加上await保证执行顺序是洋葱模型
5. koa-router
    const router = new Router()
    router.get('/', (ctx, next) => { code })
    app.use(router.routes())
    router.post('/v1/:id/books', (ctx, next) => {
      const path = ctx.params // 获取url上的参数id
      const query = ctx.request.query // 获取查询参数?后面的
      const headers = ctx.request.header // 获取请求头的内容
      app.use(parser()) // koa-bodyparser中间件
      const body = ctx.request.body // 获取http请求的body内容
    })
6. 在ctx中可以获取到很多: ctx.path、ctx.method等
7. ctx.body = { key: 'book' } // 在浏览器中显示的是json对象
8. 可以使用nodemon app.js来自动重启服务 // npm install nodemon
9. 通过requireDirectory实现路由自动加载
10. try/catch不能捕获到异步代码的异常,需要使用async和await来捕获异常
11. 在异步调用中必须使用async和await来同步代码
12. 浏览器中或API中返回NO Found是因为API没有返回结果
```

# nginx
``` js
// 配置文件
user chenjie owner; // 权限(403)添加当前登录用户为owner
include /Users/chenjie/upload/upload.conf; // 相当于import '/Users/chenjie/upload/upload.conf'这个文件
server
{ 
  charset utf-8; // 字符
  listen 8089; // 监听的端口
  server_name http_host; // 域名名称
  root /Users/chenjie/upload/; // 访问的根路径
  autoindex on;
  add_header Cache-Control "no-cache, must-revalidate"; // 添加请求头
  location / {  // url路径
    add_header Access-Control-Allow-Origin *; // 跨域
  }
}
1. 当客户端向 Nginx 服务器发送请求时,Nginx首先会根据 IP地址和端口（listen 属性） 对server服务器进行配置
   如果IP地址匹配不成功,会对 域名（server_name属性） 进行匹配；如果域名也匹配不成功,则会默认匹配第一个server服务器
   因此,当只有一个Nginx服务器时,客户端的请任何情况下都会匹配到这个服务器上
2. 如果listen有ip和端口,那么server_name则不起作用
----------------------------------------------------------------------------------------------
// nginx命令
1. nginx // 启动nginx服务
2. nginx -s reload // 重启nginx服务
3. nginx -s stop // 停止nginx服务
4. nginx -t // 检查配置文件是否存在语法错误
----------------------------------------------------------------------------------------------
// 部署
1. 前端代码打包完成后可以直接把打包好的dist下的文件全部拖到云服务器中的nginx中即可
2. node代码如果是跟前端代码部署在同一台服务器上就可以直接通过pm2(node应用进程管理器)启动即可
   相当于在本地访问node服务
3. 如果不在同一台服务器上或者node代码还要提供给别的项目进行使用则需要使用nginx进行反向代理或者
   修改云服务器的开放端口实现
4. node代码中的监听端口只是监听服务器上的,而nginx上监听的80端口则是提供对外域名服务的
5. 反向代理方式是指代理服务器来接收Internet上的连接请求,然后将请求转发给内部网络上的服务器
   并将服务器上得到的结果返回给Internet上请求连接的客户端,此时代理服务器对外就表现为一个服务器
```