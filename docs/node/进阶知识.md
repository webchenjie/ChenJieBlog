---
title: 进阶知识
date: 2020-07-19
---

```js
// 数据库
1. 关系型数据库: SQLServer、MySQL、Oracle、postgresSQL、Access // 除了这些之外的都是非关系型数据库
2. SQL语句:
    a <> 0 // a !== 0
    show databases // 查看所有的库
    create schema '库名' // 创建库
    create table '库名' '表名' // 创建表
    use '库名' // 使用这个库
    show tables // 查看当前库中的所有表
    insert into '表名'(username, pwd) values ('cj', '123') // 插入数据
    select * from users // 查这个表下的所有数据列
    select id, username from users // 查users表下的id和username列的数据
    select * from users where username = 'cj' and/or pwd = '123' // 查users表下username = cj并且/或者pwd是123的数据
    select * from users where username like %cj% // 模糊查username = cj
    select * from users where username like %cj% order by id desc // 模糊查username = cj,排序id,加desc为倒序
    update users set pwd = '456' where username = 'cj' // 把username = cj 的这条记录的pwd改成 pwd = 456
    delete from users where pwd = '123' // 删除pwd = 123这一行
    正常不会通过直接删,会采用给每一行新增一个属性status,用update来改变这个值,从而达到删除的目的,不是真的删除
    `password`是数据库的保留名称,如果有字段是password需要加上``才可以
    在SQL客户端中写SQL语句前面加上--表示注释
    在写SQL的条件where时可以在后面跟上 1=1, 避免后面要拼接的参数无值
      select * from users where 1=1
----------------------------------------------------------------------------------------------
// node连接mysql,属于硬盘数据库
1. npm install mysql // 安装
2. const mysql = require('mysql') // 引入
3. const con = mysql.createConnection({ // 创建连接对象
      host: 'localhost',
      user: 'root',
      password: '123456',
      port: '3306',
      database: '库名'
   })
4. con.connect() // 开始连接
5. con.query(sql语句, (err, data) => { code }) // 执行sql语句
6. con.end() // 关闭连接
7. 如果是插入或更新语句,会返回一个obj对象,其中可以判断affectedRows影响了几行、insertId插入的id,从而知道是否执行成功
----------------------------------------------------------------------------------------------
// redis数据库,属于内存数据库
1. 访问数据频繁,对性能要求极高
2. 断电丢失数据,内存的硬伤
3. 数据量不会太大
4. 在命令行执行 redis-cli 才能使用以下命令
5. set name cj // 添加name = cj
6. get name // 获取name
7. del name // 删除name
8. keys * // 获取全部key
9. 把session存储在redis中就可以避免session过大会把node服务进程内存挤爆, 而且在做集群时,启用多个node服务即多个进程,无法共享数据
----------------------------------------------------------------------------------------------
// node连接redis
1. 在命令行执行 redis-server 启动redis
2. npm install redis
3. const redis = require('redis')
4. const c = redis.create(lient(3006, '127.0.0.1'))
5. c.on('error', err => { code })
6. c.set('name', 'cj', redis.print) // 插入name=cj成功后在控制台打印ok
7. c.get('name', (err, data) => { code }) // 获取name
8. c.quit() // 退出
----------------------------------------------------------------------------------------------
// nginx和日志
1. 通过nginx反向代理可以让不同端口的数据从同一个端口中返回
2. 日志记录访问服务器的各种东西
3. 通过crontab拆分日志文件(定时任务linx)
4. 使用readline分析日志内容(逐行读取文件)
----------------------------------------------------------------------------------------------
// 安全
1. sql注入: 通过在表单输入sql代码给服务器执行
   解决方法: 使用escape函数
   原理: 把输入的内容转义,在sql中'-- '是注释后面代码的意思,应用在所有能拼接sql语句的地方
2. xss攻击: 在页面展示内容掺杂js代码
   解决方法: 把左右的尖括号转义或使用npm install xss,是一个函数
3. 密码加密: node自带加密库,crypto
----------------------------------------------------------------------------------------------
// async/await
1. express中间件是异步回调,koa2原生支持async/await
2. await后面可以追加promise对象,获取resolve的值
3. await必须包裹在async函数中
4. async函数执行返回也是一个promise对象
5. try/catch截获promise中reject的值
----------------------------------------------------------------------------------------------
// 断言
1. BDD行为驱动开发
2. TDD测试驱动开发
3. 断言库: chaijs // npm install chai
4. mocha让断言结果更丰富 // npm install mocha
----------------------------------------------------------------------------------------------
// 持续集成和覆盖率
1. 测试覆盖率: npm install istanbul 配合mocha
2. 持续集成: npm install egg
      频繁的将代码集成到主干
      每次集成都通过自动化的构建来验证
      尽早发现错误
      防止分支大幅偏离主干
3. benchmark排除性能影响 // jsperf.com
4. jest是ui测试,集成了覆盖率
----------------------------------------------------------------------------------------------
// 其他
1. node项目入口一般在'/bin/www.js'文件中
2. 在开发环境中可以使用 nodemon 包来自动重启node项目,否则每次修改都需要重启
3. 可以使用 corss-env 包来在package.json的script中获取env
    "dev": "corss-env NODE_ENV=dev nodemon ./bin/www.js"
4. 在项目架构时需要合理的拆分,要把路由(router)分成一个文件,把成功失败做一层封装(model)
   在router中返回的数据也需要一个文件(controller)
   也就是说项目的架构可以分为:
    'bin/www.js' -> 'app.js' -> 'router' -> 'controller' -> 'model'
5. 路由和API的关系
    API是前端和后端或不同端之间对接的术语,包括url路由、req输入、res输出
    路由是API的一部分
6. 后端可以通过设置cookie
    res.setHeader('Set-Cookie', 'username=cj; path=/; httpOnly; expires=过期时间必须是UTC格式')
```

# 原生node的http

```js
const http = require('http')
const querystring = require('querystring') // 处理query参数
const server = http.createServer((req, res) => {
  console.log('req', req)
  console.log('res', res)

  const method = req.method
  const url = req.url
  const path = url.split('?')[0]
  const query = querystring.parse(url.split('?')[1])
  const env = process.env.NODE_ENV // 环境变量

  res.setHeader('Content-type', 'application/json') // 字符串的格式是json

  const resData = { method, url, path, query, env }

  // get请求并且路由是'/api/get'
  if (method === 'GET' && path === '/api/get') {
    res.end(JSON.stringify(resData)) // 返回字符串或二进制
    return
  }

  // post请求并且路由是'/api/post'
  if (method === 'POST' && path === '/api/post') {
    let postData = ''
    req.on('data', chunk => {
      postData += chunk.toString()
    })
    req.on('end', () => {
      resData.postData = postData
      res.end(JSON.stringify(resData)) // 返回字符串或二进制
    })
    return
  }

  // 未命中路由, 返回404
  res.writeHead(404, {
    'Content-type': 'text/plain'
  })
  res.write('404 Not Found')
  res.end()

})
server.listen(8000, () => {
  console.log('localhost:8000启动成功！')
})
```

# express

```js
1. npm i -S express
const express = require('express')

// 创建 express 应用
const app = express()

// 监听 / 路径的 get 请求
app.get('/', function(req, res) {
  res.send('hello node')
})

// 使 express 监听 5000 端口号发起的 http 请求
const server = app.listen(5000, function() {
  const { address, port } = server.address()
  console.log('Http Server is running on http://%s:%s', address, port)
})
----------------------------------------------------------------------------------------------
// 中间件, 中间件是一个函数,在请求和响应周期中被顺序调用
// 中间件需要在响应结束前被调用,除了异常处理的中间件需要后置
const myLogger = function(req, res, next) {
  console.log('myLogger')
  next()
}

app.use(myLogger)
----------------------------------------------------------------------------------------------
// 路由
// 请求方法：get、post......
// 请求的路径：/、/user、/.*fly$/......
// 响应 / 路径的 get 请求
app.get('/', function(req, res) {
  res.send('hello node')
})
// 响应 / 路径的 post 请求
app.post('/', function(req, res) {
  res.send('hello node')
})
----------------------------------------------------------------------------------------------
// 异常处理,通过自定义异常处理中间件处理请求中产生的异常
// 注意:
// 第一,参数一个不能少,否则会视为普通的中间件
// 第二,中间件需要在请求之后引用
app.get('/', function(req, res) {
  throw new Error('something has error...')
})

const errorHandler = function (err, req, res, next) {
  console.log('errorHandler...')
  res.status(500)
  res.send('down...')
}

app.use(errorHandler)
```

# KOA

```js
// KOA
1. koa的中间件就是一个函数使用
2. const app = new koa()
   app.use((ctx, next) => { code }) // ctx用于中间件之间的传值,可以直接向ctx上面挂载属性,如ctx.a = 1,在另一个中间件中使用ctx.a获取
   app.listen(3000) // 监听3000端口
3. 洋葱模型,next()就是分界线
4. 中间件的调用都会返回promise,在每个next()方法前面加上await保证执行顺序是洋葱模型
5. koa-router
    const router = new Router()
    router.get('/', (ctx, next) => { code })
    app.use(router.routes())
    router.post('/v1/:id/books', (ctx, next) => {
      const path = ctx.params // 获取url上的参数id
      const query = ctx.request.query // 获取查询参数?后面的
      const headers = ctx.request.header // 获取请求头的内容
      app.use(parser()) // koa-bodyparser中间件
      const body = ctx.request.body // 获取http请求的body内容
    })
6. 在ctx中可以获取到很多: ctx.path、ctx.method等
7. ctx.body = { key: 'book' } // 在浏览器中显示的是json对象
8. 可以使用nodemon app.js来自动重启服务 // npm install nodemon
9. 通过requireDirectory实现路由自动加载
10. try/catch不能捕获到异步代码的异常,需要使用async和await来捕获异常
11. 在异步调用中必须使用async和await来同步代码
12. 浏览器中或API中返回NO Found是因为API没有返回结果
```

# nginx

```js
// 配置文件
user chenjie owner; // 权限(403)添加当前登录用户为owner
include /Users/chenjie/upload/upload.conf; // 相当于import '/Users/chenjie/upload/upload.conf'这个文件
server
{
  charset utf-8; // 字符
  listen 8089; // 监听的端口
  server_name http_host; // 域名名称
  root /Users/chenjie/upload/; // 访问的根路径
  autoindex on;
  add_header Cache-Control "no-cache, must-revalidate"; // 添加请求头
  location / {  // url路径
    add_header Access-Control-Allow-Origin *; // 跨域
  }
}
1. 当客户端向 Nginx 服务器发送请求时,Nginx首先会根据 IP地址和端口（listen 属性） 对server服务器进行配置
   如果IP地址匹配不成功,会对 域名（server_name属性） 进行匹配；如果域名也匹配不成功,则会默认匹配第一个server服务器
   因此,当只有一个Nginx服务器时,客户端的请任何情况下都会匹配到这个服务器上
2. 如果listen有ip和端口,那么server_name则不起作用
----------------------------------------------------------------------------------------------
// nginx命令
1. nginx // 启动nginx服务
2. nginx -s reload // 重启nginx服务
3. nginx -s stop // 停止nginx服务
4. nginx -t // 检查配置文件是否存在语法错误
----------------------------------------------------------------------------------------------
// 部署
1. 前端代码打包完成后可以直接把打包好的dist下的文件全部拖到云服务器中的nginx中即可
2. node代码如果是跟前端代码部署在同一台服务器上就可以直接通过pm2(node应用进程管理器)启动即可
   相当于在本地访问node服务
3. 如果不在同一台服务器上或者node代码还要提供给别的项目进行使用则需要使用nginx进行反向代理或者
   修改云服务器的开放端口实现
4. node代码中的监听端口只是监听服务器上的,而nginx上监听的80端口则是提供对外域名服务的
5. 反向代理方式是指代理服务器来接收Internet上的连接请求,然后将请求转发给内部网络上的服务器
   并将服务器上得到的结果返回给Internet上请求连接的客户端,此时代理服务器对外就表现为一个服务器
```
