---
title: 进阶知识
date: 2020-07-18
---

``` js
// dev和pro区分打包
1. 两个配置环境不同,则需要两个配置文件,对于相同的配置可以提取到一个公用的配置文件中,最后通过webpack-merge合并导出
2. npm install webpack-merge -D
    const merge = require('webpack-merge')
    const devConfig/proConfig = { '配置内容' }
    module.export = merge(commonConfig, devConfig/proConfig)
    在package.json的scripts中配置:
    "dev": "webpack-dev-server --config ./build/webpack.dev.js"
3. 环境变量
   module.export env => {
      if (env && env.production) {
        return merge(commonConfig, proConfig)
      } else {
        return merge(commonConfig, devConfig)
      }
   }
   在package.json文件的script中
    "build": "webpack --env.production --config ./webpack.common.js"
    通过命令传入参数判断使用哪个环境进行打包
----------------------------------------------------------------------------------------------
// code splitting代码分割
1. 浏览器加载两个1mb文件比加载一个2mb文件快
2. 所以有必要把逻辑代码和工具库代码进行拆分
3. 同步引入代码要做配置
4. 异步代码(import)不用配置
5. module.export = {
    optimization: {
      splitChunks: {
        chunks: 'all', // 同步、异步、全部
        minsize: 30000, // 小于30kb
        michunks: 2, // 最少使用2次(频率)
        maxAsyncRequests: 5, // 最多分割5个
        maxInitialRequests: 3, // 首页最多分割3个
        autoMaticNameDelimite: '~', // 连接符
        name: true,
        cacheGroups: { // chunks: 'all'会走到组里面来
          vendrs: {
            test: /[\\/]node_modules[\\/]/, // 只有在node_modules里面的内容才走这个配置
            priority: -10, // 优先级,哪个大就先打包哪个
            filename: 'rendors.js',
            default: { // 如果没有在node_modules里面的内容就会走default的配置
              priority: -20, // 优先级,哪个大就先打包哪个
              reuseExistingChunk: true, // 如果之前有缓存就使用之前的打包缓存
              filename: 'common.js'
            }
          }
        }
      }
    }
   }
----------------------------------------------------------------------------------------------
// css文件代码分割
1. 在output下的filename只有入口文件会走这个配置
2. 在output下的chunkFileName是入口文件中的代码去引入别个文件时会走这个配置
3. 通过MiniCssExtractPlugin把css文件进行分割,只支持生产环境,因为不支持热模块替换(HMR)
4. 通过optimizeCssAssetsPlugin把分割的css代码压缩合并
----------------------------------------------------------------------------------------------
// 懒加载
1. es6的import请求
2. 提高利用率,交互写在异步组件中,当主要逻辑加载完,在空闲时加载异步组件:
    document.addEventListener('click', () => {
      import(/* webpackPrefetch: true */ './click.js').then(() => {
        func()
      })
    })
----------------------------------------------------------------------------------------------
// chunk
1. 每一个打包后的js文件就是一个chunk
----------------------------------------------------------------------------------------------
// caching浏览器缓存
1. 当文件内容变了,哈希值就会变,就会去加载否则不会重新加载
2. module.export = {
      output: {
        filename: '[name].[contenthash].js',
        chunkFileName: '[name].[contenthash].js'
      }
   }
----------------------------------------------------------------------------------------------
// shimming垫片,自动载入库
1. module.export = {
      plugins: [
        new webpack.providePlugin({
          $: 'jQuery' // 用了$就会自动引入jQuery
        })
      ]
   }
----------------------------------------------------------------------------------------------
// library封装库发布到npm上的配置
1. module.export = {
      output: {
        librayTarget: 'umd/this/window/...', // 别人使用时可以用import/require等方式引入
        library: 'root', // 把方法挂载到root上去
        externals: ['lodash'] // 忽略lodash打包
      }
   }
----------------------------------------------------------------------------------------------
// PWA
1. 利用缓存即使服务器挂了也能展示出页面
2. const workboxWebpackPlugin = require('workbox-webpack-plugin')
   module.export = {
     plugins: [
       new workboxWebpackPlugin.Generatesw({
         clientsClaim: true,
         skipwaiting: true
       })
     ]
   }
----------------------------------------------------------------------------------------------
// typescript
1. npm install ts-loader
   module.export = {
     module: {
       rules: [
         {
           test: /\.tsx?$/,
           use: 'ts-loader',
           exclude: /node_modules/
         }
       ]
     }
   }
----------------------------------------------------------------------------------------------
// proxy代理转发
1. module.export = {
      devServer: {
        proxy: {
          '/vue/api': {
            target: 'https://webchenjie.cn', // 转发到哪个地址
            secure: false, // 对https生效
            changeOrigin: true, // 针对爬虫,对origin支持
            headers: { // 请求头
              host: '192.168.100.20'
            },
            pathRewrite: { // 路径重写,针对开发环境,上线需要后端配合跳转
              a.json: b.json
            }
          }
        },
        historyApiFallback: true // 解决单页应用路由问题
      }
   }
----------------------------------------------------------------------------------------------
// ESlint,代码检测,会生成.eslintrc文件,会降低打包速度,也可使用eslintcr文件的配置进行检测
1. npm install eslint -D
   npm install selint-loader -D
   module.export = {
     devServer: {
       overlay: true // 当发现代码检测不通过时会在浏览器里弹框提示
     },
     moudle: {
       rules: [
         {
           test: /\.js$/,
           exclude: /node_modules/,
           use: ['babel-loader', 'eslint-loader']
         }
       ]
     }
   }
----------------------------------------------------------------------------------------------
// webpack性能优化
1. 打包工具(node、npm、yarn)版本尽量最新
2. 在尽可能少的模块上应用loader,loader范围小一点
3. plugin尽可能精简并准确可靠
4. resolve参数合理配置(用于引入文件时不用加后缀等)
    module.export = {
      resolve: {
        extensions: ['.js', '.jsx'], // 以js、jsx结尾的文件
        mainFiles: ['index', 'child'], // 以index、child开头的文件,引入文件时默认是index文件
        alias: {
          child: path.resolve(__dirname, '../src/a/b') // 重定向,别名
        }
      }
    }
5. 使用DllPlugin提高打包速度,针对于不变的模块单独打包到另一个文件夹中,下次打包时不用重新打包,而是直接拿来用
    新建webpack.dll.js文件
    module.export = {
      plugins: [
        new webpack.DllPlugin({
          name: '[name]'
        })
      ],
      path: path.resolve(__dirname, '../dll/[name].manifest.json')
    }
    在webpack.js中配置使用webpacck.DllReferencePlugin把映射文件引入
    在webpack.js中使用AddAssetHtmlWebpackPlugin把在dll文件夹下的js挂载到html上
6. 控制包文件的大小
7. thread-loader、parallel-webpack、happypack多进程打包
8. 合理使用sourceMap
9. 结合stats分析打包结果
10. 开发环境内存编译
11. 开发环境无用插件剔除
----------------------------------------------------------------------------------------------
// 多页面打包配置
1. 在配置文件中写多个HtmlWebpackPlugin和增加多个entry入口
----------------------------------------------------------------------------------------------
// 其他
1. loader自己编写是一个函数,单独一个文件
2. plugin自己编写是一个类,单独一个文件,所以使用时需要引入并且new
```