---
title: 进阶知识
date: 2020-07-18
---

```js
// dev和pro区分打包
1. 两个配置环境不同,则需要两个配置文件,对于相同的配置可以提取到一个公用的配置文件中,最后通过webpack-merge合并导出
2. npm install webpack-merge -D
    const merge = require('webpack-merge')
    const devConfig/proConfig = { '配置内容' }
    module.export = merge(commonConfig, devConfig/proConfig)
    在package.json的scripts中配置:
    "dev": "webpack-dev-server --config ./build/webpack.dev.js"
3. 环境变量
   module.export env => {
      if (env && env.production) {
        return merge(commonConfig, proConfig)
      } else {
        return merge(commonConfig, devConfig)
      }
   }
   在package.json文件的script中
    "build": "webpack --env.production --config ./webpack.common.js"
    通过命令传入参数判断使用哪个环境进行打包
----------------------------------------------------------------------------------------------
// code splitting代码分割
1. 浏览器加载两个1mb文件比加载一个2mb文件快
2. 所以有必要把逻辑代码和工具库代码进行拆分 // 多个文件引入同一个库只会加载一次
3. 同步引入代码要做配置
4. 异步代码(import)不用配置
5. module.export = {
    optimization: {
      splitChunks: {
        chunks: 'all', // initial同步引入的、async异步引入的、all全部不管同步异步
        minsize: 30000, // 小于30kb不分隔
        michunks: 2, // 最少使用2次(频率)才会分隔
        maxAsyncRequests: 5, // 最多分割5个
        maxInitialRequests: 3, // 首页最多分割3个
        autoMaticNameDelimite: '~', // 连接符
        name: true,
        // 缓存分组
        cacheGroups: { // chunks: 'all'会走到组里面来
        // 第三方模块
          vendrs: {
            name: 'vendor', // chunk名称
            test: /[\\/]node_modules[\\/]/, // 只有在node_modules里面的内容才走这个配置
            priority: -10, // 优先级,哪个大就先打包哪个,如现在是-10而common是1则优先抽离common
            filename: 'rendors.js',
            minSize: 0, // 大小限制
            michunks: 2, // 最少使用2次(频率)才会分隔
            default: { // 如果没有在node_modules里面的内容就会走default的配置
              priority: -20, // 优先级,哪个大就先打包哪个
              reuseExistingChunk: true, // 如果之前有缓存就使用之前的打包缓存
              filename: 'common.js'
            }
          },
          // 公共的模块
          common: {
            name: 'common', // chunk名称
            priority: 1 // 优先级,哪个大就先打包哪个,如现在是1而vendrs是-10则优先抽离common
          }
        }
      }
    }
   }
----------------------------------------------------------------------------------------------
// css文件代码分割
1. 在output下的filename只有入口文件会走这个配置
2. 在output下的chunkFileName是入口文件中的代码去引入别个文件时会走这个配置
3. 通过MiniCssExtractPlugin把css文件进行分割,只支持生产环境,因为不支持热模块替换(HMR)
4. 通过optimizeCssAssetsPlugin把分割的css代码压缩合并
5. 在dev环境中使用:
    module.export = {
      mode: 'development',
      module: {
        rules: [{
          test: /\.css$/,
          use: {
            loader: ['style-loader', 'css-loader', 'postcss-loader'] // 开发环境下会把css直接挂载到style下面
          }
        }]
      }
    }
5. 在pro环境中使用:
    module.export = {
      mode: 'production',
      module: {
        rules: [{
          test: /\.css$/,
          use: {
            loader: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'] // 这里不用style-loader,会通过Link标签引入
          }
        }]
      },
      plugins: [
        new MiniCssExtractPlugin({
          filename: 'css/main.[contentHash:8].css' // 抽离css文件
        })
      ],
      optimization: {
        minimizer: [new TerserJSPlugin({}), new OptimizeCssAssetsPlugin({})] // 压缩css
      }
    }
----------------------------------------------------------------------------------------------
// 懒加载
1. es6的import请求
2. 提高利用率,交互写在异步组件中,当主要逻辑加载完,在空闲时加载异步组件:
    document.addEventListener('click', () => {
      import(/* webpackPrefetch: true */ './click.js').then(() => {
        func()
      })
    })
3. 引入动态数据,懒加载
    setTimeout(() => {
      import('./dynamic-data.js').then(res => {
        console.log(res)
      })
    }, 1500)
----------------------------------------------------------------------------------------------
// module、chunk、bundle的区别
1. module: 相当于是各个还没有进行打包的源码文件,在webpack中一切都是模块
2. chunk: 在打包后可能只有一个模块也可能是多模块合并成的文件
3. bundle: chunk最终的输出文件,可能一个也可能多个
----------------------------------------------------------------------------------------------
// caching浏览器缓存
1. 当文件内容变了,哈希值就会变,就会去加载否则不会重新加载
2. module.export = {
      output: {
        filename: '[name].[contenthash].js',
        chunkFileName: '[name].[contenthash].js'
      }
   }
----------------------------------------------------------------------------------------------
// shimming垫片,自动载入库
1. module.export = {
      plugins: [
        new webpack.providePlugin({
          $: 'jQuery' // 用了$就会自动引入jQuery
        })
      ]
   }
----------------------------------------------------------------------------------------------
// library封装库发布到npm上的配置
1. module.export = {
      output: {
        librayTarget: 'umd/this/window/...', // 别人使用时可以用import/require等方式引入
        library: 'root', // 把方法挂载到root上去
        externals: ['lodash'] // 忽略lodash打包
      }
   }
----------------------------------------------------------------------------------------------
// PWA
1. 利用缓存即使服务器挂了也能展示出页面
2. const workboxWebpackPlugin = require('workbox-webpack-plugin')
   module.export = {
     plugins: [
       new workboxWebpackPlugin.Generatesw({
         clientsClaim: true,
         skipwaiting: true
       })
     ]
   }
----------------------------------------------------------------------------------------------
// typescript
1. npm install ts-loader
   module.export = {
     module: {
       rules: [
         {
           test: /\.tsx?$/,
           use: 'ts-loader',
           exclude: /node_modules/
         }
       ]
     }
   }
----------------------------------------------------------------------------------------------
// proxy代理转发
1. module.export = {
      devServer: {
        proxy: {
          '/vue/api': {
            target: 'https://webchenjie.cn', // 转发到哪个地址
            secure: false, // 对https生效
            changeOrigin: true, // 针对爬虫,对origin支持
            headers: { // 请求头
              host: '192.168.100.20'
            },
            pathRewrite: { // 路径重写,针对开发环境,上线需要后端配合跳转
              a.json: b.json
            }
          }
        },
        historyApiFallback: true // 解决单页应用路由问题
      }
   }
----------------------------------------------------------------------------------------------
// ESlint,代码检测,会生成.eslintrc文件,会降低打包速度,也可使用eslintcr文件的配置进行检测
1. npm install eslint -D
   npm install selint-loader -D
   module.export = {
     devServer: {
       overlay: true // 当发现代码检测不通过时会在浏览器里弹框提示
     },
     moudle: {
       rules: [
         {
           test: /\.js$/,
           exclude: /node_modules/,
           use: ['babel-loader', 'eslint-loader']
         }
       ]
     }
   }
----------------------------------------------------------------------------------------------
// webpack性能优化1
1. 打包工具(node、npm、yarn)版本尽量最新
2. 在尽可能少的模块上应用loader,loader范围小一点
3. plugin尽可能精简并准确可靠
4. resolve参数合理配置(用于引入文件时不用加后缀等)
    module.export = {
      resolve: {
        extensions: ['.js', '.jsx'], // 以js、jsx结尾的文件
        mainFiles: ['index', 'child'], // 以index、child开头的文件,引入文件时默认是index文件
        alias: {
          child: path.resolve(__dirname, '../src/a/b') // 重定向,别名
        }
      }
    }
5. 使用DllPlugin提高打包速度,针对于不变的模块单独打包到另一个文件夹中,下次打包时不用重新打包,而是直接拿来用
    新建webpack.dll.js文件
    module.export = {
      plugins: [
        new webpack.DllPlugin({
          name: '[name]'
        })
      ],
      path: path.resolve(__dirname, '../dll/[name].manifest.json')
    }
    在webpack.js中配置使用webpacck.DllReferencePlugin把映射文件引入
    在webpack.js中使用AddAssetHtmlWebpackPlugin把在dll文件夹下的js挂载到html上
6. 控制包文件的大小
7. thread-loader、parallel-webpack、happypack多进程打包
8. 合理使用sourceMap
9. 结合stats分析打包结果
10. 开发环境内存编译
11. 开发环境无用插件剔除
----------------------------------------------------------------------------------------------
// webpack性能优化2
1. 优化打包构建速度 // 开发体验和效率
    优化babel-loader
    IgnorePlugin // 避免引入无用模块
    noPass // 不去打包哪些
    happyPack // 多进程打包工具
    ParallelUglifyPlugin // 多进程压缩工具
    自动刷新
    热更新
    DllPlugin // 针对于不变的模块单独打包到另一个文件夹中,下次打包时不用重新打包,而是直接拿来用
2. 优化产出代码 // 产品性能
----------------------------------------------------------------------------------------------
// webpack性能优化2之优化打包构建速度
1. 优化babel-loader
    module.export = {
     moudle: {
       rules: [
         {
           test: /\.js$/,
           exclude: /node_modules/, // 明确范围include,排除范围exclude,二选一即可
           use: ['babel-loader?cacheDirectoty'] // ?cacheDirectoty开启缓存
         }
       ]
     }
   }
2. IgnorePlugin // 避免引入无用模块
    module.export = {
    plugins: [
      // moment是npm安装的一个日期库,支持多个国家语言
      // 忽略 moment 下的 /locale目录
      new webpack.IgnorePlugin(/\.\/locale/, /moment/)
    ]
   }
   这样配置会导致moment不会引入,即使你写了import
   import moment from 'moment' // 初始引入,会把全部支持的国家语言都引入
   import 'moment/locale/zh-cn' // 在上面通过ignoreplugin忽略后,手动引入需要的使用的语言包
3. noPass // 避免重复打包
    module.export = {
      module: {
        // 遇到vue.min.js文件就不需要进行打包,一般min文件都是处理过的
        noPass: [/vue\.min\.js$/]
      }
   }
4. IgnorePlugin和noPass的区别
    IgnorePlugin: 直接不引入,代码中没有
    noPass: 引入模块,但不进行打包
----------------------------------------------------------------------------------------------
// 多页面打包配置
1. 在配置文件中写多个HtmlWebpackPlugin和增加多个entry入口
----------------------------------------------------------------------------------------------
// 其他
1. loader自己编写是一个函数,单独一个文件
2. plugin自己编写是一个类,单独一个文件,所以使用时需要引入并且new
3. 开发环境可以不合并、分析、压缩、拆分,会提高构建速度
```
