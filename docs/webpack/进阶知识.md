---
title: 进阶知识
date: 2020-07-18
---

``` js
// dev和pro区分打包
1. 两个配置环境不同,则需要两个配置文件,对于相同的配置可以提取到一个公用的配置文件中,最后通过webpack-merge合并导出
2. npm install webpack-merge -D
    const merge = require('webpack-merge')
    const devConfig/proConfig = { '配置内容' }
    module.export = merge(commonConfig, devConfig/proConfig)
    在package.json的scripts中配置:
    "dev": "webpack-dev-server --config ./build/webpack.dev.js"
----------------------------------------------------------------------------------------------
// code splitting代码分割
1. 浏览器加载两个1mb文件比加载一个2mb文件快
2. 所以有必要把逻辑代码和工具库代码进行拆分
3. 同步引入代码要做配置
4. 异步代码(import)不用配置
5. module.export = {
    optimization: {
      splitChunks: {
        chunks: 'all', // 同步、异步、全部
        minsize: 30000, // 小于30kb
        michunks: 2, // 最少使用2次(频率)
        maxAsyncRequests: 5, // 最多分割5个
        maxInitialRequests: 3, // 首页最多分割3个
        autoMaticNameDelimite: '~', // 连接符
        name: true,
        cacheGroups: { // chunks: 'all'会走到组里面来
          vendrs: {
            test: /[\\/]node_modules[\\/]/, // 只有在node_modules里面的内容才走这个配置
            priority: -10, // 优先级,哪个大就先打包哪个
            filename: 'rendors.js',
            default: { // 如果没有在node_modules里面的内容就会走default的配置
              priority: -20, // 优先级,哪个大就先打包哪个
              reuseExistingChunk: true, // 如果之前有缓存就使用之前的打包缓存
              filename: 'common.js'
            }
          }
        }
      }
    }
   }
----------------------------------------------------------------------------------------------
// css文件代码分割
1. 在output下的filename只有入口文件会走这个配置
2. 在output下的chunkFileName是入口文件中的代码去引入别个文件时会走这个配置
3. 只支持生成环境,因为不支持热模块替换(HMR)
4. 通过MiniCssExtractPlugin把css文件进行分割
5. 通过optimizeCssAssetsPlugin把分割的css代码压缩合并
----------------------------------------------------------------------------------------------
// 懒加载
1. es6的import请求
2. 提高利用率,交互写在异步组件中,当主要逻辑加载完,在空闲时加载异步组件:
    document.addEventListener('click', () => {
      import(/* webpackPrefetch: true */ './click.js').then(() => {
        func()
      })
    })
----------------------------------------------------------------------------------------------
// chunk
1. 每一个打包后的js文件就是一个chunk
----------------------------------------------------------------------------------------------
// caching浏览器缓存
1. 当文件内容变了,哈希值就会变,就会去加载否则不会重新加载
2. module.export = {
      output: {
        filename: '[name].[contenthash].js',
        chunkFileName: '[name].[contenthash].js'
      }
   }
----------------------------------------------------------------------------------------------
// shimming垫片,自动载入库
1. module.export = {
      plugins: [
        new webpack.providePlugin({
          $: 'jQuery' // 用了$就会自动引入jQuery
        })
      ]
   }
----------------------------------------------------------------------------------------------
// library封装库发布到npm上的配置
1. module.export = {
      output: {
        librayTarget: 'umd/this/window/...', // 别人使用时可以用import/require等方式引入
        library: 'root', // 把方法挂载到root上去
        externals: ['lodash'] // 忽略lodash打包
      }
   }
```