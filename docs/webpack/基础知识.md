---
title: 基础知识
date: 2020-07-18
---

```js
// 什么是webpack
1. webpack是一个模块打包工具
2. npm init 文件名 // 在文件中生成package.json文件
3. npm webpack index.js // 使用全局的webpack对index.js进行打包
4. npx webpack index.js // 使用当前项目的webpack对index.js进行打包
5. npm webpack --config 文件名 // 以这个文件为配置文件进行打包
6. webpack.config.js是webpack的配置文件
7. 基础的配置参数
    module.export = {
      mode: 'production'(压缩代码)/'development'(不压缩代码)
      entry: './src/index.js', // 需要打包的文件
      output: {
        filename: '打包后的文件名',
        path: '打包后的文件存放路径'
      },
      module: {
        rules: [{
          test: /\.jpg$/,
          use: {
            loader: 'file-loader'
          }
        }]
      }
    }
----------------------------------------------------------------------------------------------
// 什么是loader
1. loader是打包方案,打包非js结尾后缀的文件,针对不同文件类型进行打包
2. loader的执行规则是从右往左,从下往上,使用多个loader时配置use要用数组而不是对象
3. file-loader // 可处理图片、txt、icon文件
4. style-loader + css-loader // 把样式挂载到html + 合并css
5. sass-loader // 可处理sass文件
6. postcss-loader + autoprefixer // 添加厂商前缀
----------------------------------------------------------------------------------------------
// 什么是plugins
1. plugins相当于插件,是在运行到某个时刻执行某些事情
2. HtmlWebpackPlugin在打包结束后自动生成一个html文件,并把打包后的js自动引入到这个html中
   const htmlwebpackplugin = require('html-webpack-plugin')
   module.export = {
    plugins: [
      new HtmlWebpackPlugin({
        template: 'src/index.html', // 模板,使得新生成的html文件跟模板文件内容一样
        filename: 'index.html',
        chunks: ['index', 'vendor', 'common'] // 在生成index.html后会把code splitting代码分割后所对应的name文件引入
      })
    ]
   }
3. Clean自动清空某个文件夹下的东西
   const CleanWebpackPlugin = require('clean-webpack-plugin')
   module.export = {
    plugins: [
      new CleanWebpackPlugin(['dist'])
    ]
   }
----------------------------------------------------------------------------------------------
// entry需要打包的文件,打包2次,一个main,一个sub,output也要改
1. module.export = {
    entry: {
      main: './src/index.js',
      sub: './src/index1.js'
    }
  }
----------------------------------------------------------------------------------------------
// 打包后的输出
1. module.export = {
    output: {
      publicpath: 'webchenjie.cn', // 在新生成的html文件引入的js文件路径前面加上webchenjie.cn
      filename: '[name].[contentHash:8].js', // 打包后的文件名字,[name]是占位符
      path: path.resolve(__dirname, 'dist')
    }
  }
----------------------------------------------------------------------------------------------
// devtool,映射(sourceMap),当代码写错时,在控制台查看源代码或打包后的代码提示第几行错误
1. 在生产环境中:
    module.export = {
      mode: 'production',
      devtool: 'cheap-module-source-map'
    }
2. 在开发环境中:
    module.export = {
      mode: 'development',
      devtool: 'cheap-module-eval-source-map'
    }
3. devtool的值:
    inline // 不生成map文件,没在dist目录,以base64格式存储
    cheap // 精确到行,不到列,只管打包的业务代码
    module // 精确到行,不到列,包括loader或第三方模块
    eval // 最快,打包关联性多的文件,不推荐,也不会生成map文件
----------------------------------------------------------------------------------------------
// 监听文件变化自动打包
1. webpackDevServer不会生成dist目录而放在内存
    在package.json中的script添加命令
    "dev": "webpack-dev-server" // npm run dev,可自动打包,起了个服务器,自动刷新页面
    module.export = {
      devServer: {
        contentBase: './dist', // 在这个路径下起服务器
        open: true, // 打包完自动开打页面
        port: 8080, // 端口号
        proxy: {} // 代理
      }
    }
2. 在package.json中的script添加命令
    "watch": "webpack --watch" // npm run watch,可自动打包,当文件发生变化时
3. 通过express和webpack-dev-middleware自己写服务器
----------------------------------------------------------------------------------------------
// 热模块替换(HMR)
1. 当css或js模块发生变化时,不会影响到页面,会自己更新 // css的热更新webpak已集成,js需要自己写module.hot
2. const webpack = require('webpack')
    module.export = {
      devServer: {
        hot: true, // 开启热模块替换功能
        hotOnly: true // 当hot不生效时,页面也不会刷新
      }
      plugins: [
        new webpack.HotModuleReplacementPlugin()
      ]
    }
3. 配置了2的参数只是开启了css的热模块替换功能
4. 如果要让js模块也开启热模块替换功能需要:
    if(module.hot) {
      module.hot.accept('模块', () => { code })
    }
----------------------------------------------------------------------------------------------
// Babel
1. Babel用来处理es6语法
2. npm install babel-loader @babel/code -D // 打通webpack和babel
   npm install @babel/preset-env -D // 翻译语法
   npm install @babel/polyfill -D // 翻译方法
    module.export = {
      module: {
        rules: [
          {
            test: /\.js$/,
            exclude: /node_module/, // 这里面的文件不用转换
            loader: 'babel-loader'，
            options: { // 或新建.babelrc文件在里面配置
              presets: [
                [
                  '@babel/preset-env',
                  {
                    useBuiltIns: 'usage' // 有用的方法才配置,默认全部
                  }
                ]
              ]
            }
          }
        ]
      }
    }
----------------------------------------------------------------------------------------------
// Tree Shaking
1. 当引入模块时,不引入模块所有代码,可以通过Tree Shaking按需引入,默认是全部引入,只支持es module模式
2. 在生产环境中:
    mode: 'production'
    在package.json中配置:
    "sideEffects": false, // 对所有文件开启
    "sideEffects": ["*.css"] // 不对css文件开启
3. 在开发环境中:
    module.export = {
      mode: 'development',
      optimization: {
        usedExports: true
      }
    }
```
