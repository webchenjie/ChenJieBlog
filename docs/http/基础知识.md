---
title: 基础知识
date: 2020-07-11
---

```js
// 5层网络模型
1. 物理层: 电脑设备(硬件)
2. 数据链路层: 在通信的实体间建立数据链路连接(0101)
3. 网络层: 为数据在结点之间传输创建逻辑链路(百度应对www.baidu.com)
4. 传输层: Tcp/ip协议(端到端服务,如与百度服务器传输数据),Tcp connection连接
5. 应用层: Http
----------------------------------------------------------------------------------------------
// url的各个部分
1. http://www.baidu.com:80/path?search#hash
2. http // 协议
3. www.baidu.com // 主机名
4. baidu.com // 主域名
5. 80 // 端口号(http默认80,https默认443)
6. path // 路径
7. search // 查询字符串
8. hash // 锚点
----------------------------------------------------------------------------------------------
// 输入url到拿到数据的过程
1. 跳转
2. 查看应用缓存
3. DNS查找
4. 创建TCP连接
5. 发送请求
6. 接收响应
----------------------------------------------------------------------------------------------
// methods
1. GET // 获取
2. POST // 新建
3. PATCH/PUT // 更新
4. DELETEE // 删除
----------------------------------------------------------------------------------------------
// 状态码
1. 1xx: 服务器收到请求
2. 2xx: 表示成功处理请求,如200
3. 3xx: 需要重定向,浏览器直接跳转,301表示永久重定向,302表示临时重定向,304表示资源未改变(缓存)
4. 4xx: 客户端请求错误,404表示资源找不到,403表示没有权限
5. 5xx: 服务器端错误,504表示网关超时,500表示服务器错误
----------------------------------------------------------------------------------------------
// Restful-API
1. 传统的API设计: 把每个url当做一个功能
2. Restful-API设计: 把每个url当做一个唯一的资源
3. 如何设计成一个资源？
      尽量不用url参数
         传统API: /api/list?id=2
         Restful-API: /api/list/2
      用method表示操作类型
         传统API: 
               post请求 /api/create-blog // 创建
               post请求 /api/update-blog?id=2 // 更新
               get请求 /api/get-blog?id=2 // 获取
         Restful-API:
               post请求 /api/blog
               patch请求 /api/blog/100
               get请求 /api/blog/100
----------------------------------------------------------------------------------------------
// tcp连接
1. 一个tcp连接对应多个http请求,http基于tcp/ip
2. 创建一个tcp连接需要经过三次握手,解决网络传输中的问题
3. tcp连接在同域下最多6个,在http1.1中http请求在tcp连接中是有先后顺序的,在http2.0可以并发
4. 在请求头connection: keep-alive/close,可以保持长连接,在请求时可复用tcp连接,也可以设置连接保持多长时间
----------------------------------------------------------------------------------------------
// 强制缓存cache-control
1. 服务器设置cache-control: max-age = 3153600(单位是s)
2. cache-control的值:
   max-age // 过期时间
   no-cache // 不用强制缓存,到服务器请求
   no-store // 不用缓存,也不用服务端的缓存措施(协商缓存)
   private // 只允许最终用户做缓存
   public // 也允许中间代理做缓存
----------------------------------------------------------------------------------------------
// 协商缓存
1. 服务器缓存策略
2. 服务器判断客户端资源,是否和服务器端资源一样
3. 一致则返回304,否则返回200和最新的资源
4. 浏览器请求服务器时第一次请求会返回资源和资源标识,再次请求会带上资源标识,由服务器判断返回304或返回新的资源和新的资源标识
----------------------------------------------------------------------------------------------
// 资源标识
1. Last-Modified资源的最后修改时间只能精确到秒
2. Etag资源的唯一标识(一个字符串,类似人类指纹)
3. 1和2可以共存不互斥,会优先使用Etag
4. 服务器返回的last-modifed和浏览器带上的if-modified-since的值是一样的
5. 服务器返回的Etag和浏览器带上的if-none-match的值是一样的
----------------------------------------------------------------------------------------------
// 刷新页面的操作
1. 正常输入url地址: 强制缓存有效,协商缓存有效
2. 手动刷新F5: 强制缓存失效,协商缓存有效
3. 强制刷新ctrl+F5: 强制缓存失效,协商缓存失效
----------------------------------------------------------------------------------------------
// 数据协商
1. q为权重,q=0.8 > q=0.9
2. 请求头:
   Accept: '想要的数据类型'
   Accept-Encoding: '编码方式,数据压缩'
   Accept-Language: '语言'
   User-Agent: '浏览器的信息'
3. 返回头
   Content-Type: '返回的数据类型'
   Content-Encoding: '哪种压缩方式'
   Content-Language: '返回的语言'
----------------------------------------------------------------------------------------------
// 内容安全策略
1. content-security-policy: default-src、connect-src、img-src、style-scr
2. 限制资源获取
3. 报告资源获取越权
----------------------------------------------------------------------------------------------
// HTTP2的优势
1. 信道复用: 在一个tcp连接上可以有多个http请求,不需要先后顺序
2. 分帧传输: 分成不同的帧发送,并发的发送不同的请求
3. server push: 服务器主动推送
----------------------------------------------------------------------------------------------
// 其他
1. 爬虫是服务器端发出的请求
```