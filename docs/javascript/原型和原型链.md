---
title: 原型和原型链
date: 2020-07-04
---

# 原型和原型链图示

![原型和原型链](https://6368-chenjie-blog-88b4b7-1302547066.tcb.qcloud.la/docs/javascript/原型和原型链/原型和原型链1.png)

# 原型和原型链图示

![原型和原型链](https://6368-chenjie-blog-88b4b7-1302547066.tcb.qcloud.la/docs/javascript/原型和原型链/原型和原型链2.png)

```js
// 面向对象和继承
1. es5
function user(name, pass) {
  this.name = name
  this.pass = pass
}
// 方法放在原型上添加
User.prototype.showName = function() { console.log(this.name) }
User.prototype.showPass = function() { console.log(this.pass) }
// 继承
function vipUser(name, pass, level) {
  user.call(this, name, pass) //继承属性
  this.level = level
}
// 继承方法
方法1: vipUser.prototype = Object.create(user.prototype)
方法2: vipUser.prototype = new user()
      vipUser.prototype.construtor = vipUser
// 自己的方法
vipUser.prototype.showLevel = function() { console.log(this.level) }
----------------------------------------------------------------------------------------------
2. es6
class user {
  constructor(name, pass) {
    this.name = name
    this.pass = pass
    // 方法直接放在内部
    showName() { console.log(this.name) }
    showPass() { console.log(this.pass) }
  }
}
// 继承
class vipUser extends User {
  constructor(name, pass, level) {
    super(name, pass) // 相当于call继承属性,方法自动继承
    this.level = level
    showLevel() { console.log(this,level) }
  }
}
----------------------------------------------------------------------------------------------
// es6
1. 只读属性(保护),要写在construtor的下面
   get 名称() {}
   set 名称() {} //名称是类上的属性而不是方法,名称不是属性名称而是对外访问的出入口
2. 静态方法指的是类方法,构造函数除外
3. 实例方法指的是写在构造函数内的方法
4. es5的实例方法就是在原型上的方法和写在类中的this.方法名
5. 静态方法则是在构造函数外且不是原型上的方法,如类名.方法名
6. es6静态方法是在class中的方法前面加上static,不加则是实例方法
7. 继承extends和super,如果子类没有直接的构造属性,constructor和super可以省,如果有自己的属性则不能省
----------------------------------------------------------------------------------------------
// 其他
1. 插件机制: 相当于给prototype上增加新的函数
2. 扩展机制: 继承
```
