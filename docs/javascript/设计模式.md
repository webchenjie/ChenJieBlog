---
title: 设计模式
date: 2020-10-25
---

```js
// 面向对象三要素
1. 继承：
    子类继承父类
    继承可将公共方法抽离出来，提高复用，减少冗余
2. 封装： // pulic、protected、private
    减少耦合，不该外露的不外露
    利于数据、接口的权限管理
    ES6目前不支持，一般认为_开头的属性时private
3. 多态：
    保持子类的开放性和灵活性
    面向接口编程，JS引用极少，相当于方法重写
----------------------------------------------------------------------------------------------
// 什么是设计
1. 即按照哪一种思路或者标准来实现功能
2. 功能相同，可以有不同设计方案来实现
3. 伴随着需求增加，设计的作用才能体现出来 
----------------------------------------------------------------------------------------------
// 设计准则
1. 小即是美
2. 让每个程序只做好一件事
3. 快速建立原型进而自我更新
4. 舍弃高效率而取可移植性
5. 采用纯文本来存储数据非二进制
6. 充分利用软件的杠杆原理即复用
7. 使用shell脚本来提高杠杆效应和可移植性
8. 避免强制性的用户界面
9. 让每个程序都称为过滤器
----------------------------------------------------------------------------------------------
// 设计小准则
1. 允许用户定制环境
2. 尽量是操作系统内核小而轻量化
3. 使用小写字母并尽量简短
4. 沉默是金
5. 各部分之和大于整体
6. 寻求90%的解决方案
----------------------------------------------------------------------------------------------
// SOLID五大设计原则
1. S —— 单一职责原则
    一个程序只做好一件事
    如果功能过于复杂就拆分开，每个部分保持独立
2. O —— 开放封闭原则
    对扩展开放，对修改封闭
    增加需求时，扩展新代码，而非修改已有代码
    这是软件设计的终极目标
3. L —— 李氏置换原则
    子类能覆盖父类
    父类能出现在的地方子类就能出现
    JS中使用较少 // 弱类型语言
4. I —— 接口独立原则
    保持接口的单一独立，避免出现胖接口
    JS中没有接口 // ts有
    类似于单一职责原则，这里更关注接口
5. D —— 依赖导致原则
    面向接口编程，依赖于抽象而不依赖于具体
    使用方只关注接口而不关注具体类的实现
    JS中使用较少 // 没有接口，弱类型语言
----------------------------------------------------------------------------------------------
// 设计模式简介
1. 创建型
    工厂模式，包括工厂方法模式、抽象工厂模式、建造者模式
    单例模式
    原型模式
2. 结构型
    适配器模式
    装饰器模式
    代理模式
    外观模式
    桥接模式
    组合模式
    享元模式
3. 行为型
    策略模式
    模板方法模式
    观察者模式
    迭代器模式
    职责连模式
    命令模式
    备忘录模式
    状态模式
    访问者模式
    中介者模式
    解释器模式
----------------------------------------------------------------------------------------------
// 工厂模式
1. 将new操作单独封装
2. 遇到new时就要考虑是否该使用工厂模式
3. 使用场景：
    jQuery的 $('div')
    React.createElement
    vue异步组件
class Product {
  constructor(name) {
    this.name = name
  }
  init() {
    console.log('init')
  }
}
class Creator { // 工厂
  create(name) {
    return new Product(name)
  }
}
const creator = new Creator()
const p = creator.create('p1')
p.init()
----------------------------------------------------------------------------------------------
// 单例模式
1. 系统中被唯一使用
2. 一个类只有一个实例
3. 单例模式需要用到 private 特性 // ts
4. 使用场景：
    jQuery只有一个 $ ，不管引入多少个
    if (window.jQuery != null) {
      return window.jQuery
    } else {
      // 初始化
    }
class SingleObject {
  login() {
    console.log('login')
  }
}
SingleObject.getInstance = (function() {
  let instance
  return function() {
    if (!instance) {
      instance = new SingleObject()
    }
    return instance
  }
})()
const obj1 = SingleObject.getInstance()
obj1.login()
const obj2 = SingleObject.getInstance()
obj2.login()
console.log(obj1 === obj2) // true
```
