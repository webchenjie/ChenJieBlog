---
title: 设计模式
date: 2020-10-25
---

```js
// 面向对象三要素
1. 继承：
    子类继承父类
    继承可将公共方法抽离出来，提高复用，减少冗余
2. 封装： // pulic、protected、private
    减少耦合，不该外露的不外露
    利于数据、接口的权限管理
    ES6目前不支持，一般认为_开头的属性时private
3. 多态：
    保持子类的开放性和灵活性
    面向接口编程，JS引用极少，相当于方法重写
----------------------------------------------------------------------------------------------
// 什么是设计
1. 即按照哪一种思路或者标准来实现功能
2. 功能相同，可以有不同设计方案来实现
3. 伴随着需求增加，设计的作用才能体现出来 
----------------------------------------------------------------------------------------------
// 设计准则
1. 小即是美
2. 让每个程序只做好一件事
3. 快速建立原型进而自我更新
4. 舍弃高效率而取可移植性
5. 采用纯文本来存储数据非二进制
6. 充分利用软件的杠杆原理即复用
7. 使用shell脚本来提高杠杆效应和可移植性
8. 避免强制性的用户界面
9. 让每个程序都称为过滤器
----------------------------------------------------------------------------------------------
// 设计小准则
1. 允许用户定制环境
2. 尽量是操作系统内核小而轻量化
3. 使用小写字母并尽量简短
4. 沉默是金
5. 各部分之和大于整体
6. 寻求90%的解决方案
----------------------------------------------------------------------------------------------
// SOLID五大设计原则
1. S —— 单一职责原则
    一个程序只做好一件事
    如果功能过于复杂就拆分开，每个部分保持独立
2. O —— 开放封闭原则
    对扩展开放，对修改封闭
    增加需求时，扩展新代码，而非修改已有代码
    这是软件设计的终极目标
3. L —— 李氏置换原则
    子类能覆盖父类
    父类能出现在的地方子类就能出现
    JS中使用较少 // 弱类型语言
4. I —— 接口独立原则
    保持接口的单一独立，避免出现胖接口
    JS中没有接口 // ts有
    类似于单一职责原则，这里更关注接口
5. D —— 依赖导致原则
    面向接口编程，依赖于抽象而不依赖于具体
    使用方只关注接口而不关注具体类的实现
    JS中使用较少 // 没有接口，弱类型语言
----------------------------------------------------------------------------------------------
// 设计模式简介
1. 创建型
    工厂模式，包括工厂方法模式、抽象工厂模式、建造者模式
    单例模式
    原型模式
2. 结构型
    适配器模式
    装饰器模式
    代理模式
    外观模式
    桥接模式
    组合模式
    享元模式
3. 行为型
    策略模式
    模板方法模式
    观察者模式
    迭代器模式
    职责连模式
    命令模式
    备忘录模式
    状态模式
    访问者模式
    中介者模式
    解释器模式
----------------------------------------------------------------------------------------------
// 工厂模式
1. 将new操作单独封装
2. 遇到new时就要考虑是否该使用工厂模式
3. 使用场景：
    jQuery的 $('div')
    React.createElement
    vue异步组件
4. 示例：
class Product {
  constructor(name) {
    this.name = name
  }
  init() {
    console.log('init')
  }
  run() {
    console.log('run')
  }
}
class Creator { // 工厂
  create(name) {
    return new Product(name)
  }
}
const creator = new Creator()
const p = creator.create('p1')
p.init()
p.run()
----------------------------------------------------------------------------------------------
// 单例模式
1. 系统中被唯一使用
2. 一个类只有一个实例
3. 单例模式需要用到 private 特性 // ts
4. 使用场景：
    jQuery只有一个 $ ，不管引入多少个
    if (window.jQuery != null) {
      return window.jQuery
    } else {
      // 初始化
    }
5. 示例：
class SingleObject {
  login() {
    console.log('login')
  }
}
SingleObject.getInstance = (function() {
  let instance
  return function() {
    if (!instance) {
      instance = new SingleObject()
    }
    return instance
  }
})()
const obj1 = SingleObject.getInstance()
obj1.login()
const obj2 = SingleObject.getInstance()
obj2.login()
console.log(obj1 === obj2) // true
----------------------------------------------------------------------------------------------
// 适配器模式
1. 旧接口格式和使用者不兼容
2. 中间加一个适配转换接口
3. 使用场景：
    封装旧接口
    vue computed
4. 示例：
class Adaptee {
  specificRequest() {
    return '德国标准的插头'
  }
}
class Target {
  constructor() {
    this.adaptee = new Adaptee()
  }
  request() {
    const info = this.adaptee.specificRequest()
    return `${info} -> 转换器 -> 中国标准的插头`
  }
}
const target = new Target()
target.request()
----------------------------------------------------------------------------------------------
// 装饰器模式
1. 为对象添加新功能
2. 不改变其原有的结构和功能
3. 示例1：
class Circle {
  draw() {
    console.log('画一个圆形)
  }
}
class Decorator {
  constructor(circle) {
    this.circle = circle
  }
  draw() {
    this.circle.draw()
    this.setRedBorder(circle)
  }
  setRedBorder(circle) {
    console.log('设置红色边框')
  }
}
const circle = new Circle()
circle.draw()

const dec = new Decorator(circle)
dec.draw()
3. 示例2：装饰类1
// 相当于把类传到函数中去执行
// class Demo {} Demo = testDec(Demo) || Demo
function testDec(target) {
  target.isDec = true
}

@testDec
class Demo {
  init() {
    console.log('init')
  }
}

console.log(Demo.isDec) // true
3. 示例3：装饰类2
function mixins(...list) {
  return function(target) {
    Object.assign(target.prototype, ...list)
  }
}
const Foo = {
  foo() {
    console.log('foo')
  }
}

@mixins(Foo)
class Demo {}
const obj = new Demo()
obj.foo() // foo
3. 示例4：装饰方法
function log(target, name, descriptor) {
  // target 当前的类
  // name 属性名
  // descriptor 属性描述符
  let oldValue = descriptor.value
  descriptor.value = function() {
    console.log(`calling ${name} width`, arguments)
    return oldValue.apply(this, arguments)
  }
  return descriptor
}

class Math {
  @log
  add(a, b) {
    return a + b
  }
}

const math = new Math()
console.log(math.add(2, 4))
4. 可以使用 npm install core-decorators 这个库，提供了常用的装饰器
----------------------------------------------------------------------------------------------
// 代理模式，类似科学上网或明星经纪人
1. 使用者无权访问目标对象
2. 中间加代理，通过代理做授权和控制
3. 使用场景：
    网页事件代理
    jQuery.$proxy
    ES6 proxy
4. 示例：
class ReadImg {
  constructor(fileName) {
    this.fileName = fileName
    this.loadFromDisk()
    display() {
      console.log('display')
    }
    loadForomDisk() {
      console.log('loadForomDisk')
    }
  }
}
class ProxyImg {
  constructor(fileName) {
    this.realImg = new ReadImg(fileName)
  }
  display() {
    this.realImg.display()
  }
}

const proxyImg = new ProxyImg('1.png')
proxyImg.display()
----------------------------------------------------------------------------------------------
// 适配器模式、装饰器模式和代理模式的区别
1. 适配器模式 vs 代理模式
   适配器模式：提供一个不同的接口 // 如不同版本的插头
   代理模式：提供一模一样的接口
2. 装饰器模式 vs 代理模式
   装饰器模式：扩展功能，原有功能不变且可直接使用
   代理模式：显示原有功能，但是经过限制或者阉割之后的
```
