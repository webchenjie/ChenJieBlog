---
title: 作用域和闭包
date: 2020-07-05
---

```js
// 作用域
1. 作用域有全局作用域和局部作用域之分
2. 作用域链是用来查询变量的(由内到外)
3. es6新增的块级作用域
----------------------------------------------------------------------------------------------
// js解析机制(1、2是预解析)
1. 所有var都赋值为undefined,参数当做局部变量处理,函数提前声明
2. 变量与函数冲突则保留函数,函数与函数冲突,保留后面的
3. 逐行解读
4. 旧版本火狐不能对if、for这种代码块中的函数进行预解析,多个script是分开解析的
----------------------------------------------------------------------------------------------
// 内存问题
1. 离开作用域的值被标记为可回收,将在垃圾收集期间被删除
2. 标记清除是目前主流的垃圾收集算法
3. 标记清除就是给不用的值加标记,然后回收其内存
4. 引用计数算法可能因为循环引用的问题而得不到释放
5. 当变量不用的时候,可以手动解除它的引用(赋值为null)
----------------------------------------------------------------------------------------------
// 闭包
1. 函数作为返回值
2. 函数作为参数
3. 函数b在a内嵌套的,函数a需要返回b
4. 可用于读取函数内部变量,让变量保留在内存中
----------------------------------------------------------------------------------------------
// 自由变量
1. 一个变量在当前作用域没有定义,但被使用了
2. 所有自由变量的查找,是在函数定义的地方,向上级作用域查找,不是在执行的地方
----------------------------------------------------------------------------------------------
// this的使用场景
1. 作为普通函数
2. 使用call、apply、bind
3. 作为对象方法被调用
4. 在class方法中调用
5. 箭头函数
----------------------------------------------------------------------------------------------
// 普通函数this指向
1. 总是代表着它的直径调用者,如obj.fn,fn的this就是obj
2. 默认情况下没有直径调用者,this指向window
3. 严格模式下(设置了'use strict'),this为undefined
4. 当使用call、apply、bind绑定的,this指向绑定对象
----------------------------------------------------------------------------------------------
// 箭头函数this指向
1. 继承于父级执行上下文里的this,本身没有this
2. 即使是call、apply、bind方法也不能改变箭头函数的this指向
3. 简单对象(非函数)是没有执行上下文的
----------------------------------------------------------------------------------------------
// this案例演示
1. function hello() { console.log(this) }
hello函数是全局函数没有直接调用它的对象,没有严格模式所以指向window
2. function hello() { 'use strict' console.log(this) }
hello函数是全局函数没有直接调用它的对象,有严格模式所以指向undefined
3. const obj = {
  hello: function() {
    console.log(this) //obj
    setTimeout(function() {
      console.log(this) // window
    }, 1000)
  }
}
hello函数直接调用者是obj,所以第一个this指向obj,setTimeout是匿名函数没有直接调用者,也没有严格模式所以指向window
```
