---
title: HTTP
date: 2020-07-11
---

``` js
// 5层网络模型
1. 物理层: 电脑设备(硬件)
2. 数据链路层: 在通信的实体间建立数据链路连接(0101)
3. 网络层: 为数据在结点之间传输创建逻辑链路(百度应对www.baidu.com)
4. 传输层: Tcp/ip协议(端到端服务,如与百度服务器传输数据),Tcp connection连接
5. 应用层: Http
----------------------------------------------------------------------------------------------
// url的各个部分
1. http://www.baidu.com:80/path?search#hash
2. http // 协议
3. www.baidu.com // 主机名
4. baidu.com // 主域名
5. 80 // 端口号(http默认80,https默认443)
6. path // 路径
7. search // 查询字符串
8. hash // 锚点
----------------------------------------------------------------------------------------------
// 输入url到拿到数据的过程
1. 跳转
2. 查看应用缓存
3. DNS查找
4. 创建TCP连接
5. 发送请求
6. 接收响应
----------------------------------------------------------------------------------------------
// methods
1. GET // 获取
2. POST // 新建
3. PATCH/PUT // 更新
4. DELETEE // 删除
----------------------------------------------------------------------------------------------
// 跨域
1. 跨域只是浏览器拦截掉了,实际发了请求也返回了数据
2. 同源策略: 协议、域名、端口必须一致
3. 允许跨域的方法: GET、POST、HEAD
4. 允许跨域的类型: content-Type: text/plain、multipart/form-data、application/x-www-form-urlencoded
5. 其他方法或类型需要预请求: option
6. 预请求: 第一次发的methods是option,第二次才是实际要发送的methods
----------------------------------------------------------------------------------------------
// JSONP
1. <script>可以绕过同源限制
2. 服务器可以任意动态拼接数据返回
3. <script>就可以获得跨域的数据,只要服务端愿意返回一个函数执行,在html中定义的
4. 通过函数参数获得跨域内容
5. link、img等也可以绕过同源限制
----------------------------------------------------------------------------------------------
// CORS
服务端设置http header: Access-Control-Allow-Headers: '*'
----------------------------------------------------------------------------------------------
// tcp连接
1. 一个tcp连接对应多个http请求,http基于tcp/ip
2. 创建一个tcp连接需要经过三次握手,解决网络传输中的问题
3. tcp连接在同域下最多6个,在http1.1中http请求在tcp连接中是有先后顺序的,在http2.0可以并发
4. 在请求头connection: keep-alive/close,可以保持长连接,在请求时可复用tcp连接,也可以设置连接保持多长时间
----------------------------------------------------------------------------------------------
// 强制缓存cache-control
1. 服务器设置cache-control: max-age = 3153600(单位是s)
2. cache-control的值:
   max-age // 过期时间
   no-cache // 不用强制缓存,到服务器请求
   no-store // 不用缓存,也不用服务端的缓存措施(协商缓存)
   private // 只允许最终用户做缓存
   public // 也允许中间代理做缓存
----------------------------------------------------------------------------------------------
// 协商缓存
1. 服务器缓存策略
2. 服务器判断客户端资源,是否和服务器端资源一样
3. 一致则返回304,否则返回200和最新的资源
4. 浏览器请求服务器时第一次请求会返回资源和资源标识,再次请求会带上资源标识,由服务器判断返回304或返回新的资源和新的资源标识
----------------------------------------------------------------------------------------------
// 资源标识
1. Last-Modified资源的最后修改时间只能精确到秒
2. Etag资源的唯一标识(一个字符串,类似人类指纹)
3. 1和2可以共存不互斥,会优先使用Etag
4. 服务器返回的last-modifed和浏览器带上的if-modified-since的值是一样的
5. 服务器返回的Etag和浏览器带上的if-none-match的值是一样的
----------------------------------------------------------------------------------------------
// 刷新页面的操作
1. 正常输入url地址: 强制缓存有效,协商缓存有效
2. 手动刷新F5: 强制缓存失效,协商缓存有效
3. 强制刷新ctrl+F5: 强制缓存失效,协商缓存失效
----------------------------------------------------------------------------------------------
// 数据协商
1. q为权重,q=0.8 > q=0.9
2. 请求头: 
   Accept: '想要的数据类型'
   Accept-Encoding: '编码方式,数据压缩'
   Accept-Language: '语言'
   User-Agent: '浏览器的信息'
3. 返回头
   Content-Type: '返回的数据类型'
   Content-Encoding: '哪种压缩方式'
   Content-Language: '返回的语言'
----------------------------------------------------------------------------------------------
// 内容安全策略
1. content-security-policy: default-src、connect-src、img-src、style-scr
2. 限制资源获取
3. 报告资源获取越权
----------------------------------------------------------------------------------------------
// HTTP2的优势
1. 信道复用: 在一个tcp连接上可以有多个http请求,不需要先后顺序
2. 分帧传输: 分成不同的帧发送,并发的发送不同的请求
3. server push: 服务器主动推送
----------------------------------------------------------------------------------------------
// 其他
1. 爬虫是服务器端发出的请求
```