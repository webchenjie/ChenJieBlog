---
title: 数据类型
date: 2020-07-04
---

```js
// 简单数据类型(不可改变,只能复制,按值传递)
1. Symbol
2. undefined
3. Boolean
4. Number
5. String
6. 值不可修改
7. 保存在栈内存中
8. 按值访问
9. 比较时值相等即相等
10. 复制时创建一个副本
11. 按值传递参数
12. 用typeof检测类型
----------------------------------------------------------------------------------------------
// 复杂数据类型(引用,可以改变,按引用传递)
1. Object
2. Array
3. Function
4. null
5. 值可以修改
6. 保存在堆内存中
7. 按引用访问
8. 比较时同一引用才相等
9. 复制其实是指针
10. 按值传递参数
11. 用instanceof检测类型
----------------------------------------------------------------------------------------------
// 栈和堆
1. 栈从上往下落,堆从下往上升,一般不会重合(内存)
----------------------------------------------------------------------------------------------
// 深拷贝
1. 判断简单数据类型还是复杂数据类型
2. 判断是数组还是对象
3. 递归
4. function deepClone(obj = {}) {
    if (typeof obj !== 'object' || obj == null) {
      // obj 是 null 或不是对象和数组直接返回
      return obj
    }
    // 初始化返回结果
    let result
    if (obj instanceof Array) {
      result = []
    } else {
      result = {}
    }
    for (let key in obj) {
      // 保证 key 不是原型的属性
      if (obj.hasOwnProperty(key)) {
        // 递归调用
        result[key] = deepClone(obj[key])
      }
    }
    // 返回结果
    return result
}
----------------------------------------------------------------------------------------------
// 深度比较isEqual
function isEqual(obj1, obj2) {
  if (!isObject(obj1) || !isObject(obj2)) {
    // 值类型, 一般不会是函数
    return obj1 === obj2
  }
  if (obj1 === obj2) {
    return true
  }
  // 两个都是对象或数组, 而且不相等
  // 先取出obj1和obj2的keys, 比较个数
  const obj1Keys = Object.keys(obj1)
  const obj2Keys = Object.keys(obj2)
  if (obj1Keys.length !== obj2Keys.length) {
    return false
  }
  // 以obj1为基准和obj2依次递归比较
  for (let key in obj1) {
    const res = isEqual(obj1[key], obj2[key])
  }
}
function isObject(obj) {
  return typeof obj === 'object' && obj !== null
}
----------------------------------------------------------------------------------------------
// 简单数据类型检测,返回值String, Number, Boolean, Object, undefined, function
1. typeOf(1) // 返回Numbner
    能识别所有简单数据类型
    识别函数
    判断是否是引用类型(不可再细分,object)
2. null === Object // true
3. undefined == null // true, undefined是null派生出来的
4. NaN // 非数值
5. NaN !== NaN // true
6. isNaN(参数) // 判断参数是否是非数值,返回Boolean,会尝试把参数转为数字类型如 id = '16'
----------------------------------------------------------------------------------------------
// 复杂数据类型检验,typeof遇到复杂数据类型只会返回object
1. [] instanceof Array // 返回true
----------------------------------------------------------------------------------------------
// 数值转换
1. Number(参数) // 参数要以数字开头, 会忽略开头0和空格,如果转换字符串则返回NaN,有两个参数的第二个为进制
2. parsetInt(参数) // 参数要以数字开头, 会忽略开头0和空格,如果转换字符串则返回NaN,有两个参数的第二个为进制
3. parseFloat(参数) // 参数要以数字开头, 会忽略开头0和空格,如果转换字符串则返回NaN,有两个参数的第二个为进制,第一个小数点有效
----------------------------------------------------------------------------------------------
// 字符串转换
1. String(参数) // 在不知道参数的类型时使用
2. toStirng() // 返回str的一个副本
----------------------------------------------------------------------------------------------
// boolean转换
1. 除0之外的所有数字转换为布尔值都为true
2. 除空之外的所有字符串转换为布尔值都为true
3. null和undefined转换为布尔值为false
4. 比较操作符返回值为boolean
----------------------------------------------------------------------------------------------
// 逻辑与操作符转换
逻辑与(只要有一个条件不成立则返回false)
如果操作数不是布尔值时:
1. 如果第一个操作数隐式类型转换后为true则返回最后一个操作数
2. 如果第一个操作数隐式类型转换后为false则返回第一个操作数
3. 有一个操作数是null则返回null
4. 有一个操作数是undefined则返回undefined
----------------------------------------------------------------------------------------------
// 逻辑或操作符转换
逻辑或(只要有一个条件成立则返回true)
如果操作数不是布尔值时:
1. 如果第一个操作数隐式类型转换后为true则返回第一个操作数
2. 如果第一个操作数隐式类型转换后为false则返回第二个操作数
3. 如果有两个操作数是null则返回null
4. 如果有两个操作数是undefined则返回undefined
5. 如果有两个操作数是NaN则返回NaN
----------------------------------------------------------------------------------------------
// 逻辑非操作符转换
1. 无论操作数是什么数据类型,都会返回一个布尔值
2. !!对该布尔值求反
----------------------------------------------------------------------------------------------
// 可选链
const user = {
  address: {
    street: '街道',
    getNum() {
      return '80号'
    }
  }
}
1. 常规获取
  const street = user && user.address && user.address.street
  const num = user && user.address && user.address.getNum && user.address.getNum()
2. 可选链获取
  const street = user?.address?.street
  const num = user?.address?.getNum?.()
----------------------------------------------------------------------------------------------
// 空值合并运算符
1. 常规
  const b = null
  const a = b || 5 // 当 b 隐式转换是 true 时取 b，否则取 5
2. 空值合并运算符
  const b = null
  const a = b ?? 5 // 只有 b 是 null 或 undefined 时才会取 5，而常规中 b 的值是 0 或空字符或 false 都会取 5
----------------------------------------------------------------------------------------------
// truly和falsely
1. !!变量 === true // truly变量
2. !!变量 === false // falsely变量
3. if里判断就是这两种变量
----------------------------------------------------------------------------------------------
// js错误类型
1. syntaxError // 语法错误
    符号漏打、多大、少打、错打
    使用了不符合语法的变量名
    语句写错,没写完
2. referenceError // 变量引用异常或未定义
3. typeError // 类型使用错误
4. ranggeError // 递归爆栈,深度太深错误
5. 捕获错误
    try {
      code
    } catch(ex) {
      code
    } finally {
      code
    }
6. throw new Error('err') // 抛出错误
7. debugger // 打断点
----------------------------------------------------------------------------------------------
// 其他
1. 在判断是否相等时只有判断是不是 == null 时使用两个等号,其他使用三个等号
2. blob对象表示一个不可变、原始数据的类文件对象
```
