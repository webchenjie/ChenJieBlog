---
title: 异步
date: 2020-07-04
---

```js
// 异步
1. 同步会阻塞代码,异步不会,基于js是单线程语言,只能同时做一件事
2. js和DOM渲染公用一个线程,因为js可以修改DOM结构
3. 异步应用场景: 网络请求(ajax、图片加载)、定时任务(setTimeout)
4. async/await是消灭异步回调的终极武器
5. js还是单线程,还得是有异步,还得是基于event loop
6. async/await只是一个语法糖 // 语法不一样,实现效果一样
7. await的后面(下面)都可以看做是callback里的内容,即异步
8. for in以及forEach和for是常规的同步变量,一次性全部一起执行,不会等待任何东西,一瞬间遍历完,一瞬间执行几遍
9. for of常用于异步的变量,有顺序,执行完一个再执行下一个
----------------------------------------------------------------------------------------------
// promise
1. 通过promise这个构造函数来创建一个对象
2. 这个promise对象,有三种状态pending(等待)、resolved(成功)、rejected(失败)
3. promise构造函数有一个参数,这个参数是同一个回调,这个回调接收两个参数,都能改变
4. promise对象的状态,第一个参数可以将状态从pending变成resolved,第二个将pending变成rejected
5. then有两个参数第一个代表成功,第二个代表失败
6. 在使用promise时,在then最后记得return promise实例或promise对象,以便可以影响的后面的then操作
7. 初始化promise时,传入的函数会立刻被执行
8. then正常返回resolved,里面有报错则返回rejected
9. catch正常返回resolved,里面有报错则返回rejected
10. rejected触发catch回调
11. resolved触发then回调
12. const promise = new Promise((resolve, reject) => {
      setTimeout(function() {
        let num = Math.floor(Math.random() * 100)
        if (num % 2 === 0) {
          resolve(num) // 成功
        } else {
          reject(num) // 失败
        }
      }, 1000)
   })
   promise.then(num => {
     return `resolve${num}` // 成功
   })
   promise.catch(num => {
     return `reject${num}` // 失败
   })
   Promise.all([p1, p2]).then(resolve => {}, reject => {}) // 整合,全部都有才能继续
   Promise.race([p1, p2]).then(resolve => {}, reject => {}) // 竞争,谁快用谁
----------------------------------------------------------------------------------------------
// js 执行顺序
1. 从前往后,一行一行执行
2. 如果有执行报错,则停止下面的代码运行
3. 先把同步执行完再执行异步
----------------------------------------------------------------------------------------------
// event loop
1. call stack // 调用栈
2. webApis // 宏任务挂起的地方
3. micro task queue // 微任务挂起的地方
4. callback queue // event loop每次查询的地方
5. event loop // 永动机查询
----------------------------------------------------------------------------------------------
// event loop (事件循环/事件轮询)
1. 同步代码,一行一行放在call stack调用栈执行
2. 遇到异步,会先记录下来,等待时机(定时、网络请求等)
3. 时机到了,就移动到callback queue
4. 如果call stack为空(即同步代码执行完),Event Loop开始工作
5. 轮询查找callback queue,如有则移动到call stack执行
6. 然后继续轮询查找(永动机一样)
----------------------------------------------------------------------------------------------
// 宏任务和微任务
1. 宏任务: setTimeout、setInterval、ajax、DOM事件
2. 微任务: promise、async/await、process.nextTick
3. 微任务比宏任务执行时机要早
----------------------------------------------------------------------------------------------
// 宏任务和微任务的区别
1. 宏任务会在DOM渲染后触发,微任务在DOM渲染前触发
2. 宏任务是ES6(ECMA)语法规定的,微任务是浏览器规定的(W3C)
3. 宏任务会等待时机放在webApis中再去放到callback queue中
4. 微任务会等待时机放到micro task queue中
----------------------------------------------------------------------------------------------
// 有宏任务和微任务的event loop
1. 当call stack每次轮询清空后
2. 会执行当前的微任务
3. 再尝试DOM渲染
4. 再触发event loopp
----------------------------------------------------------------------------------------------
// DOM事件和event loop关系
1. js是单线程的
2. 异步(setTimeout、ajax等),使用回调,基于event loop
3. DOM事件也使用回调,基于event loop
----------------------------------------------------------------------------------------------
// DOM渲染和event loop关系
1. call stack空闲时(call stack清空,同步代码执行完,每次轮询结束)会先执行当前的微任务
2. 尝试DOM渲染,如果DOM结构有改变则重新渲染
3. 再去触发event loop
```
