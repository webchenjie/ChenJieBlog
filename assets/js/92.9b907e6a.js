(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{688:function(e,v,t){"use strict";t.r(v);var l=t(11),_=Object(l.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),t("p",[e._v("render 函数的作用就是根据 vnode 去渲染对应的 DOM 元素，其中会根据 vnode 中的类型去创建不同的 DOM 节点")]),e._v(" "),t("h2",{attrs:{id:"过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[e._v("#")]),e._v(" 过程")]),e._v(" "),t("p",[e._v("以下主要分析 Element 元素节点类型的挂载更新逻辑")]),e._v(" "),t("h3",{attrs:{id:"挂载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#挂载"}},[e._v("#")]),e._v(" 挂载")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("如果新节点是空的并且旧节点存在，则会执行删除动作")])]),e._v(" "),t("li",[t("p",[e._v("触发 patch 方法，根据 vnode 中的 type 和 shapeFlag 的值来确定要进行哪种类型的节点挂载（shapeFlag 使用 "),t("code",[e._v("按位与")]),e._v(" 运算计算）")])])]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("按位与")]),e._v(" 运算可以简单理解为是把数值变成 32 位的二进制进行相比，只有两个都为 1 结果才是 1，否则就是 0，然后再把二进制转为十进制")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("确定了类型，就可以进行挂载操作，挂载函数会判断是否有旧节点，如果有则是更新，如果没有则是挂载")])]),e._v(" "),t("li",[t("p",[e._v("挂载逻辑")]),e._v(" "),t("ul",[t("li",[e._v("生成 DOM 标签")]),e._v(" "),t("li",[e._v("生成标签中的内容")]),e._v(" "),t("li",[e._v("处理 props（class/style）")]),e._v(" "),t("li",[e._v("挂载节点")])])]),e._v(" "),t("li",[t("p",[e._v("挂载后会把当前的 vnode 保存在 DOM 元素上，标识为旧节点")])])]),e._v(" "),t("h3",{attrs:{id:"更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更新"}},[e._v("#")]),e._v(" 更新")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("触发 patchElement 方法，在里面主要更新子节点和更新 props")])]),e._v(" "),t("li",[t("p",[e._v("如果新旧两个节点的 type 和 key 相同，则会认为是同一个节点，如果是不同类型的节点进行更新，会直接把旧节点进行删除，然后进行新节点的挂载")])]),e._v(" "),t("li",[t("p",[e._v("diff")])])]),e._v(" "),t("h3",{attrs:{id:"文本节点、注释节点、片段节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文本节点、注释节点、片段节点"}},[e._v("#")]),e._v(" 文本节点、注释节点、片段节点")]),e._v(" "),t("ul",[t("li",[e._v("对于这三种节点的挂载更新比较简单，这边不描述，原理也是直接调用 DOM API")])]),e._v(" "),t("h2",{attrs:{id:"属性相关的操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性相关的操作"}},[e._v("#")]),e._v(" 属性相关的操作")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("class 和其他属性的挂载逻辑")]),e._v(" "),t("ul",[t("li",[e._v("如果是 class，则通过 el.className 挂载")]),e._v(" "),t("li",[e._v("实际上 class 的设置可以通过 el.className 和 el.setAttribute 进行设置，Vue 使用 el.className 设置的原因是 className 比 setAttribute 的性能要好")])])]),e._v(" "),t("li",[t("p",[e._v("style 属性挂载逻辑")]),e._v(" "),t("ul",[t("li",[e._v("如果是 '--' 开头的，则认为是 CSS 变量，会使用 style.setProperty 进行挂载")]),e._v(" "),t("li",[e._v("如果是 style 和 class 逻辑差不多，都是循环遍历通过 el.style.xxx = xxx 进行赋值")]),e._v(" "),t("li",[e._v("赋值后会缓存 style 的值，如果后面再次改变了 style，会判断新的 style 有没有包含旧的 style，如果没有，则会把旧的进行移除")])])]),e._v(" "),t("li",[t("p",[e._v("其他属性的挂载逻辑")]),e._v(" "),t("ul",[t("li",[e._v("如果是 value，则通过 el.value 挂载")]),e._v(" "),t("li",[e._v("如果是 el 中的某个属性（key in el），则通过 el[key] = xxx 挂载")]),e._v(" "),t("li",[e._v("如果是其他属性，则通过 el.setAttribute 挂载")])])]),e._v(" "),t("li",[t("p",[e._v("事件的挂载逻辑")]),e._v(" "),t("ul",[t("li",[e._v("本质通过 addEventListener 进行事件添加，通过 removeEventListener 进行事件移除")]),e._v(" "),t("li",[e._v("会过滤掉 onUpdate 的事件，这个是 v-model 的事件")]),e._v(" "),t("li",[e._v("在事件中，Vue 通过 vei 即 vue event invokers 进行事件回调缓存，如果是同一个事件，一开始的回调函数是 A，后面改成了回调函数 B，这种情况不会进行多次 add 和 remove，而是通过改变 vei 中的回调函数，因为 add 和 remove 会消耗性能")])])])])])}),[],!1,null,null,null);v.default=_.exports}}]);