(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{562:function(e,s,a){"use strict";a.r(s);var n=a(4),t=Object(n.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"nodejs-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-是什么"}},[e._v("#")]),e._v(" nodejs 是什么？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. nodejs 是基于 Chrome V8 引擎的 javascript 运行时\n2. nodejs 出现之前，js 只能在浏览器运行\n3. nodejs 出现之后，js 可以在任何安装 nodejs 的环境运行\n")])])]),a("h2",{attrs:{id:"nodejs-和前端-js-的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-和前端-js-的区别是什么"}},[e._v("#")]),e._v(" nodejs 和前端 js 的区别是什么？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. 语法\n  都是使用 ES 语法\n  前端 js 使用 web API，如 DOM、BOM 等\n  nodejs 使用 node API，如 http、querystring 等\n2. 应用\n  前端 js 用于网页，在浏览器运行\n  nodejs 可用于服务端，如开发 web server\n  nodejs 也可用于本机，如 webpack 等本机的工具\n")])])]),a("h2",{attrs:{id:"nodejs-如何调试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-如何调试"}},[e._v("#")]),e._v(" nodejs 如何调试？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. 启动 nodejs 服务时，使用 inspect，如 node --inspect-brk index.js\n2. 代码中使用 debugger 断点\n3. 使用 chrome 调试，chrome://inspect\n")])])]),a("h2",{attrs:{id:"如何获取当前文件和当前目录的路径"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何获取当前文件和当前目录的路径"}},[e._v("#")]),e._v(" 如何获取当前文件和当前目录的路径？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. __filename\n2. __dirname\n3. 两个都是全局变量\n")])])]),a("h2",{attrs:{id:"commonjs-和-es6-module-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-和-es6-module-的区别"}},[e._v("#")]),e._v(" commonjs 和 ES6 Module 的区别？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. 语法不同\n2. commonjs 是动态引入，执行时引入\n3. ES6 Module 是静态引入，编译时引入，需要放在最外层顶部引入，webpack tree shaking 只支持 ES6 Module\n")])])]),a("h2",{attrs:{id:"path-resolve-和-path-join-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#path-resolve-和-path-join-的区别"}},[e._v("#")]),e._v(" path.resolve 和 path.join 的区别？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. 两者都是用于拼接文件路径\n2. path.resolve 获取绝对路径\n3. path.join 获取相对路径或拼接路径\n")])])]),a("h2",{attrs:{id:"event-loop-在浏览器和-nodejs-中的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-在浏览器和-nodejs-中的区别"}},[e._v("#")]),e._v(" event loop 在浏览器和 nodejs 中的区别？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. 浏览器 js 的异步\n  1. 宏任务：setTimeout、setInterval、ajax 等\n  2. 微任务：promise、async/await\n  3. 微任务比宏任务更早执行\n2. 浏览器的 event loop\n  1. call stack 空闲时，将触发 event loop 机制，执行宏任务\n  2. 而触发 event loop 之前，会把现有的微任务都执行完\n  3. 所以微任务比宏任务执行时机更早\n3. nodejs 的异步\n  1. 宏任务：setTimeout、setInterval、setImmediate、I/O 文件、网络、socket 连接，如连接 mysql\n  2. 微任务：promise、async/await、process.nextTick\n4. nodejs 的 event loop\n  1. 因为 nodejs 中的微任务不多，宏任务类型较多，如果宏任务都放在 callback queue 中就不好管理\n  2. nodejs 事件循环的分为 6 个阶段（宏任务）\n    1. timer ——> I/O ——> idle，prepare ——> poll ——> check ——> close callback\n    2. timer：执行 setTimeout 以及 setInterval 的回调\n    3. I/O：callback 处理网络、流、TCP 的错误回调\n    4. idle，prepare：闲置阶段，node 内部使用\n    5. poll：执行 poll 中的 I/O 队列，检查定时器是否到时间\n    6. check：存放 setImmediate 回调\n    7. close callback：关闭回调，例如 socket.on('close')\n  3. 原则上还是先执行微任务再执行宏任务，而宏任务的执行顺序通过上面的 6 个阶段执行\n  4. 微任务中，process.nextTick 优先级最高，最早被执行 （process.nextTick 现已不推荐使用，因为会阻塞 IO）\n  5. 细节\n    1. setTimeout 比 setImmediate 执行更早\n    2. process.nextTick 比 promise.then 执行更早\n    3. 建议用 setImmediate 代替 process.nextTick\n  6. 区别\n    1. nodejs 异步 API 更多，宏任务类型也更多\n    2. nodejs 的 event loop 分为 6 个阶段，要按照顺序执行\n    3. 微任务中 process.nextTick 优先级更高\n")])])]),a("h2",{attrs:{id:"session-如何实现登录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#session-如何实现登录"}},[e._v("#")]),e._v(" session 如何实现登录？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. cookie 如何实现登录校验\n  1. 前端登录成功后，服务端会设置 cookie，当前端进行其他操作时会带上 cookie，服务端进行校验\n2. session 和 cookie 的关系\n  1. 当在 cookie 中存储敏感信息时会不安全，则换成存储 userId，对应到服务端则是用户信息\n3. session 为何需要存储在 redis 中\n  1. 进程有内存限制\n  2. 进程的内存是相互隔离的\n  3. 存储到 redis 中，可解决这些问题\n")])])]),a("h2",{attrs:{id:"描述-koa2-和-express-的中间件机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述-koa2-和-express-的中间件机制"}},[e._v("#")]),e._v(" 描述 koa2 和 express 的中间件机制？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. 从代码来看，中间件就是一个函数\n2. 从业务来看，中间件则是一个独立的模块\n3. 模块拆分，模块流转，即可完成复杂的功能\n")])])]),a("h2",{attrs:{id:"nodejs-如何读取大文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-如何读取大文件"}},[e._v("#")]),e._v(" nodejs 如何读取大文件？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. stream —— 流\n2. 1G 大小的 access.log\n3. 分析其中的 Chrome 浏览器占比\n4. 考虑 cpu 和内存的限制\n")])])]),a("h2",{attrs:{id:"nodejs-线上为何开启多进程-pm2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-线上为何开启多进程-pm2"}},[e._v("#")]),e._v(" nodejs 线上为何开启多进程？（pm2）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("1. 高效使用多核 CPU\n2. 充分利用服务器内存\n3. 最终：压榨服务器，不浪费资源\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",[e._v("作者：chenjie "),a("br"),e._v("\n链接：https://webchenjie.cn "),a("br"),e._v("\n来源：ChenJieBlog")])])])}),[],!1,null,null,null);s.default=t.exports}}]);