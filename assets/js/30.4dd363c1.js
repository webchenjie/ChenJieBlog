(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{626:function(t,n,a){"use strict";a.r(n);var s=a(11),e=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"ieee-754-计算步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ieee-754-计算步骤"}},[t._v("#")]),t._v(" IEEE 754 计算步骤")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. 指数对阶\n  1. 小阶对大阶，会右移，容易丢失位数\n  2. 相加或相减，值可以溢出\n2. 尾数运算\n  1. 尾数运算就是在完成对阶以后进行尾数相加减\n3. 结果规格化\n  1. 左移规格化，右移可能精度丢失\n4. 舍入处理\n  1. 四舍五入，1入0舍（默认）\n  2. 朝正无穷方向舍入\n  3. 朝负无穷方向舍入\n  4. 朝0方向舍入\n5. 溢出检查\n  1. 运算结果的阶码的值判断是否溢出\n  2. 超过最大正数（上溢）：浮点数正数是正上溢，否则是负上溢\n")])])]),a("h2",{attrs:{id:"双精度-64-举例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双精度-64-举例"}},[t._v("#")]),t._v(" 双精度 64 举例")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. 符号位（1位）+ 指数位（11位）+ 尾数（52位）\n2. 符号位中，1 表示负数，0 表示正数\n3. 指数位中，指数 = 指数 + 1023（偏移码）\n4. 尾数中，默认存储 1 后面部分，小数部分\n")])])]),a("h2",{attrs:{id:"_0-1-0-2-0-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-0-2-0-3"}},[t._v("#")]),t._v(" 0.1 + 0.2 !== 0.3")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1. js采用的是 IEEE 754 标准，其中有俩个标准一种是 64 位双精度浮点数，一种是 32 为单精度浮点数\n   这俩种标准主要的区别在于数的范围的大小\n2. 32 位的尾数一共 23 个字符。最多表示 23 个 1 也就是数字 2^23(8388608)。当值大于这个数的时候就会超过 23 位\n   因此就没法计算了。（64 位也是相同的道理）\n3. 在计算的时候并不是先将 10 进制数计算完成在存储为 2 进制。而是会先将 10 进制转换为二进制在计算\n4. 0.1或0.2在转换二进制数时是个无限循环小数，会出现小数丢失情况，所以0.1 + 0.2 !== 0.3\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("作者：chenjie "),a("br"),t._v("\n链接：https://webchenjie.cn "),a("br"),t._v("\n来源：ChenJieBlog")])])])}),[],!1,null,null,null);n.default=e.exports}}]);