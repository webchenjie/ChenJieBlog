(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{556:function(a,t,e){"use strict";e.r(t);var s=e(4),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"v-show-和-v-if-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-show-和-v-if-的区别"}},[a._v("#")]),a._v(" v-show 和 v-if 的区别？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("v-show通过css display控制显示和隐藏\nv-if组件真正的渲染和销毁,而不是显示和隐藏\n频繁的切换显示状态用v-show,否则用v-if\n")])])]),e("h2",{attrs:{id:"为何在-v-for-中用-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为何在-v-for-中用-key"}},[a._v("#")]),a._v(" 为何在 v-for 中用 key？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("必须用key,且不能是index和随机数\ndiff算法中通过tag和key来判断,是否是sameNode\n减少渲染次数,提升渲染性能\n")])])]),e("h2",{attrs:{id:"vue-组件如何通讯-常见"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件如何通讯-常见"}},[a._v("#")]),a._v(" vue 组件如何通讯,常见？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("父子组件props和this.$emit\n自定义事件event.$on、event.$off、event.$emit // 总线bus\n$attrs\nprovide/inject\n$ref\n$parent\nvuex\n")])])]),e("h2",{attrs:{id:"双向数据绑定-v-model-的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定-v-model-的实现原理"}},[a._v("#")]),a._v(" 双向数据绑定 v-model 的实现原理？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("input元素的value = this.name\n绑定input事件this.name = $event.target.value\ndata更新触发re-render\n")])])]),e("h2",{attrs:{id:"对-mvvm-的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对-mvvm-的理解"}},[a._v("#")]),a._v(" 对 MVVM 的理解？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("M: Model层,即数据库\nV: View层,即视图层DOM\nVM: 即Vue\n")])])]),e("h2",{attrs:{id:"computed-有何特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-有何特点"}},[a._v("#")]),a._v(" computed 有何特点？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("有缓存,data不变不会重新计算\n提高性能\n")])])]),e("h2",{attrs:{id:"为何组件-data-必须是一个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为何组件-data-必须是一个函数"}},[a._v("#")]),a._v(" 为何组件 data 必须是一个函数？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("vue文件最后编译出来是一个class\n只有data是一个函数才能做到在不同的地方使用时data数据不共享\n")])])]),e("h2",{attrs:{id:"ajax-请求应该放在哪个生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajax-请求应该放在哪个生命周期"}},[a._v("#")]),a._v(" ajax 请求应该放在哪个生命周期？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("mounted\njs是单线程,ajax异步获取数据\n放在mounted之前是没有用的,只会让逻辑更加混乱\n")])])]),e("h2",{attrs:{id:"如何将组件所有-props-传递给子组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何将组件所有-props-传递给子组件"}},[a._v("#")]),a._v(" 如何将组件所有 props 传递给子组件？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('<组件名 v-bind="$props" />\n')])])]),e("h2",{attrs:{id:"多个组件有相同的逻辑-如何抽离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多个组件有相同的逻辑-如何抽离"}},[a._v("#")]),a._v(" 多个组件有相同的逻辑,如何抽离？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  mixin\n")])])]),e("h2",{attrs:{id:"何时要使用异步组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何时要使用异步组件"}},[a._v("#")]),a._v(" 何时要使用异步组件？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  加载大组件\n  路由异步加载\n  优化性能\n")])])]),e("h2",{attrs:{id:"何时需要使用-keep-alive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何时需要使用-keep-alive"}},[a._v("#")]),a._v(" 何时需要使用 keep-alive？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  缓存组件,不需要重复渲染\n  如多个静态tab页的切换\n  优化性能\n")])])]),e("h2",{attrs:{id:"何时需要使用-beforedestory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何时需要使用-beforedestory"}},[a._v("#")]),a._v(" 何时需要使用 beforeDestory？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  解绑自定义事件evnet.$off\n  清除定时器\n  解绑自定义的DOM事件,如window.scroll等\n  vue事件会自动解除,自定义则需要自己解除\n")])])]),e("h2",{attrs:{id:"vuex-中-action-和-mutation-有区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-中-action-和-mutation-有区别"}},[a._v("#")]),a._v(" vuex 中 action 和 mutation 有区别？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  action中处理异步,mutation不可以\n  mutation做原子操作\n  action可以整合多个mutation\n")])])]),e("h2",{attrs:{id:"vue-router-常用的路由模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-常用的路由模式"}},[a._v("#")]),a._v(" vue-router 常用的路由模式？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  - hash默认\n        - 实现原理：window.location.hash\n  - H5 history 需要服务端支持\n        - 实现原理：window.history.pushState 推送路由 + window.onpopstate 监听路由变化\n  - abstract history，Vue3 改名为 memory history，即 url 不会发生变化，没有前进后退\n")])])]),e("h2",{attrs:{id:"如何配置-vue-router-异步加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何配置-vue-router-异步加载"}},[a._v("#")]),a._v(" 如何配置 vue-router 异步加载？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  使用函数返回import\n  component: () => import('路径')\n")])])]),e("h2",{attrs:{id:"请用-vnode-描述一个-dom-结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请用-vnode-描述一个-dom-结构"}},[a._v("#")]),a._v(" 请用 vnode 描述一个 DOM 结构？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  看上面vdom\n")])])]),e("h2",{attrs:{id:"监听-data-变化的核心-api-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#监听-data-变化的核心-api-是什么"}},[a._v("#")]),a._v(" 监听 data 变化的核心 API 是什么？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  Object.defineProperty\n  以及深度监听、监听数组\n  具体看上面响应式\n")])])]),e("h2",{attrs:{id:"vue-如何监听数组变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-如何监听数组变化"}},[a._v("#")]),a._v(" vue 如何监听数组变化？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  Object.defineProperty不能监听数组变化\n  重新定义原型,重写push、pop等方法,实现监听\n  具体看上面响应式\n")])])]),e("h2",{attrs:{id:"请描述响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请描述响应式原理"}},[a._v("#")]),a._v(" 请描述响应式原理？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  监听data变化\n  组件渲染和更新的流程\n")])])]),e("h2",{attrs:{id:"diff-算法的时间复杂度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法的时间复杂度"}},[a._v("#")]),a._v(" diff 算法的时间复杂度？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  O(n)\n  在O(n^3)基础上做了一下调整\n")])])]),e("h2",{attrs:{id:"简述-diff-算法过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简述-diff-算法过程"}},[a._v("#")]),a._v(" 简述 diff 算法过程？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  patch(ele, vnode)和patch(oldVnode, newVnode)\n  patchVnode和addVnodes和removeVnodes\n  updatechildren // key的重要性\n")])])]),e("h2",{attrs:{id:"vue2、vue3、react-三者-diff-算法的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2、vue3、react-三者-diff-算法的区别"}},[a._v("#")]),a._v(" Vue2、Vue3、React 三者 diff 算法的区别？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  Vue2 - 双端比较\n  Vue3 - 在 Vue2 的基础上，增加最长递增子序列\n  React - 仅右移\n")])])]),e("h2",{attrs:{id:"vue-为何是异步渲染-nexttick-何用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-为何是异步渲染-nexttick-何用"}},[a._v("#")]),a._v(" vue 为何是异步渲染,$nextTick 何用？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  异步渲染(以及合并data修改),以提高渲染性能\n  $nextTick在DOM更新完之后,触发回调\n")])])]),e("h2",{attrs:{id:"vue-常见性能优化方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-常见性能优化方式"}},[a._v("#")]),a._v(" vue 常见性能优化方式？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  合理使用v-show和v-if\n  合理使用computed\n  v-for时加key,以及避免和v-if同时使用\n  自定义事件、DOM事件及时销毁\n  合理使用异步组件\n  合理使用keep-alive\n  data层级不要太深\n  使用vue-loader在开发环境做模板编译 // 预编译\n  webpack层面的优化\n  前端通用的性能优化,如图片懒加载 // 具体看js的性能和安全\n  使用SSR\n")])])]),e("h2",{attrs:{id:"data-状态设计和组件设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#data-状态设计和组件设计"}},[a._v("#")]),a._v(" data 状态设计和组件设计？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  data状态设计:\n    用数据描述所有内容\n    数据要结构化,易于程序操作(遍历、查找)\n    数据要可扩展,以便增加新的功能\n  组件设计:\n    从功能上拆分层次\n    尽量让组件原子化\n    容器组件(只管理数据)\n    UI组件(只显示视图)\n")])])]),e("div",{staticClass:"custom-block tip"},[e("p",[a._v("作者：chenjie "),e("br"),a._v("\n链接：https://webchenjie.cn "),e("br"),a._v("\n来源：ChenJieBlog")])])])}),[],!1,null,null,null);t.default=r.exports}}]);