(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{688:function(e,t,l){"use strict";l.r(t);var v=l(11),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,l=e._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[l("h2",{attrs:{id:"_1-简介"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[e._v("#")]),e._v(" 1. 简介")]),e._v(" "),l("p",[e._v("render 函数的作用就是根据 vnode 去创建对应的 DOM 元素，其中会根据 vnode 中的类型去创建不同的 DOM 节点")]),e._v(" "),l("h2",{attrs:{id:"_2-挂载"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-挂载"}},[e._v("#")]),e._v(" 2. 挂载")]),e._v(" "),l("ul",[l("li",[l("p",[e._v("触发 patch 方法，根据 vnode 中的 type 和 shapeFlag 的值来确定要进行哪种类型的节点挂载")])]),e._v(" "),l("li",[l("p",[e._v("在挂载方法中，会根据旧节点是否存在，从而进行挂载节点或更新节点的操作")])]),e._v(" "),l("li",[l("p",[e._v("挂载逻辑")]),e._v(" "),l("ul",[l("li",[e._v("生成 DOM 标签")]),e._v(" "),l("li",[e._v("生成标签中的内容")]),e._v(" "),l("li",[e._v("处理属性内容（class/style）")]),e._v(" "),l("li",[e._v("挂载节点")])])]),e._v(" "),l("li",[l("p",[e._v("挂载后会把当前的 vnode 保存在 DOM 元素上，标识为旧节点")])]),e._v(" "),l("li",[l("p",[e._v("如果新节点是空的并且旧节点存在，Vue 会直接把旧节点删除")])]),e._v(" "),l("li",[l("p",[e._v("属性的挂载逻辑")]),e._v(" "),l("ul",[l("li",[e._v("如果是 class，则通过 el.className 挂载")]),e._v(" "),l("li",[e._v("如果是其他属性，则通过 el.setAttribute 挂载")]),e._v(" "),l("li",[e._v("如果是 value，则通过 el.value 挂载")]),e._v(" "),l("li",[e._v("实际上 class 的设置可以通过 el.className 和 el.setAttribute 进行设置，Vue 使用 el.className 设置的原因是 className 比 setAttribute 的性能要好")])])])]),e._v(" "),l("h2",{attrs:{id:"_3-更新"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-更新"}},[e._v("#")]),e._v(" 3. 更新")]),e._v(" "),l("ul",[l("li",[l("p",[e._v("更新子节点，其中会 diff 算法的逻辑")])]),e._v(" "),l("li",[l("p",[e._v("更新节点的属性，包含新的属性和旧的属性")])]),e._v(" "),l("li",[l("p",[e._v("当新节点和旧节点不相同时，Vue 会直接把旧节点给删除，然后执行新节点的挂载")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);